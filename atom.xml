<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SuooL&#39;s Blog</title>
  
  <subtitle>蛰伏于盛夏 藏华于当春</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suool.net/"/>
  <updated>2018-07-24T14:50:20.659Z</updated>
  <id>http://suool.net/</id>
  
  <author>
    <name>SuooL</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>决策树及其在手写数字识别的实践</title>
    <link href="http://suool.net/2018/07/19/Mnist-With-Decision-Tree-ID3/"/>
    <id>http://suool.net/2018/07/19/Mnist-With-Decision-Tree-ID3/</id>
    <published>2018-07-19T02:32:03.000Z</published>
    <updated>2018-07-24T14:50:20.659Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>决策时是一种基本的分类和回归方法，现在主要讨论分类决策树。决策树模型呈树形结构，在分类问题中，表示基本特征对实例进行分类的过程，你可以认为他是一个 <code>if-then</code> 的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。<br><a id="more"></a></p><p>其优点是模型具有可读性，分类速度快，学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型。预测的时，对新的数据利用训练建立的决策树模型来分类。</p><p>决策树学习分为三个步骤：特征选择、决策树生成和决策树的剪枝。主要的决策树生成算法有 ID3 算法、C4.5 算法、 CART 算法。</p><p>本文的大纲如下：</p><ol><li>介绍决策树模型的基本概念</li><li>决策树的特征选择和学习过程</li><li>以 ID3 算法为例进行手写数字识别实践</li></ol><h2 id="决策树模型的基本概念"><a href="#决策树模型的基本概念" class="headerlink" title="决策树模型的基本概念"></a>决策树模型的基本概念</h2><h3 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h3><p>分类决策树是一种描述对实例进行分类的树形结构。决策树由节点和有向边组成，节点分为两类：内部结点和叶节点。内部结点表示一个特征或者属性，叶节点表示一个分类。</p><p>用决策树分类的过程类似于一系列的 <code>if-then</code> 判断，如下图的一个决策树，圆和方框分别表示内部节点和叶节点，决策分类过程是这样的：首先从顶端的根节点出发，每个内部结点都是一个特征判断，即是 <code>if-then</code>  判断，如果满足特征是一种路径，不满足特征是另一条路径。</p><p><img src="https://suool-bolg.b0.upaiyun.com/2018/07/24/D295E3E5-FD3E-4509-BBA7-D80D26317A61.png" alt="D295E3E5-FD3E-4509-BBA7-D80D26317A61"></p><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习，假设给定训练数据集：</p><script type="math/tex; mode=display">D=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}</script><p>其中，$x_i = (x_i^1,x_i^2,\cdots,x_i^n)$ 为输入实力（特征向量），n为特征个数， $y_i\in{1,2,\cdots,K}$为类标记，$i=1,2,\cdots,N$，N 为样本容量。学习的目标是根据给定的训练数据集构建一个决策树模型，使他能够进行正确的分类。</p><p>而通过上面决策树的概念介绍，我们可以知道，决策树学习本质上是从训练数据集中归纳出一组分类规则。与训练数据集不相矛盾的决策树（即是能对训练数据进行正确分类的决策树）可能有多个，有可能一个都没有。我们需要的是一个与训练数据矛盾较小的决策树，同时有较好的泛化能力。</p><p>决策树学习的损失函数通常是正则化的极大似然函数。决策树学习的策略也自然是以损失函数为目标函数的最小化。而这是一个 NP 问题，所以一般采用启发式的方法求得一个次最优解。</p><p>决策树学习的算法通常是一个递归的选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。</p><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>特征选择在于选取对训练数据具有分类能力的特征，这样可以提高决策树学习的效率，而衡量特征分类效果的函数就是信息增益函数。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>信息增益是信息论中的概念，了解信息增益，首先要了解熵和条件熵的定义。<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/24/02E0F04F-0D7E-463B-BBEC-92B7909204F8.png" alt="熵的定义"><br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/24/E16F35E0-799D-4CD7-8927-2CCC0BFBBC17.png" alt="条件熵"></p><p><strong>信息增益的定义</strong>：特征 A 对训练集 D 对信息增益   g(D,A)，定义为集合 D 的经验熵 H(D) 与特征 A 给定的条件下 D 的经验条件熵 H(D|A) 之差，即是：</p><script type="math/tex; mode=display">g(D,A) = H(D)-H(D|A)</script><p><strong>信息增益算法</strong></p><ul><li>基本假设<br>  <img src="https://suool-bolg.b0.upaiyun.com/2018/07/24/D145C82E-3CEC-40BA-BBA3-223CC39CE9AB.png" alt="基本元素定义"></li></ul><p>于是信息增益算法如下：<br><strong>输入</strong>：训练数据集 D 和特征 A；<br><strong>输出</strong>：特征 A 对训练数据集 D 的信息增益 g(D,A)<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/24/18A795F2-9690-479B-B780-B893C562ED4D.png" alt="算法步骤"></p><h2 id="决策树生成"><a href="#决策树生成" class="headerlink" title="决策树生成"></a>决策树生成</h2><p>ID3 算法的核心是在决策树各个节点上应用信息增益准则选择特征，递归的构建决策树。具体点方法是：从根结点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同取值建立子节点；再对子节点递归的调用以上方法，构建决策树；知道所有的特征的信心增益均很小或者没有特征可以选择为止。最后得到一个决策树，ID3 算法相当于用最大似然估计进行概率模型的选择。</p><h3 id="ID3-算法"><a href="#ID3-算法" class="headerlink" title="ID3 算法"></a>ID3 算法</h3><p><strong>输入：</strong>训练数据 D，特征集 A，阈值 $\epsilon$<br><strong>输出：</strong>决策树<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/24/A2008824-0C64-4C99-AB08-27B6AD708FE0.png" alt="ID3-1"><br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/24/5D4D317A-2635-47DC-81B5-CCF172A6BD72.png" alt="ID3-2"></p><p>ID3 算法只有树的生成，所以其生成的树很容易过拟合。</p><p>以下为该算法的代码在 Mnist 数据集上实现的准确率，86.7%，比不上 KNN 的准确度，但是速度比其快的多。</p><p><img src="https://suool-bolg.b0.upaiyun.com/2018/07/24/8959541E-8E3F-4094-997E-C839D795ACA9.png" alt="预测准确率"></p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> testLibrary <span class="keyword">as</span> tl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALL_DATA = <span class="number">60000</span></span><br><span class="line"></span><br><span class="line">total_class = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        logging.debug(<span class="string">'start %s()'</span> % func.__name__)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        end_time = time.time()</span><br><span class="line">        logging.debug(<span class="string">'end %s(), cost %s seconds'</span> % (func.__name__,end_time-start_time))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二值化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryzation</span><span class="params">(img)</span>:</span></span><br><span class="line">    cv_img = img.astype(np.uint8)</span><br><span class="line">    cv2.threshold(cv_img,<span class="number">50</span>,<span class="number">1</span>,cv2.cv.CV_THRESH_BINARY_INV,cv_img)</span><br><span class="line">    <span class="keyword">return</span> cv_img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryzation_features</span><span class="params">(trainset)</span>:</span></span><br><span class="line">    features = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> trainset:</span><br><span class="line">        img = np.reshape(img,(<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">        cv_img = img.astype(np.uint8)</span><br><span class="line"></span><br><span class="line">        img_b = binaryzation(cv_img)</span><br><span class="line">        <span class="comment"># hog_feature = np.transpose(hog_feature)</span></span><br><span class="line">        features.append(img_b)</span><br><span class="line"></span><br><span class="line">    features = np.array(features)</span><br><span class="line">    features = np.reshape(features, (<span class="number">-1</span>, <span class="number">784</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node_type, Class=None, feature=None)</span>:</span></span><br><span class="line">        self.node_type = node_type</span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">        self.Class = Class</span><br><span class="line">        self.feature = feature</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_tree</span><span class="params">(self, val, tree)</span>:</span></span><br><span class="line">        self.dict[val] = tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, features)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.node_type == <span class="string">'leaf'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.Class</span><br><span class="line"></span><br><span class="line">        tree = self.dict[features[self.feature]]</span><br><span class="line">        <span class="keyword">return</span> tree.predict(features)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_ent</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        calculate shanno ent of x</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    x_value_list = set([x[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(x.shape[<span class="number">0</span>])])</span><br><span class="line">    ent = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> x_value <span class="keyword">in</span> x_value_list:</span><br><span class="line">        p = float(x[x == x_value].shape[<span class="number">0</span>]) / x.shape[<span class="number">0</span>]</span><br><span class="line">        logp = np.log2(p)</span><br><span class="line">        ent -= p * logp</span><br><span class="line">    <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_condition_ent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        calculate ent H(y|x)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># calc ent(y|x)</span></span><br><span class="line">    x_value_list = set([x[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(x.shape[<span class="number">0</span>])])</span><br><span class="line">    ent = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> x_value <span class="keyword">in</span> x_value_list:</span><br><span class="line">        sub_y = y[x == x_value]</span><br><span class="line">        temp_ent = calc_ent(sub_y)</span><br><span class="line">        ent += (float(sub_y.shape[<span class="number">0</span>]) / y.shape[<span class="number">0</span>]) * temp_ent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def calc_ent_grap(x,y):</span></span><br><span class="line"><span class="comment">#     """</span></span><br><span class="line"><span class="comment">#         calculate ent grap</span></span><br><span class="line"><span class="comment">#     """</span></span><br><span class="line"><span class="comment">#     base_ent = calc_ent(y)</span></span><br><span class="line"><span class="comment">#     condition_ent = calc_condition_ent(x, y)</span></span><br><span class="line"><span class="comment">#     ent_grap = base_ent - condition_ent</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     return ent_grap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recurse_train</span><span class="params">(train_set, train_label, features, epsilon)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total_class</span><br><span class="line"></span><br><span class="line">    LEAF = <span class="string">'leaf'</span></span><br><span class="line">    INTERNAL = <span class="string">'internal'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤1——如果train_set中的所有实例都属于同一类Ck</span></span><br><span class="line">    label_set = set(train_label)</span><br><span class="line">    <span class="keyword">if</span> len(label_set) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> Tree(LEAF, Class=label_set.pop())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤2——如果features为空</span></span><br><span class="line">    (max_class, max_len) = max([(i, len([x <span class="keyword">for</span> x <span class="keyword">in</span> train_label <span class="keyword">if</span> x == i])) <span class="keyword">for</span> i <span class="keyword">in</span> range(total_class)],key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(features) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> Tree(LEAF, Class=max_class)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤3——计算信息增益</span></span><br><span class="line">    max_feature = <span class="number">0</span></span><br><span class="line">    max_gda = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    d = train_label</span><br><span class="line">    hd = calc_ent(d)</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">        A = np.array(train_set[:, feature].flat)</span><br><span class="line">        gda = hd - calc_condition_ent(A, d)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> gda &gt; max_gda:</span><br><span class="line">            max_gda, max_feature = gda, feature</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤4——小于阈值</span></span><br><span class="line">    <span class="keyword">if</span> max_gda &lt; epsilon:</span><br><span class="line">        <span class="keyword">return</span> Tree(LEAF, Class=max_class)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤5——构建非空子集</span></span><br><span class="line">    sub_features = [x <span class="keyword">for</span> x <span class="keyword">in</span> features <span class="keyword">if</span> x != max_feature]</span><br><span class="line">    tree = Tree(INTERNAL, feature=max_feature)</span><br><span class="line"></span><br><span class="line">    feature_col = np.array(train_set[:, max_feature].flat)</span><br><span class="line">    feature_value_list = set([feature_col[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(feature_col.shape[<span class="number">0</span>])])</span><br><span class="line">    <span class="keyword">for</span> feature_value <span class="keyword">in</span> feature_value_list:</span><br><span class="line"></span><br><span class="line">        index = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(train_label)):</span><br><span class="line">            <span class="keyword">if</span> train_set[i][max_feature] == feature_value:</span><br><span class="line">                index.append(i)</span><br><span class="line"></span><br><span class="line">        sub_train_set = train_set[index]</span><br><span class="line">        sub_train_label = train_label[index]</span><br><span class="line"></span><br><span class="line">        sub_tree = recurse_train(sub_train_set,sub_train_label,sub_features,epsilon)</span><br><span class="line">        tree.add_tree(feature_value,sub_tree)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(train_set, train_label, features, epsilon)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> recurse_train(train_set, train_label, features, epsilon)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(test_set, tree)</span>:</span></span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> features <span class="keyword">in</span> test_set:</span><br><span class="line">        tmp_predict = tree.predict(features)</span><br><span class="line">        result.append(tmp_predict)</span><br><span class="line">    <span class="keyword">return</span> np.array(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_accuracy</span><span class="params">(predict_ary, test)</span>:</span></span><br><span class="line">    right_count = <span class="number">0.0</span></span><br><span class="line">    accuracy_ary = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(predict_ary)):</span><br><span class="line">        <span class="keyword">if</span> predict_ary[index] == test[index]:</span><br><span class="line">            right_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (index + <span class="number">1</span>) % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">                accuracy_ary.append(float(right_count) / (index + <span class="number">1</span>))</span><br><span class="line">        print(<span class="string">"预测值：%d 实际值： %d"</span> % (predict_ary[index], test[index]))</span><br><span class="line">    <span class="keyword">return</span> right_count/len(test), accuracy_ary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取训练数据集和测试数据集的方法和朴素贝叶斯方法一致</span></span><br><span class="line">    print(<span class="string">'Start read train data'</span>)</span><br><span class="line">    time_1 = time.time()</span><br><span class="line">    data_map, labels = tl.loadCSVfile(<span class="string">"data.csv"</span>)</span><br><span class="line">    print(data_map.shape, labels.shape)</span><br><span class="line">    time_2 = time.time()</span><br><span class="line">    print(<span class="string">'read data train cost '</span>, time_2 - time_1, <span class="string">' seconds'</span>, <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Start read predict data'</span>)</span><br><span class="line">    time_3 = time.time()</span><br><span class="line">    test_data_map, test_labels = tl.loadCSVfile(<span class="string">"dataTest.csv"</span>)</span><br><span class="line">    print(test_data_map.shape, test_data_map.shape)</span><br><span class="line">    time_4 = time.time()</span><br><span class="line">    print(<span class="string">'read predict data cost '</span>, time_4 - time_3, <span class="string">' seconds'</span>, <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    tree = train(data_map, labels, [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">784</span>)], <span class="number">0.1</span>)</span><br><span class="line">    test_predict = predict(test_data_map, tree)</span><br><span class="line"></span><br><span class="line">    rate, accuracy = calculate_accuracy(test_predict, test_labels)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"The accuracy score is "</span>, rate)</span><br><span class="line">    new_ticks = np.linspace(<span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">    plt.xticks(new_ticks)</span><br><span class="line">    plt.ylim(ymin=<span class="number">0.7</span>, ymax=<span class="number">1</span>)</span><br><span class="line">    plt.plot(new_ticks, accuracy, <span class="string">'o-'</span>, color=<span class="string">'g'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"x -- 1:500"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"y"</span>)</span><br><span class="line">    plt.title(<span class="string">u"预测准确率"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;决策时是一种基本的分类和回归方法，现在主要讨论分类决策树。决策树模型呈树形结构，在分类问题中，表示基本特征对实例进行分类的过程，你可以认为他是一个 &lt;code&gt;if-then&lt;/code&gt; 的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://suool.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://suool.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>K 近邻法及其在手写数字识别的实践</title>
    <link href="http://suool.net/2018/07/10/Mnist-With-K-Nearest-Neighbor/"/>
    <id>http://suool.net/2018/07/10/Mnist-With-K-Nearest-Neighbor/</id>
    <published>2018-07-10T09:09:08.000Z</published>
    <updated>2018-07-19T02:35:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>k 近邻法（k-nearest-neighbor, KNN）是一种基本的分类和回归方法。现在只讨论其分类方面的应用，它不具备明显的学习过程，实际上是利用已知的训练数据集对输入特征向量空间进行划分，并作为其分类的“模型”。<br><a id="more"></a></p><p>其中 k 值的选择、距离的度量及分类决策规则是 k 近邻模型的三个基本要素。</p><p>本文将按照以下提纲进行：</p><ul><li>k 近邻法阐述</li><li>k 近邻的模型</li><li>k 近邻在手写数字识别上的实战</li></ul><h2 id="k-近邻法阐述"><a href="#k-近邻法阐述" class="headerlink" title="k 近邻法阐述"></a>k 近邻法阐述</h2><p>k 近邻算法非常容易理解，因为其本质上就是求距离，这是非常简单而直观的度量方法：对于给定的一个训练数据集，对新的输入实例 M，在训练数据集中找到与该新实例 M 最邻近的 k 个实例，由这 k 个实例按照一定的表决规则进行投票决策最合适的类别，那么实例 M 就属于这个类。下面是算法的描述：<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/10/CC3A072A-F73B-4A54-A6F9-94EF80316B66.png" alt="CC3A072A-F73B-4A54-A6F9-94EF80316B66"></p><h2 id="k-近邻模型"><a href="#k-近邻模型" class="headerlink" title="k 近邻模型"></a>k 近邻模型</h2><p>k 近邻算法本质上是在超空间内划分区域空间分类的问题，在输入数据集的特征空间内，对于每个训练实例点 $x_i$ ，距离改点比其他点更近的所有点组成一个区域，叫做单元(cell)。上文说了 k 近邻模型的三个要素，k 值选择、距离度量、决策函数，下面一一说明。</p><h3 id="k-值选择"><a href="#k-值选择" class="headerlink" title="k 值选择"></a>k 值选择</h3><p>k 值指的是选择近邻点的数目，如果 k = 1 则是最近邻，即是每次由距离新实例最近的训练点所属的类别决定待分类实例的类别。</p><p>k 值的选择对于 k 近邻法的结果可以产生重大影响。</p><p>当 k 值较小的时候，那么预测学习的近似误差会减少，因为此时只有距离待分类点较近的训练实例才会对于分类预测结果有影响作用，但是缺点是估计误差会增大，因为预测结果会对近邻的实例点非常敏感，如果近邻的实例多数都是噪声点，那么就很容易导致预测出错。即是说，k 值的减少意味着模型变得复杂，容易发生过拟合。</p><p>当 k 值较大的时候，就相当于用较大邻域中的训练实例进行预测。其优点是可以减少学习的估计误差。但缺点是学习的近似误差会增大，这时与输入实例较远的（不相似的）训练实例也会对预测起作用，使预测发生错误。k 值的增大就意味着整体的模型变得简单。</p><p>如果 k = N，那么无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类。这时，模型过于简单，完全忽略训练实例中的大量有用信息，是不可取的。</p><p>在应用中，k 值一般取一个比较小的数值。通常采用交叉验证法来选取最优的 k 值。</p><h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>在实数域中，数的大小和两个数之间的距离是通过绝对值来度量的。在解析几何中，向量的大小和两个向量之差的大小是“长度”和“距离”的概念来度量的。为了对矩阵运算进行数值分析，我们需要对向量 和矩阵的“大小”引进某种度量。而范数是绝对值概念的自然推广。</p><p>特征空间中两个实例点的距离是其相似程度的反映，k 近邻空间选用欧式距离及更一般的 $L_p$ 距离。</p><p>设特征空间 X 是 n 维实数向量空间 $R^n$，$x_i,x_j \in \mathcal{X}, x_i = (x_i^1,x_i^2,\cdots,x_i^n), x_j = (x_j^1,x_j^2,\cdots,x_j^n)$，则 $x_i, x_j$ 的$L_p$距离定义为:</p><script type="math/tex; mode=display">L_p(x_i,x_j) =  \left(\sum_{l=1}^n |x_i^l-x_j^l|^p\right) ^{\frac{1}{p}}</script><p>这里 p 要不小于1，当 p = 2时，成为欧氏距离；<br>当 p = 1 时，称为曼哈顿距离；<br>当 p = $\infty$ 时，它是各个坐标距离的最大值。</p><h3 id="分类决策"><a href="#分类决策" class="headerlink" title="分类决策"></a>分类决策</h3><p>k 近邻法中的分类决策规则往往是多数投票表决，即由输入实例的 k 个邻近的训练实例中的多数类决定输入实例的类。</p><p>多数表决规则（majorityvotingrule）有如下解释：如果分类的损失函数为 0-1 损失函数，分类函数为：</p><script type="math/tex; mode=display">f:R^n \to \{c_1,c_2,\cdots, c_K\}</script><p>那么对给定的实例 $x\in X$，其最近邻的 k 个训练实例点构成集合 $N_k(x$。如果涵盖$N_k(x)$的区域的类别是，那么误分类率是：</p><script type="math/tex; mode=display">\frac{1}{k} \sum_{x_i\in N_k(x)} I (y_i\not=c_j) = 1 - \frac{1}{k} \sum_{x_i\in N_k(x)} I (y_i = c_j)</script><p>要使误分类率最小即经验风险最小，就要使$\sum_{x_i\in N_k(x)} I (y_i = c_j)$最大，所以多数表决规则等价于经验风险最小化。</p><p>同时多数表决可以加权表决，可以一定程度提高表决结果的准确性。</p><h2 id="k-近邻在手写数字识别上的实战"><a href="#k-近邻在手写数字识别上的实战" class="headerlink" title="k 近邻在手写数字识别上的实战"></a>k 近邻在手写数字识别上的实战</h2><p> 数据集的读取和解析和<a href="https://suool.net/2018/07/08/navie-bayes-handwriting-recognition/">朴素贝叶斯法识别手写数字</a>的原理一样，这里不再赘述。 </p><p>代码实现算法上，这里先采用线性暴搜的方法，效率上明显是非常低的，耗时也比朴素贝叶斯慢的多，但是准确率却非常高，目前表决数为 k=3 的情况下且不加权的预测准确率可以达到 94% 以上。</p><p>训练预测结果如下:<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/10/597C98CC-BFA6-4998-9E03-A43C6BAF6620.png" alt="597C98CC-BFA6-4998-9E03-A43C6BAF6620"></p><p>可以看出，测试 2100 个图片，用了1218秒，20多分钟，效率非常慢。<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/10/A535D08C-349E-46B2-8147-E59F88076FB1.png" alt="A535D08C-349E-46B2-8147-E59F88076FB1"></p><p>但是准确率异常高，且比较稳定。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>更高效率的 k 近邻寻找方法是 k-d树（k-dimensional树的简称），这是一种分割 k 维数据空间的数据结构，主要应用于多维空间关键数据的搜索。</p></li><li><p>可以对 k 近邻进行加权表决，对于预测准确率应该也会有所提升。</p></li></ul><h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p>下一次将实践以上的两点总结，看看具体的表现如何吧。</p><hr><p>附KNN 算法的线性暴搜实现如下:</p><pre><code class="lang-python"># -*- coding: utf-8 -*import timeimport matplotlib.pyplot as pltimport testLibrary as tlimport collectionsimport numpy as np# 距离计算def calc_dis(train_image,test_image):    dist=np.linalg.norm(train_image-test_image)    return dist# 确定待分类实例的 k 近邻def find_labels(k,train_images,train_labels,test_image):    all_dis = []    labels=collections.defaultdict(int)    for i in range(len(train_images)):        dis = np.linalg.norm(train_images[i]-test_image)        all_dis.append(dis)    sorted_dis = np.argsort(all_dis)    count = 0    while count &lt; k:        labels[train_labels[sorted_dis[count]]]+=1        count += 1    return labels# 结合训练数据集，对所有待分类实例进行 k 近邻分类预测def knn_all(k,train_images,train_labels,test_images, test_labels):    print(&quot;start knn_all!&quot;)    res=[]    right = 0    accuracy = []    count=0    for i in range(2100):        labels=find_labels(k,train_images,train_labels,test_images[i])        res.append(max(labels))        print(&quot;Picture %d has been predicted! real is %d predicted is %d&quot;%(count, test_labels[i], max(labels)))        count+=1        if max(labels) == test_labels[i]:            right+=1        if (i+1) % 70 == 0:            accuracy.append(float(right)/(i+1))    return res, accuracy# 总的预测准确率计算def calc_precision(res,test_labels):    f_res_open=open(&quot;res.txt&quot;,&quot;a+&quot;)    precision=0    for i in range(len(res)):        f_res_open.write(&quot;res:&quot;+str(res[i])+&quot;\n&quot;)        f_res_open.write(&quot;test:&quot;+str(test_labels[i])+&quot;\n&quot;)        if res[i]==test_labels[i]:            precision+=1    return precision/len(res)if __name__ == &#39;__main__&#39;:    print(&#39;Start process train data&#39;)    time_0 = time.time()    # tl.get_train_set()    print(&#39;Start process test data&#39;)    time_t = time.time()    # tl.get_test_set()    # 读取训练数据集和测试数据集的方法和朴素贝叶斯方法一致    print (&#39;Start read train data&#39;)    time_1 = time.time()    data_map, labels = tl.loadCSVfile(&quot;data.csv&quot;)    print(data_map.shape, labels.shape)    time_2 = time.time()    print(&#39;read data train cost &#39;, time_2 - time_1, &#39; seconds&#39;, &#39;\n&#39;)    print(&#39;Start read predict data&#39;)    time_3 = time.time()    test_data_map, test_labels = tl.loadCSVfile(&quot;dataTest.csv&quot;)    print(test_data_map.shape, test_data_map.shape)    time_4 = time.time()    print(&#39;read predict data cost &#39;, time_4 - time_3, &#39; seconds&#39;, &#39;\n&#39;)    print(&#39;Start predicting data&#39;)    time_5 = time.time()    res, accuracy = knn_all(3, data_map, labels, test_data_map, test_labels)    score = calc_precision(res, test_labels)    time_6 = time.time()    print(&#39;read predict data cost &#39;, time_6 - time_5, &#39; seconds&#39;, &#39;\n&#39;)    new_ticks = np.linspace(1, 30, 30)    plt.xticks(new_ticks)    plt.ylim(ymin=0.5, ymax = 1)    plt.plot(new_ticks, accuracy, &#39;o-&#39;, color=&#39;g&#39;)    plt.xlabel(&quot;x -- 1:70&quot;)    plt.ylabel(&quot;y&quot;)    plt.title(u&quot;预测准确率&quot;)    plt.show()    print(&quot;The accuracy rate is &quot;, score)    print(&quot;All data processing cost %s seconds&quot; % (time_6 - time_0))</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;k 近邻法（k-nearest-neighbor, KNN）是一种基本的分类和回归方法。现在只讨论其分类方面的应用，它不具备明显的学习过程，实际上是利用已知的训练数据集对输入特征向量空间进行划分，并作为其分类的“模型”。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://suool.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://suool.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>乡土中国</title>
    <link href="http://suool.net/2018/07/09/from-the-soil-first/"/>
    <id>http://suool.net/2018/07/09/from-the-soil-first/</id>
    <published>2018-07-09T08:28:07.000Z</published>
    <updated>2018-07-19T02:35:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上个周看完了费孝通的《乡土中国》，现在摘抄一下其中的标记，后续再写相关的读后感吧。<br><a id="more"></a></p><ol><li>从基层上看，中国社会是乡土性的。</li><li>农业和游牧或者工业不同，它是直接取资于土地的。种地的农民是搬不动的，因为长在土里的庄稼是他们生存的基础，伺候庄家的老农也像是半身插在土里，无法流动。</li><li>直接靠土地来谋生的人是站着在土地上的。以农为生的人，时代定居是常态，迁移是变态。除非天灾战火才有可能会使他们背井离乡，即使这样，死守在土里的可能还是较大的。</li><li>人口的不流动是从人和空间的关系上说的，从人和人在空间的排列关系上说就是孤立和隔膜。孤立和隔膜并不是以个人为单位的，而是以一处住在的集团为单位的，比如村落。</li><li>中国的农民一般是聚村而居，形成数百户人家的村落是积极普遍的；而美国等国家农民则一般是一户人家形成一个单位，因此而形成的精神文明也大不相同。</li><li>乡土社会在地方性的限制下成了生于斯、死于斯的社会，常态的生活是终老于乡。因此，中国的基层社会也就形成了这样一个特色，每个孩子都是在人家眼里看着长大的，在孩子眼里周围的人也是从小看惯的。这就形成了一个对每个人而言都充满了“熟悉”感的社会，没有陌生人的社会。</li><li>社会学里分出两种性质的社会：礼俗社会和法理社会。礼俗社会是没有具体目的，只是因为在一起生长而发生的社会，是有机的团结；法理社会是为了要完成一件任务而结合的社会，是机械的团结。</li><li>乡土社会中的规矩不是法律，规矩是“习”出来的礼俗。</li><li>乡土社会是熟人社会，因此乡土社会的人与人之间也从熟悉得到信任，但这种信任不是出于契约精神的信用，乡土社会的信用不是对契约的重视，而是发生于对一种行为的规矩熟悉到不假思索时的可靠性。</li><li>像是一株植物扎根于土地，在能在后续悠长的生存时间里，从容的摸清每个人都生活，甚至摸清“物”的生活，传统的二十四节气，以及各种农业谚语都是农人对于生存环境熟悉的经验总结。然而这些熟悉里面的认识都是个别的，不具有抽象的普遍原则，在熟悉环境中生长的人也不需要这些原则就能世代安稳的生存，因此，他们也会不去尝试追求更加抽象的笼罩万物的真理。</li><li>但是熟悉个别的事物，总结成生存经验这种生存哲学在一个陌生人的社会是无法应用的。在我们社会的急速变迁中，从乡土社会进入现代社会的过程中，我们在乡土社会中所养成的生活方式处处产生了流弊。陌生人所组成的现代社会是无法用乡土社会的习俗来应对的。于是，“土气”成了贬义词，“乡”也不再是衣锦荣归的去处了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个周看完了费孝通的《乡土中国》，现在摘抄一下其中的标记，后续再写相关的读后感吧。&lt;br&gt;
    
    </summary>
    
      <category term="社会学" scheme="http://suool.net/categories/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"/>
    
    
      <category term="书摘" scheme="http://suool.net/tags/%E4%B9%A6%E6%91%98/"/>
    
      <category term="思考" scheme="http://suool.net/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯应用之在手写数字识别的实践</title>
    <link href="http://suool.net/2018/07/08/navie-bayes-handwriting-recognition/"/>
    <id>http://suool.net/2018/07/08/navie-bayes-handwriting-recognition/</id>
    <published>2018-07-08T06:42:24.000Z</published>
    <updated>2018-07-19T02:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们都见过或者用过的一个东西就是输入法的手写键盘，如下面的动图所示，那么输入法是如何识别出我们手写的字迹是什么字的呢？这是一个对人而言非常简单（前提是你写的字体不过于潦草），但是对于程序而言，可能就没有那么简单了，这次我就从一个更简单的角度来试一下，如何去识别手写的数字。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="李航《统计学习方法》第四章">[1]</span></a></sup><br><a id="more"></a><br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/handinput.gif" alt="手写输入"></p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>我们在前面的文章中提到了<a href="https://suool.net/2018/06/21/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%92%8C%E8%B4%9D%E5%8F%B6%E6%96%AF/">贝叶斯定理</a>，公式表示如下</p><script type="math/tex; mode=display">P(y|x)= \frac{P(x,y)}{p(x)} = \frac {P(x|y)P(y)} {P(x)} = \frac {P(x|y)P(y)} {\sum_{y \in Y} P(x|y)P(y)}</script><p>并从中得出了这样的结论:</p><blockquote><p>贝叶斯定理可以精确的说明在已知新证据 $x$ 的情况下，我们应该改变多少关于 $y$ 的信念，这个等式中，$P(y)$ 是新证据 $x$ 出现之前我对于 $y$ 的先验信念。 $P(x|y)$ 是在 $y$ 确定的前提下，得到证据 $x$ 的可能性。 $P(y|x)$ 是在考虑新证据后我对于 $y$ 的后验信念。</p></blockquote><p>而朴素贝叶斯（Naive Bayes）法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布，然后基于学习到模型，对于新的输入 $x$ ，利用贝叶斯定理求出后验概率最大的输出 $y$ ，朴素贝叶斯法实现简单，学习和预测的效率也非常高，是一种很常用的分类方法。</p><h3 id="朴素贝叶斯法的学习与分类"><a href="#朴素贝叶斯法的学习与分类" class="headerlink" title="朴素贝叶斯法的学习与分类"></a>朴素贝叶斯法的学习与分类</h3><p>朴素贝叶斯法如何用于分类工作呢？这里用更加数学的语言，可以表述如下：<br>首先设输入空间 $\mathcal{X} \subseteq R^n $  为 n 维向量的集合，输出空间为类标记集合 $\mathcal{Y} = {c_1, c_2, \cdots<br>, c_k}$，其中输入为特征向量 $x  \in \mathcal{X}$，输出为类标记（class label） $y \in \mathcal{Y}$ .则 $ P(X, Y) $  是 $X$ 和 $Y$ 的联合概率分布.</p><p>其次训练数据集表示为:</p><script type="math/tex; mode=display">T = \{(x_1, y_1), (x_2, y_2), \cdots, (x_N, y_N) \}</script><p>由 $P(X, Y) $  独立同分布产生.</p><p>最后由朴素贝叶斯法通过上述训练数据集学习到联合概率分布 $P(X, Y) $ ，由条件概率公式可以知道只需要学习到如下的先验概率分布:</p><script type="math/tex; mode=display">P(Y = c_k), k=1,2,\cdots, K</script><p>以及条件概率分布：</p><script type="math/tex; mode=display">P(X = x \mid Y = c_k) = P(X^{(1)} = x^{(1)}, \cdots, X^{(n)} = x^{(n)} \mid Y = c_k)</script><p>二者相乘即可得到联合概率分布。</p><p>但是，事实上，从我们学到的条件概率分布的知识可以知道，$P(X = x \mid Y = c_k) $ 是一个具有指数级数量的参数，一旦训练集稍微具有规模，那么这个概率分布都是无法估计的。而机器学习中，训练集的规模化显然是不可避免的。</p><p>那么现在我们明显已经知道通过学习上述两个概率分布，可以得到我们想要的联合概率分布，从而得到训练模型，然而其中条件概率分布计算的不可行性却让我们止步不前。</p><p>在这样一个尴尬的时候，朴素贝叶斯法站出来为我们解围了，它提出了一个非常强的假设，就是假设条件概率分布是特征条件独立的，因此朴素贝叶斯，也就朴素在这里:他的假设太强，强到改变了理论上计算的规则。</p><p>具体的，条件独立性假设是：</p><script type="math/tex; mode=display">\begin{align}P(X = x \mid Y = c_k) & = P(X^{(1)} = x^{(1)}, \cdots, X^{(n)} = x^{(n)} \mid Y = c_k) \\& = \prod^{n}_{j=1}P(X^{(j)} = x^{(j)} \mid Y=c_k) \tag{1}\end{align}</script><p>这个假设等于是说用于分类的特征在类别确定的条件下都是条件独立的，这一假设使得条件概率的计算变得异常简单，但是显然也牺牲了一定的准确率，因为一般情况下特征并不都是独立的而是有关联的。</p><p>通过上述学习到模型，就可以计算后验概率分布 $P(Y = c_k \mid X = x)$，将后验概率最大的类别作为要预测的样本 $x$ 的输出。后验概率的计算依据贝叶斯定理进行：</p><script type="math/tex; mode=display">P(Y = c_k \mid X = x) = \frac{P(X=x\mid Y=c_k) P(Y=c_k)}{\sum_k P(X=x\mid Y=c_k) P(Y=c_k)} \tag{2}</script><p>将 2 式代入 1 式，得到：</p><script type="math/tex; mode=display">P(Y = c_k \mid X = x) = \frac{P(Y=c_k) \prod_{j}P(X^{(j)} = x^{(j)} \mid Y=c_k)}{\sum_k P(Y=c_k) \prod_{j}P(X^{(j)} = x^{(j)} \mid Y=c_k)}</script><p>所以，贝叶斯分类器可以表示为：</p><script type="math/tex; mode=display">y=f(x)= \arg \max_{c_k} \frac{P(Y=c_k) \prod_{j}P(X^{(j)} = x^{(j)} \mid Y=c_k)}{\sum_k P(Y=c_k) \prod_{j}P(X^{(j)} = x^{(j)} \mid Y=c_k)}</script><p>上式因为分母对所有 $c_k$ 都是相同的，所以：</p><script type="math/tex; mode=display">y = \arg \max_{c_k} P(Y=c_k) \prod_{j}P(X^{(j)} = x^{(j)} \mid Y=c_k)</script><p>这就是朴素贝叶斯分类器的最简形式，从这个式子可以看出来，朴素贝叶斯分类器本质上是根据先验概率及条件概率求最大化的后验概率，从而推断类别。</p><h3 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h3><h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a><strong>极大似然估计</strong></h4><p>在上面所说的朴素贝叶斯法中，训练学习意味着估计先验概率 $P(Y=c_k)$ 和条件概率 $P(X^{(j)} = x^{(j)} \mid Y=c_k)$，这可以应用极大似然估计来估计相应的概率，其中先验概率的极大似然估计是：</p><script type="math/tex; mode=display">P(Y=c_k) = \frac{\sum^{N}_{i=1} I(y_i=c_k)}{N} ，k = 1,2,\cdots,K</script><p>设第 j 个特征 $x^{j}$ 可能的取值的集合为 <img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/0EE6F321-E6D7-495F-BEDD-0CA48526F6EB.png" alt="0EE6F321-E6D7-495F-BEDD-0CA48526F6EB">，则条件概率的极大似然估计为：</p><script type="math/tex; mode=display">P(X^{(j)} = a_{jl} \mid Y=c_k) = \frac{\sum^{N}_{i=1} I (x_i^{(j)} = a_{jl}, y_i = c_k)}{\sum^{N}_{i=1}I (y_i=c_k)} \tag{3}</script><p><img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/D5690E7F-DC11-4F6C-8842-77972CDFEBE8.png" alt="D5690E7F-DC11-4F6C-8842-77972CDFEBE8"></p><h4 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a><strong>贝叶斯估计</strong></h4><p>因为用极大似然估计可能会出现所要估计的概率值为 0 的情况，这就会导致后续的计算出现错误，使得分类出现偏差，解决这个问题的方法就是使用贝叶斯估计，即是平滑处理估计结果，条件概率的贝叶斯估计是：</p><script type="math/tex; mode=display">P(X^{(j)} = a_{jl} \mid Y=c_k) = \frac{\sum^{N}_{i=1} I (x_i^{(j)} = a_{jl}, y_i = c_k) + \lambda}{\sum^{N}_{i=1}I (y_i=c_k) + S_j\lambda} \tag{3}</script><p>其中 $\lambda \geq 0$，等价于给随机变量的各个取值的频数加上一个正数 $\lambda &gt; 0$ 常取 $\lambda = 1$，称为<strong>拉普拉斯平滑</strong>。</p><h2 id="实战朴素贝叶斯"><a href="#实战朴素贝叶斯" class="headerlink" title="实战朴素贝叶斯"></a>实战朴素贝叶斯</h2><p>有了上面的基础，那么处理手写数字识别上面就变得很简单了，整个处理的步骤分为：</p><ul><li>图片预处理</li><li>图片数据化</li><li>模型训练</li><li>模型测试</li></ul><h3 id="图片预处理"><a href="#图片预处理" class="headerlink" title="图片预处理"></a>图片预处理</h3><p>这里我们取现成的 mnist 数据集 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[THE MNIST DATABASE](http://yann.lecun.com/exdb/mnist/)">[2]</span></a></sup> ，首先数据集下载下来的是特殊格式的压缩包，其中训练集的图片包和标签包格式如下：<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/traintype.png" alt="压缩格式"></p><p>可以看出在 train-images.idx3-ubyte 中，第一个数为 32 位的整数（魔数，图片类型的数），第二个数为32位的整数（图片的个数），第三和第四个也是 32 位的整数（分别代表图片的行数和列数），接下来的都是一个字节的无符号数（即像素，值域为0~255），因此，我们只需要依次获取魔数和图片的个数，然后获取图片的长和宽，最后逐个按照图片大小的像素读取就可以得到一张张的图片内容了。标签数据集及测试数据集的的数据读取都是一样的原理。</p><p>读取训练图片集并将图片存储成图片，读取标签集的代码实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_image</span><span class="params">(filename)</span>:</span></span><br><span class="line">    f = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    buf = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    // 开始读取 魔数、图片数目、图片行数、列数</span><br><span class="line">    magic, images, rows, columns = struct.unpack_from(<span class="string">'&gt;IIII'</span>, buf, index)</span><br><span class="line">    index += struct.calcsize(<span class="string">'&gt;IIII'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(images):</span><br><span class="line">        <span class="comment"># 逐个读取图片，每个图片字节数为 行数X列数</span></span><br><span class="line">        image = Image.new(<span class="string">'L'</span>, (columns, rows))</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(columns):</span><br><span class="line">                <span class="comment"># 读取并填充图片的像素值，每个像素值为一个字节</span></span><br><span class="line">                image.putpixel((y, x), int(struct.unpack_from(<span class="string">'&gt;B'</span>, buf, index)[<span class="number">0</span>]))</span><br><span class="line">                index += struct.calcsize(<span class="string">'&gt;B'</span>)</span><br><span class="line">        print(<span class="string">'save '</span> + str(i) + <span class="string">'image'</span>)</span><br><span class="line">        image.save(<span class="string">'train/'</span> + str(i) + <span class="string">'.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_label</span><span class="params">(filename, saveFilename)</span>:</span></span><br><span class="line">    f = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    buf = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="comment"># 开始读取 魔数及标签数目</span></span><br><span class="line">    magic, labels = struct.unpack_from(<span class="string">'&gt;II'</span>, buf, index)</span><br><span class="line">    index += struct.calcsize(<span class="string">'&gt;II'</span>)</span><br><span class="line">    labelArr = [<span class="number">0</span>] * labels</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(labels):</span><br><span class="line">        <span class="comment"># 一个标签一个字节</span></span><br><span class="line">        labelArr[x] = int(struct.unpack_from(<span class="string">'&gt;B'</span>, buf, index)[<span class="number">0</span>])</span><br><span class="line">        index += struct.calcsize(<span class="string">'&gt;B'</span>)</span><br><span class="line">    save = open(saveFilename, <span class="string">'w'</span>)</span><br><span class="line">    save.write(<span class="string">','</span>.join([str(x) <span class="keyword">for</span> x <span class="keyword">in</span> labelArr]))</span><br><span class="line">    save.write(<span class="string">'\n'</span>)</span><br><span class="line">    save.close()</span><br><span class="line">    print(<span class="string">'save labels success'</span>)</span><br><span class="line">    <span class="keyword">return</span> labelArr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    read_image(<span class="string">'train-images.idx3-ubyte'</span>)</span><br><span class="line">    read_label(<span class="string">'train-labels.idx1-ubyte'</span>, <span class="string">'train/label.txt'</span>)</span><br></pre></td></tr></table></figure></p><p>读取到图片之后，存储的结果如下：</p><p><img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/dataprocess-1.png" alt="数据解压"></p><h3 id="图片数据化"><a href="#图片数据化" class="headerlink" title="图片数据化"></a>图片数据化</h3><p>为了将图片变成更易为计算机接受的形式，这里需要将图片二值化，即是只包含0和1的图片表现形式，即是下面这样的矩阵，其方法是超过一定像素值的点标记为 1，否则为 0：<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/FE2F3FF5-7847-4F83-9C62-400196BB55FF.png" alt="FE2F3FF5-7847-4F83-9C62-400196BB55FF"></p><p>可以隐约看出一个 5 的形状。</p><p>这里为了方便继续处理图片特征，将这个 28 *28 的矩阵进行 reshape 操作，将一幅图展开为行向量。因此整个训练集（）60000张图片）就变成了一个大小为 60000×784 的矩阵，之后尽量进行矩阵操作。</p><p>同时为了方便标记，将每行向量表示的数字写在最后一列，因此整个矩阵的大小为  60000×785。</p><p>并为了后续数据操作的方便，将这个矩阵存在本地的CSV文件中，代码及结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">28</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_train_set</span><span class="params">()</span>:</span></span><br><span class="line">    f = open(<span class="string">'data.csv'</span>, <span class="string">'wb'</span>)</span><br><span class="line">    category = MR.read_label(<span class="string">'train-labels.idx1-ubyte'</span>, <span class="string">'train/label.txt'</span>)</span><br><span class="line"></span><br><span class="line">    file_names = os.listdir(<span class="string">r"./train/"</span>, )</span><br><span class="line">    train_picture = np.zeros([len(file_names)<span class="number">-1</span>, N ** <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 遍历文件，转为向量存储</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> range(len(file_names)<span class="number">-1</span>):</span><br><span class="line">        img_num = io.imread(<span class="string">'./train/%d.png'</span> % (file))</span><br><span class="line">        rows, cols = img_num.shape</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> img_num[i, j] &lt; <span class="number">100</span>:</span><br><span class="line">                    img_num[i, j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    img_num[i, j] = <span class="number">1</span></span><br><span class="line">        train_picture[file, <span class="number">0</span>:N ** <span class="number">2</span>] = img_num.reshape(N ** <span class="number">2</span>)</span><br><span class="line">        train_picture[file, N ** <span class="number">2</span>] = category[file]</span><br><span class="line">        print(<span class="string">"完成处理第%d张图片"</span> % (file+<span class="number">1</span>))</span><br><span class="line">    np.savetxt(f,train_picture,fmt=<span class="string">'%d'</span>,delimiter=<span class="string">','</span>, newline=<span class="string">'\n'</span>, header=<span class="string">''</span>, footer=<span class="string">''</span>)</span><br><span class="line">    f.close()</span><br><span class="line">    time_e = time.time()</span><br><span class="line">    print(<span class="string">'process data train cost '</span>, time_e - time_0, <span class="string">' seconds'</span>, <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> train_picture</span><br></pre></td></tr></table></figure></p><p>结果为，红色框内即是该行向量的标签：<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/EAFE6D9C-EC29-4806-80D2-055FCE2CFFB5.png" alt="EAFE6D9C-EC29-4806-80D2-055FCE2CFFB5"></p><p>处理测试数据也是一样的原理。</p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>从第一部分我们可以了解到，要求后验概率的本质是求在类别为 j 的条件下，样本 x 的第 i 个特征出现的条件概率的，将所有特征的概率与该类别的先验概率作连乘即得到后验概率。</p><p>因此，重点是计算类别的先验概率和在类别为 j 的条件下，样本 x 的第 i 个特征出现的条件概率，这也就是我们要训练的模型，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Train</span><span class="params">()</span>:</span></span><br><span class="line">    conditional_probability = np.zeros((class_num, feature_len, <span class="number">2</span>))   <span class="comment"># 条件概率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算先验概率及条件概率</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(labels)):</span><br><span class="line">        img = data_map[i, :]</span><br><span class="line">        label = labels[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(feature_len):</span><br><span class="line">            conditional_probability[label][j][img[j]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将概率归到[1.1001]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(class_num):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(feature_len):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 经过二值化后图像只有0，1两种取值</span></span><br><span class="line">            pix_0 = conditional_probability[i][j][<span class="number">0</span>]</span><br><span class="line">            pix_1 = conditional_probability[i][j][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算0，1像素点对应的条件概率</span></span><br><span class="line">            probalility_0 = (float(pix_0)/float(pix_0+pix_1))*<span class="number">1000</span> + <span class="number">1</span></span><br><span class="line">            probalility_1 = (float(pix_1)/float(pix_0+pix_1))*<span class="number">1000</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            conditional_probability[i][j][<span class="number">0</span>] = probalility_0</span><br><span class="line">            conditional_probability[i][j][<span class="number">1</span>] = probalility_1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conditional_probability</span><br></pre></td></tr></table></figure></p><p>其中部分说明如下：</p><ul><li><p>由于 Python 浮点数精度的原因，784个浮点数联乘后结果变为 Inf，而 Python 中 int 可以无限相乘的，因此可以利用python int 数据类型的特性对先验概率与条件概率进行一些改造。</p></li><li><p>先验概率： 由于先验概率分母都是 N，因此不用除于 N，直接用分子即可。 </p></li><li>条件概率： 条件概率公式如上说明济代码所示，我们得到概率后再乘以1000000 （最小的可能性为1/784，同时需要尽量保存概率精度，这里保存到白万分之一，因此乘以1000000），将概率映射到[0,1000000]中，但是为防止出现概率值为0的情况，人为的加上1，使概率映射到<a href="https://blog.csdn.net/wds2006sdo/article/details/51967839" target="_blank" rel="noopener">1,1000001]中。<sup id="fnref:3"><a href="#fn:3" rel="footnote">&lt;span class=”hint—top-right hint—error hint—large” aria-label=”李航《统计学习方on实现朴素贝叶斯分类器（MNIST数据集）</a>“&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;</sup></a></li></ul><h3 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h3><p>模型预测的方法就是根据上面训练出来的朴素贝叶斯模型，对任一个新的样本 x ，分别计算它是类别 j 的条件下的后验概率，取最大后验概率的类别即可。</p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算概率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_probability</span><span class="params">(img, label)</span>:</span></span><br><span class="line">    probability = int(prior_probability[label])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(img)):</span><br><span class="line">        probability *= int(conditional_probability[label][i][img[i]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> probability</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Predict</span><span class="params">(testset, test_labels)</span>:</span></span><br><span class="line">    predict = []</span><br><span class="line">    accuracy = []</span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    rows, cols = testset.shape</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">        <span class="comment"># 图像二值化</span></span><br><span class="line">        img = testset[row, :]</span><br><span class="line"></span><br><span class="line">        max_label = <span class="number">0</span></span><br><span class="line">        max_probability = calculate_probability(img, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            probability = calculate_probability(img, j)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> max_probability &lt; probability:</span><br><span class="line">                max_label = j</span><br><span class="line">                max_probability = probability</span><br><span class="line">        predict.append(max_label)</span><br><span class="line">        <span class="keyword">if</span> max_label == test_labels[row]:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (row+<span class="number">1</span>) % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            accuracy.append(float(right)/(row+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> float(right)/len(test_labels), np.array(predict), accuracy</span><br></pre></td></tr></table></figure></p><p>整个代码运行的结果如下：<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/15310514214661.jpg" alt="-w455"><br>准确率曲线如下：<br><img src="https://suool-bolg.b0.upaiyun.com/2018/07/08/8EAA5A09-8E40-45F3-85EC-D20F83C5C844.png" alt="8EAA5A09-8E40-45F3-85EC-D20F83C5"></p><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><ul><li>本次实验将图像展开、对单个像素独立判断，损失了图像的空间信息，而这种空间信息正是我们人眼识别图像的关键。所以最终的准确率受此影响。</li><li>测试数据的准确率为84.47%，还是非常不错的（共有10个分类，理论上随机猜测的准确率只有10%）。能使准确率达到84.15%的原因主要是：(1) MNIST数据集被预先处理过。通过上面的示例图片可以看出，MNIST中的图片较为纯净，没有噪声干扰，非常清晰。所以实验中可以直接进行二值化。(2) MNIST数据集中，图片中的数字总是在中心位置，大小合适，比较饱满。这一点保留了部分的空间信息。</li><li>本例中的二值化过程是直接将超过一定像素阀值值置1，如果采用更合理的阈值(比如取当前图片最大像素阀值为 100 )进行二值化操作，进行训练、测试过程，最终的准确率可能会提升。 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[用朴素贝叶斯法对MNIST数据集分类](http://geyao1995.com/%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95%E5%AF%B9MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E7%B1%BB/)">[4]</span></a></sup></li></ul><p>以上就是这次朴素贝叶斯法的理论及实战啦。</p><p>下次是 K 近邻算法在手写识别上的应用。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">李航《统计学习方法》第四章<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">THE MNIST DATABASE</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">李航《统计学习方on实现朴素贝叶斯分类器（MNIST数据集）](https://blog.csdn.net/wds2006sdo/article/details/51967839)<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://geyao1995.com/%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95%E5%AF%B9MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">用朴素贝叶斯法对MNIST数据集分类</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我们都见过或者用过的一个东西就是输入法的手写键盘，如下面的动图所示，那么输入法是如何识别出我们手写的字迹是什么字的呢？这是一个对人而言非常简单（前提是你写的字体不过于潦草），但是对于程序而言，可能就没有那么简单了，这次我就从一个更简单的角度来试一下，如何去识别手写的数字。 &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-right hint--error hint--large&quot; aria-label=&quot;李航《统计学习方法》第四章&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://suool.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://suool.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最小二乘法矩阵表示及非线性响应</title>
    <link href="http://suool.net/2018/06/26/Least-Squares-with-Matrix-Nolinear/"/>
    <id>http://suool.net/2018/06/26/Least-Squares-with-Matrix-Nolinear/</id>
    <published>2018-06-26T05:43:19.000Z</published>
    <updated>2018-07-10T11:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>早上上班的路上读《社会心理学》里面有一段话，觉得不错，摘在这里。</p><blockquote><p><strong>我们人类总是有一种不可抑制的冲动，想要解释行为，对其归因，以使其变得次序井然．具有可预见性，使一切尽在掌握之中。</strong>你我对于类似的情境却可能表现出截然不同的反应，这是因为我们的想法不同。我们对朋友的责难做何反应，取决于我们对其所做的解释，取决于我们是把它归咎于朋友的敌意行为，还是归结于他糟糕的心情。<br>从某种角度来说，我们都是天生的科学家。我们解释着他人的行为，通常足够快也足够准确，以适应我们日常生活的需要。当他人的行为具有一致性而且与众不同时，我们会把其行为归因于他们的人格。例如。如果你发现一个人说话总是对人冷嘲热讽．你可能就会推断此人秉性不良，然后便设法尽量避免与他的接触。</p></blockquote><p>当然这是指更大范围内的人类心理，在对数据和模型的痴迷上，人类的欲望显然也是强烈的，人类总是想尽一切的办法打破现有的桎梏，在创造了更多的不确定性之后，期望通过对数据的把控和预测以看到更确切的未来。<br><a id="more"></a><br>这次我们来从矩阵和向量的角度来解释最小二乘法及非线性的模拟建模。</p><h2 id="LS-的矩阵推导"><a href="#LS-的矩阵推导" class="headerlink" title="LS 的矩阵推导"></a>LS 的矩阵推导</h2><p>继续使用上一次的方程式并将其改写成矩阵的形式如下：</p><script type="math/tex; mode=display">f(x_n;w_0,w_1) = w_0 + w_1x = w^Tx \tag{2.1}</script><p>代入最小二乘损失函数，得到结果为：</p><script type="math/tex; mode=display">\begin{align}\mathcal{L} &= \frac{1}{N} \sum_{n=1}^{N} \mathcal{L}_n(t_n,f(x_n;w_0,w_1 )) \\&= \frac{1}{N} \sum_{n=1}^{N} (t_n-w^tx_n)^2 \tag{2.2} \\& = \frac{1}{N} \sum_{n=1}^{N} (t-Xw)^T(t-Xw) \tag{2.3}\end{align}</script><p>式 2.2 到式 2.3 的证明忽略。</p><p>其中 $X$ 、$W$ 和 $T$ 为：</p><script type="math/tex; mode=display"> X = \begin{bmatrix} x_1^T  \\ x_2^T  \\ x_3^T   \\ \vdots \\  x_n^T  \\ \end{bmatrix} =  \begin{bmatrix} 1 & x_1  \\ 1 &  x_2 \\ 1 & x_3  \\ \vdots & \vdots\\ 1 & x_n  \\ \end{bmatrix} \\ w = \begin{bmatrix} w_0^T  \\ w_1^T \end{bmatrix} \quad \\ t = \begin{bmatrix} t_1^T  \\ t_2^T  \\ t_3^T   \\ \vdots \\  t_n^T  \\ \end{bmatrix}</script><p>对上述 2.3 展开，得到下面的表达式：</p><script type="math/tex; mode=display">\begin{align}\mathcal{L} &= \frac{1}{N} w^TX^TXw - \frac {2} {N}w^TX^Tt + \frac {1}{N} t^Tt \\& = \frac{1}{N} (w^TX^TXw - 2 w^TX^Tt + t^Tt)\end{align}</script><p>为了得到最小值，需要得到 $\mathcal{L}$的拐点（极小值）一致的向量$w$的值，这里一样是求 $\mathcal{L}$ 关于 $w$ 的偏导数，并令其为 0，可以代入上述的矩阵进行求解，也可以使用一些恒等式来直接化简:</p><script type="math/tex; mode=display">% inner array of minimum values 内层"最小值"数组\begin{array}{c|c}\hlinef(w) & \frac {\partial f} {\partial w} \\\hlinew^Tx & x \\x^t=Tw & x \\w^Tw & 2w \\w^TCw & 2Cw \\\hline\end{array}</script><p>得到的表达式如下：</p><script type="math/tex; mode=display">\frac {\partial \mathcal{L}} {\partial w} = \frac {2} {N} X^TXw - \frac {2} {N}X^Tt = 0</script><script type="math/tex; mode=display">X^Xw = X^Tt \tag{2.4}</script><p>从而得到使损失最小的$w$值，$\hat w$ 的矩阵公式为：</p><script type="math/tex; mode=display">\hat w = (X^TX)^{-1}X^Tt \tag{2.5}</script><p>根据此公式解出的值与上次用标量形式解出的是一样的。</p><h2 id="线性模型的非线性响应"><a href="#线性模型的非线性响应" class="headerlink" title="线性模型的非线性响应"></a>线性模型的非线性响应</h2><p>前面我们所假设的是拟合函数是一次函数，但是可以明显的看出拟合效果并不好，所以需要往更高次的多项式延伸，假如是二次的话，那么可以表示为：</p><script type="math/tex; mode=display">f(x;w) = w^Tx = w_0+w_1x+w_2x^2</script><p>更一般的，扩展 $x$ 的幂次到任意任意阶的多项式函数，对于一个 K 阶多项式，可以扩展数据矩阵为：</p><script type="math/tex; mode=display">t = \begin{bmatrix} x_1^0 & x_1^1 & x_1^2 & \cdots & x_1^k \\ x_2^0 & x_2^1 & x_2^2 & \cdots & x_2^k\\ \vdots & \vdots & \vdots & \ddots & \vdots \\x_n^0 & x_n^1 & x_n^2 & \cdots & x_n^k \\\end{bmatrix}</script><p>函数表达为更一般的形式：</p><script type="math/tex; mode=display">f(x;w)= \sum^K_{k=0} w_kx^k</script><p>其解一样适用于式 $2.5$</p><p>可以求得其八阶线性拟合结果如下：</p><p><img src="https://suool-bolg.b0.upaiyun.com/2018/07/03/FE170A95-A609-4B5D-AE3C-4090B7B63FA2.png" alt="FE170A95-A609-4B5D-AE3C-4090B7B63FA2"></p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x_cord = []</span><br><span class="line">y_cord = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawScatterDiagram</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    fr=open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr=line.split(<span class="string">','</span>)</span><br><span class="line">        x_cord.append(float(lineArr[<span class="number">0</span>]))</span><br><span class="line">        y_cord.append(float(lineArr[<span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># plt.scatter(x_cord,y_cord,s=30,c='red',marker='o', alpha=0.7,label='比赛成绩 ')</span></span><br><span class="line">    <span class="comment"># plt.xlabel("year")</span></span><br><span class="line">    <span class="comment"># plt.ylabel("time")</span></span><br><span class="line">    <span class="comment"># plt.title("result of game")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noLinearMoreTimesCalculate</span><span class="params">()</span>:</span></span><br><span class="line">    x_mat = np.ones((len(x_cord),<span class="number">1</span>))</span><br><span class="line">    y_mat = np.mat(y_cord).T</span><br><span class="line">    test = np.array(x_cord)</span><br><span class="line">    test = (test - <span class="number">1896</span>)/<span class="number">4.0</span>  // 数据预处理，缩小化</span><br><span class="line">    <span class="comment"># x_mat = np.mat(np.c_[x_zeros,test])</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">9</span>):</span><br><span class="line">        x_temp = test**index</span><br><span class="line">        x_mat = np.mat(np.c_[x_mat, x_temp])</span><br><span class="line">    print(x_mat)</span><br><span class="line">    w_mat = ((x_mat.T * x_mat).I*x_mat.T*y_mat)[::<span class="number">-1</span>]</span><br><span class="line">    w_mat = w_mat.T</span><br><span class="line">    c = np.squeeze([i <span class="keyword">for</span> i <span class="keyword">in</span> w_mat])</span><br><span class="line">    print(c)</span><br><span class="line">    func = np.poly1d(c)</span><br><span class="line">    x_mLo = np.linspace(<span class="number">0</span>, <span class="number">29</span>, <span class="number">112</span>)</span><br><span class="line"></span><br><span class="line">    y_mLo = func(x_mLo)</span><br><span class="line"></span><br><span class="line">    plt.scatter(test,y_cord,s=<span class="number">30</span>,c=<span class="string">'red'</span>,marker=<span class="string">'o'</span>, alpha=<span class="number">0.7</span>,label=<span class="string">'比赛成绩 '</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"year"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"time"</span>)</span><br><span class="line">    plt.title(<span class="string">"result of game"</span>)</span><br><span class="line"></span><br><span class="line">    plt.plot(x_mLo,y_mLo, c=<span class="string">"yellow"</span>,label=<span class="string">'线性拟合-8阶'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    drawScatterDiagram(<span class="string">"olympic100m.txt"</span>)</span><br><span class="line">    <span class="comment"># linearCalculate()</span></span><br><span class="line">    <span class="comment"># noLinearCalculate()</span></span><br><span class="line">    noLinearMoreTimesCalculate()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h2 id="过拟合与验证"><a href="#过拟合与验证" class="headerlink" title="过拟合与验证"></a>过拟合与验证</h2><p>从上次的一阶线性拟合到现在的八阶拟合，从直观上看，八阶的拟合效果比一阶的明显好很多，但是我们做拟合的根本目的是为了做预测，不是纯粹为了拟合而拟合，因为理论上说，一般对于 n 个点，可以拟合 n-1 次多项式以便完全通过这些点。但是这样子的拟合结果对于预测而言可能是极其差的。</p><p>那么如何衡量呢?<br>和拟合是一样的思想，看模型在泛化问题时候的表现，即是在预测验证数据上的表现，如果其损失很小，那么可以认为这个模型的预测能力不错。</p><h3 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h3><p>克服过拟合问题的一般方法是使用第二个数据集，即是验证集。用其来验证模型的预测性能，验证集可以是单独提供的，也可以从原始训练集中拿出来的。</p><p>从验证集计算的损失对于验证集数据的选择敏感，如果验证集非常小，那就更加困难了，而交叉验证是一个有效使用现有数据集的方法。</p><p>一般是 K 折交叉验证，当 K = N 的时候，及 K 恰好是等于数据集中的可观测数据的数量，每个观测数据依次拿出用作测试其他 N-1 个对象训练得到的模型，其又叫 留一交叉验证 （Leave-One-Out Cross Validation, LOOCV）,对于 LOOCV 的均方验证为：</p><script type="math/tex; mode=display">\mathcal{L}^{CV} = \frac {1}{N} \sum^N_{n=1}(t_n-\hat{w}^T_{-n}x_n)^2</script><p>其中 $\hat{w}_{-n}$ 是除去第 n 个训练样例的参数估计值。</p><h3 id="应用实例及代码实现"><a href="#应用实例及代码实现" class="headerlink" title="应用实例及代码实现"></a>应用实例及代码实现</h3><p>首先定义一个带噪声的函数，并用其生成 100 个随机数据点作为训练数据，生成 1000 个随机数据点作为测试数据，生成数据点的 $x$ 范围是 [-5,5], 表达式如下，其中噪声$\mathcal {N}$ 符合正态分布</p><script type="math/tex; mode=display">y = 5 \times x^3 - x^2 + x + 100 \times \mathcal N \\\mathcal N(x \mid \mu,\sigma^2) = \frac {1}{\sigma \sqrt {2 \pi}} \exp \{- \frac {1}{2\sigma^2}(x-\mu)^2\}</script><p>使用如上的矩阵式，对数据进行不同阶数的拟合，得到的结果如下:</p><p><img src="https://suool-bolg.b0.upaiyun.com/2018/07/03/51A2EEB0-A96E-44EC-BFC9-10C5C196DC89.png" alt="51A2EEB0-A96E-44EC-BFC9-10C5C196D"></p><p>然后，分别对比训练损失、测试损失及使用 LOOCV 方法拟合及其损失随着阶数增高而变化的曲线如下图所示:</p><p><img src="https://suool-bolg.b0.upaiyun.com/2018/07/03/274FF482-8C88-4A58-B39D-3231ADBBFAF4.png" alt="274FF482-8C88-4A58-B39D-3231ADBBFAF4"></p><p>可以从图中看出，在 3 阶的时候，测试损失和 LOOCV 损失达到最小，且 3 阶拟合之后训练损失不明显，但是测试损失明显增高，即产生了过拟合的现象。</p><p>实现代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.random.randint(<span class="number">-5000</span>,<span class="number">5000</span>, size=[<span class="number">100</span>,<span class="number">1</span>]) / <span class="number">1000.0</span></span><br><span class="line"></span><br><span class="line">t = <span class="number">5</span>*(x**<span class="number">3</span>)  - x**<span class="number">2</span> + x + <span class="number">100</span>*np.random.randn(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">testx = np.linspace(<span class="number">-5</span>,<span class="number">5</span>,<span class="number">1001</span>)</span><br><span class="line"></span><br><span class="line">testt = <span class="number">5</span>*(testx**<span class="number">3</span>) - testx**<span class="number">2</span> + testx + <span class="number">100</span>*np.random.randn(<span class="number">1001</span>, <span class="number">1</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.scatter(x, t, s=<span class="number">35</span>, c=<span class="string">"red"</span>, marker=<span class="string">'o'</span>, alpha=<span class="number">0.9</span>)</span><br><span class="line">plt.xlabel(<span class="string">"x"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y"</span>)</span><br><span class="line">plt.title(<span class="string">"points of train"</span>)</span><br><span class="line"></span><br><span class="line">x_mat = np.ones((len(x),<span class="number">1</span>))</span><br><span class="line">y_mat = np.mat(t)</span><br><span class="line"></span><br><span class="line">color = [<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>]</span><br><span class="line"></span><br><span class="line">degrees = np.arange(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">trainLoss = []</span><br><span class="line">predictLoss = []</span><br><span class="line">LOOCVLoss = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainAndGetLoss</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> degree <span class="keyword">in</span> degrees:</span><br><span class="line">        <span class="keyword">global</span> x_mat</span><br><span class="line">        <span class="keyword">global</span> y_mat</span><br><span class="line">        tempX = x_mat</span><br><span class="line">        tempY = y_mat</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, degree):</span><br><span class="line">            x_temp = x ** index</span><br><span class="line">            tempX = np.mat(np.c_[tempX, x_temp])</span><br><span class="line">        <span class="comment"># print(tempX)</span></span><br><span class="line">        print(<span class="string">"计算"</span>)</span><br><span class="line">        print(type(tempX.T*tempX))</span><br><span class="line">        w_mat = ((tempX.T * tempX).I * tempX.T * tempY)[::<span class="number">-1</span>]</span><br><span class="line">        w_mat = w_mat.T</span><br><span class="line">        c = np.squeeze([i <span class="keyword">for</span> i <span class="keyword">in</span> w_mat])</span><br><span class="line">        print(c)</span><br><span class="line">        func = np.poly1d(c)</span><br><span class="line">        <span class="keyword">if</span> degree ==<span class="number">2</span> <span class="keyword">or</span> degree == <span class="number">3</span> <span class="keyword">or</span> degree == <span class="number">5</span> :</span><br><span class="line">            x_mLo = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">            y_mLo = func(x_mLo)</span><br><span class="line">            plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            plt.plot(x_mLo, y_mLo, linewidth=<span class="number">2</span>, c=np.random.rand(<span class="number">3</span>,), label=<span class="string">'线性拟合-%d阶'</span> % (degree - <span class="number">1</span>))</span><br><span class="line">            plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line">        <span class="comment">#  训练数据损失</span></span><br><span class="line">        y_train = func(x)</span><br><span class="line">        print(np.mean((y_train-t)**<span class="number">2</span>), type(y_train), len(y_train))</span><br><span class="line">        trainLoss.append(np.mean((y_train-t)**<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 预测数据损失</span></span><br><span class="line">        y_predict = func(testx)</span><br><span class="line">        print(np.mean((y_predict-testt)**<span class="number">2</span>), type(y_predict), len(y_predict))</span><br><span class="line">        predictLoss.append(np.mean((y_predict-testt)**<span class="number">2</span>))</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    new_ticks = np.linspace(<span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line">    plt.xticks(new_ticks)</span><br><span class="line">    plt.plot(new_ticks, trainLoss, <span class="string">'o-'</span>, color=<span class="string">'g'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"x"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"y"</span>)</span><br><span class="line">    plt.title(<span class="string">"训练数据损失"</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">    plt.xticks(new_ticks)</span><br><span class="line">    plt.plot(new_ticks, predictLoss, <span class="string">'o-'</span>, color=<span class="string">'g'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"x"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"y"</span>)</span><br><span class="line">    plt.title(<span class="string">"预测数据损失"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainLOOCVAndGetLoss</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> degree <span class="keyword">in</span> degrees:</span><br><span class="line">        trainLoocv = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">            <span class="comment"># 准备训练数据</span></span><br><span class="line">            index_x = (index)</span><br><span class="line">            new_x = np.delete(x, index_x)</span><br><span class="line">            new_y = np.delete(t, index_x)</span><br><span class="line">            tempX = np.ones([<span class="number">99</span>, <span class="number">1</span>])</span><br><span class="line">            tempY = np.mat(new_y).T</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, degree):</span><br><span class="line">                x_temp = new_x ** index</span><br><span class="line">                tempX = np.mat(np.c_[tempX, x_temp])</span><br><span class="line">            w_mat = ((tempX.T * tempX).I * tempX.T * tempY)[::<span class="number">-1</span>]</span><br><span class="line">            w_mat = w_mat.T</span><br><span class="line">            c = np.squeeze([i <span class="keyword">for</span> i <span class="keyword">in</span> w_mat])</span><br><span class="line">            func = np.poly1d(c)</span><br><span class="line">            <span class="keyword">if</span> index_x == <span class="number">0</span>:</span><br><span class="line">                print((func(x[index,<span class="number">0</span>])-t[index,<span class="number">0</span>])**<span class="number">2</span>)</span><br><span class="line">            trainLoocv.append((func(x[index,<span class="number">0</span>])-t[index,<span class="number">0</span>])**<span class="number">2</span>)</span><br><span class="line">        LOOCVLoss.append(np.mean(trainLoocv))</span><br><span class="line">        plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">        new_ticks = np.linspace(<span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line">        plt.xticks(new_ticks)</span><br><span class="line">        plt.plot(new_ticks, predictLoss, <span class="string">'o-'</span>, color=<span class="string">'g'</span>)</span><br><span class="line">        plt.xlabel(<span class="string">"x"</span>)</span><br><span class="line">        plt.ylabel(<span class="string">"y"</span>)</span><br><span class="line">        plt.title(<span class="string">"LOOCV损失"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    trainAndGetLoss()</span><br><span class="line">    trainLOOCVAndGetLoss()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>  下一次是真正入门啦，将之前说过的贝叶斯定理应用于机器学习，和你分享如何使用朴素的贝叶斯方法来进行简单的分类工作，比如识别手写数字，新闻素材的主题分类。（具体是挖那个主题的坑，还不知道 </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;早上上班的路上读《社会心理学》里面有一段话，觉得不错，摘在这里。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;我们人类总是有一种不可抑制的冲动，想要解释行为，对其归因，以使其变得次序井然．具有可预见性，使一切尽在掌握之中。&lt;/strong&gt;你我对于类似的情境却可能表现出截然不同的反应，这是因为我们的想法不同。我们对朋友的责难做何反应，取决于我们对其所做的解释，取决于我们是把它归咎于朋友的敌意行为，还是归结于他糟糕的心情。&lt;br&gt;从某种角度来说，我们都是天生的科学家。我们解释着他人的行为，通常足够快也足够准确，以适应我们日常生活的需要。当他人的行为具有一致性而且与众不同时，我们会把其行为归因于他们的人格。例如。如果你发现一个人说话总是对人冷嘲热讽．你可能就会推断此人秉性不良，然后便设法尽量避免与他的接触。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然这是指更大范围内的人类心理，在对数据和模型的痴迷上，人类的欲望显然也是强烈的，人类总是想尽一切的办法打破现有的桎梏，在创造了更多的不确定性之后，期望通过对数据的把控和预测以看到更确切的未来。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://suool.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://suool.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最小二乘法的朴素实现</title>
    <link href="http://suool.net/2018/06/24/Least-Squares/"/>
    <id>http://suool.net/2018/06/24/Least-Squares/</id>
    <published>2018-06-24T12:23:21.000Z</published>
    <updated>2018-07-01T14:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最小二乘法（Least Squares Method, 简记为LS）的维基解释。 </p><blockquote><p>最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="维基百科[最小二乘法](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95)">[1]</span></a></sup></p></blockquote><p>如果大学的时候学过高等数学，或许你对这个名词就不会陌生，这是下册第九章第十节的内容。<br><a id="more"></a><br>其表示法为</p><script type="math/tex; mode=display">\min\sum_in(y_m^{(i)}-y^{(i)})^2</script><p>其中 $y_m$ 表示我们拟合函数得到的拟合结果，$y_i$ 表示真实值。</p><p>&emsp; &emsp; “最小二乘法”是最优化问题中建立经验公式的一种实现方法。了解它的原理，对于了解后面“Logistic回归”和“支持向量机的学习”都很有裨益。</p><p>这次就是最小二乘法的朴素实现，即是不借助矩阵、向量等，纯粹借助数学标量推导完成。</p><h2 id="起源背景"><a href="#起源背景" class="headerlink" title="起源背景"></a>起源背景</h2><p>最小二乘法是在十九世纪的产生的，源于天文学和测地学上的应用需要。</p><p>其中高斯使用的最小二乘法的方法发表于1809年他的著作《天体运动论》中，而法国科学家勒让德于1806年独立发现“最小二乘法”，但因不为时人所知而默默无闻。两人曾为谁最早创立最小二乘法原理发生争执。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="维基百科[最小二乘法](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95)">[1]</span></a></sup></p><p>1829年，高斯提供了最小二乘法的优化效果强于其他方法的证明，即高斯-马尔可夫定理。</p><h2 id="使用及实现"><a href="#使用及实现" class="headerlink" title="使用及实现"></a>使用及实现</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>“最小二乘法”的核心就是保证所有数据偏差的平方和最小。</p><p>首先有这样一组看起来比较杂乱的数据，这组数据是 1896 到 2008 年间部分年份的男子百米赛跑最佳成绩，其散点图效果如下：<br><img src="https://suool-bolg.b0.upaiyun.com/2018/06/26/F8FC66C1-84BB-450C-BE96-8477C1C0C45F.png" alt="散点图"></p><p>如何于混沌中找出规律，在杂乱中确定关系，往往是我们最关心的事情，那么对于上面这样一组数据，我们就尝试对它进行建模拟合。</p><p>最简单的拟合是线性建模的拟合，即假设存在最佳的线性关系 $y=f(x;w_0,w_1)=w_0+w_1x $  可以拟合这组数据。</p><h3 id="什么是最好？"><a href="#什么是最好？" class="headerlink" title="什么是最好？"></a>什么是最好？</h3><p>这里首先要解决的一个问题就是什么是“最佳”？或者如何衡量“最佳”？这里最佳显然是存在由一组$w_0,w_1$确定的直线，这条直线尽可能的与所有的数据点接近，那么衡量远近即距离的最佳方法显然使用平方差，则这里可以使用下面这样一个平方差函数表示( $x_n$ 是年份，$t_n$ 是比赛成绩)： </p><script type="math/tex; mode=display">\mathcal{L}_n =(t_n-f(x_n;w_0,w_1))^2</script><p>这个表达式的值越小，则表示误差越小。</p><p>这里用下面的公式表示 N 年的平均损失，最小二乘损失函数</p><script type="math/tex; mode=display">\mathcal{L}= \frac{1}{N} \sum_{n=1}^{N} \mathcal{L}_n(t_n,f(x_n;w_0,w_1 ))</script><p>这个值显然越小越好，而其最小的关键是寻找到最合适的$w_0, w_1$，这个数学表达式为</p><script type="math/tex; mode=display">\mathop{\arg\;\min}\limits_{w_0, w_1} \frac{1}{N} \sum_{n=1}^{N} \mathcal{L}_n(t_n,f(x_n;w_0,w_1 ))</script><p>此时将函数关系表示为</p><script type="math/tex; mode=display">f(x_n;w_0,w_1) = w_0 + w_1x</script><p>代入最小二乘损失函数，得到结果为：</p><script type="math/tex; mode=display">\begin{align}\mathcal{L} &= \frac{1}{N} \sum_{n=1}^{N} \mathcal{L}_n(t_n,f(x_n;w_0,w_1 )) \\& = \frac{1}{N} \sum_{n=1}^{N}(w_1^2x_n^2 + 2w_1x_n(w_0-t_n)+w_0^2-2w_0t_n+t^2)\end{align}</script><p>在上述函数 $\mathcal {L}$ 的最小值点处，其关于 $w_0$ 和 $w_1$ 的偏导数一定是 0。因此，对上函数式求偏导，使其等于 0 并对 $w_0$ 和 $w_1$ 求解，可以得到最小值。</p><h3 id="化简结果"><a href="#化简结果" class="headerlink" title="化简结果"></a>化简结果</h3><p>关于 $w_0$ 和 $w_1$ 的表示式分别为</p><script type="math/tex; mode=display">\left\{ \begin{array}{c}\hat{w_0} = \overline {t} - w_1\overline {x} \\ \hat{w_1} = \frac {\overline {xt} - \overline{x} \overline{t}} {\overline{x^2}-(\overline{x})^2} \end{array}\right.</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>有了上述的表达式，直接使用代码计算得出的结果如下：<br><img src="https://suool-bolg.b0.upaiyun.com/2018/06/26/5C466B2C-2AF5-4469-A8F5-5325E8C7D2B5.png" alt="线性建模结果"></p><p>代码实现如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-<span class="number">8</span> -*</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as <span class="built_in">np</span></span><br><span class="line"></span><br><span class="line">x_cord = []</span><br><span class="line">y_cord = []</span><br><span class="line">def drawScatterDiagram(fileName):</span><br><span class="line">    fr=open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr=line.<span class="built_in">split</span>(',')</span><br><span class="line">        x_cord.<span class="built_in">append</span>(<span class="built_in">float</span>(lineArr[<span class="number">0</span>]))</span><br><span class="line">        y_cord.<span class="built_in">append</span>(<span class="built_in">float</span>(lineArr[<span class="number">1</span>]))</span><br><span class="line">    plt.scatter(x_cord,y_cord,s=<span class="number">30</span>,c='red',marker='o', alpha=<span class="number">0.7</span>)</span><br><span class="line">    plt.<span class="built_in">xlabel</span>(<span class="string">"year"</span>)</span><br><span class="line">    plt.<span class="built_in">ylabel</span>(<span class="string">"time"</span>)</span><br><span class="line">    plt.<span class="built_in">title</span>(<span class="string">"result of game"</span>)</span><br><span class="line"></span><br><span class="line">def linearCalculate():</span><br><span class="line">    x = <span class="built_in">np</span>.<span class="built_in">array</span>(x_cord)</span><br><span class="line">    y = <span class="built_in">np</span>.<span class="built_in">array</span>(y_cord)</span><br><span class="line">    x_mean = <span class="built_in">np</span>.<span class="built_in">mean</span>(x_cord)</span><br><span class="line">    y_mean = <span class="built_in">np</span>.<span class="built_in">mean</span>(y_cord)</span><br><span class="line">    xy_mean = <span class="built_in">np</span>.<span class="built_in">mean</span>(x*y)</span><br><span class="line">    x_square_mean = <span class="built_in">np</span>.<span class="built_in">mean</span>(x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    w1 = (xy_mean-x_mean*y_mean)/(x_square_mean-x_mean**<span class="number">2</span>)</span><br><span class="line">    w0 = y_mean - w1*x_mean</span><br><span class="line">    xasix = <span class="built_in">np</span>.linspace(<span class="number">1896</span>, <span class="number">2008</span>, <span class="number">112</span>)</span><br><span class="line">    yasix = w1 * xasix + w0</span><br><span class="line">    plt.plot(xasix,yasix, <span class="built_in">label</span>='<span class="built_in">linear</span> line')</span><br><span class="line">    plt.<span class="built_in">legend</span>(loc='upper right')</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == '__main__':</span><br><span class="line">    drawScatterDiagram(<span class="string">"olympic100m.txt"</span>)</span><br><span class="line">    linearCalculate()</span><br><span class="line">    plt.<span class="built_in">show</span>()</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">维基百科<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="noopener">最小二乘法</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最小二乘法（Least Squares Method, 简记为LS）的维基解释。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。 &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-right hint--error hint--large&quot; aria-label=&quot;维基百科[最小二乘法](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95)&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果大学的时候学过高等数学，或许你对这个名词就不会陌生，这是下册第九章第十节的内容。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://suool.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://suool.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>信息论、贝叶斯及机器学习</title>
    <link href="http://suool.net/2018/06/21/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%92%8C%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://suool.net/2018/06/21/信息论和贝叶斯/</id>
    <published>2018-06-21T12:23:21.000Z</published>
    <updated>2018-07-01T14:10:09.701Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>1956年，让机器来做聪明的事情的科学被称为“人工智能”。直到1997年，人类才创造出来能下象棋的电脑并打败了世界冠军。通过这样的一个例子及数字计算机的发展历史表明，感知其实是一个很难解决的问题。但是，我们的脑却能够很简单的解决这个问题，这是否意味着，数字计算机不是人脑的一个好隐喻？或者，我们需要为计算机的运行找新的运算方式？</p><a id="more"></a><p>同时信息论的发展使得我们看到物理事件和电脉冲是如何转化为精神事件和讯息的。但是，在最初表达中存在一个根本的问题。一条信息中的信息量，或者更通俗的说，任何刺激中的信息量完全由那个刺激源来决定，这种界定信息的方法看上去很完美，实际上会产生自相矛盾的结果。</p><p>比如在图像的处理中，图片是由像素点组成的，以此形成不同的颜色。比如看这样一张图片，它是一张简单的以白色为背景的黑色正方形的图片，这张图片中的哪些要素含有最多的信息？当我们的眼睛扫过一个颜色不变的区域的时候，因为没有任何的改变，就不会产生任何的惊奇感。而当我们眼睛扫到边缘的时候，颜色突然变化，我们就会感到“惊奇”。因此，根据信息论，图片的边缘所含的信息量是最大的，这和我们的直觉也确实是相符的，假如我们用轮廓来代替这个物体，换句话说，只留下有信息的边缘，我们仍然能够认出这个物体。</p><p><img src="https://suool-bolg.b0.upaiyun.com/2018/06/21/06E79D3A-1211-4697-A3AF-B712D13C4EAE-1.png" alt="轮廓信息"></p><p>但是，这种表述实际上是自相矛盾的，按照这种界定，当我们用眼睛扫一幅图片的时候，我们预测不到接下来会发生什么，这样子的图片所含的信息量最多，完全由随机的点构成。比如电视机出现故障的时候出现的“雪花”屏幕，如果说这样子的图片含有最丰富的信息，恐怕你是不会同意的。<br><img src="https://suool-bolg.b0.upaiyun.com/2018/06/21/BAD85663-52A5-47A4-BCAB-3FF1D50B4FA6-1.png" alt="雪花"></p><p>出现这种矛盾的问题在于，信息论没有考虑到观看者本身，更根本的说，是没有考虑到观看者的先验知识和预期期望，这些不同会明显的影响我们对事物的感知。</p><p>比如刚刚提到的黑色正方形，对于一些观看者来说，这就是一个黑色正方形，但是这个黑色正方形是俄罗斯绘画至上主义者的幻想、非具象艺术的首例，它是 Kazimir Malevich 于1913年展示的。这个例子里，知道“这是一件重要的艺术品”的先验知识，可以改变你对这个黑色正方形的感知，虽然它的信息量并无改变。<br><img src="https://suool-bolg.b0.upaiyun.com/2018/06/21/A905B126-2523-491D-9574-1313E36D0557.png" alt="Kazimir Malevich"></p><h2 id="Thomas-Bayes-牧师"><a href="#Thomas-Bayes-牧师" class="headerlink" title="Thomas Bayes 牧师"></a>Thomas Bayes 牧师</h2><p>那么如何修正信息论使它能够考虑到观察者的不同经历和期望呢？我们可以说一条讯息携带的信息量可以达到改变接受者对世界信念的程度。要知道讯息承载了多少信息量给接收者，我们就得在讯息到达之前了解接收者的信念，然后才能知道接受者在收到讯息之后的信念改变了多少。但是，能否测量出接受者前先前的信念和信念的变化呢？</p><p>这个问题的答案就是每个学习过概率论和数理统计的人都知道的贝叶斯定理。</p><p>提出贝叶斯定理的 Thomas Bayes 牧师不是一个墨守成规的人，他的一生（1702-1761）没有发表过一篇论文，但是他在1742年却成为了英国皇家学会的会员。直到去世后两年，他的经典论文才被发表，而后的一百多年来，他的经典论文依然为人遗忘而无人问津。直到20世纪20年代，他才声名鹊起。对于当时的英国皇家协会主席和统计学界的人看来，Bayes 是一个的的确确的伟人，而在统计学界之外，他毫无名气，而且那些了解贝叶斯统计的人也常常认为它缺少适当的客观性。</p><p>然而，20世纪末至今，Thomas Bayes 成为了一个超级巨星。如今当你学习概率论或者想要入门人工智能，一个绕不过去的坎就是贝叶斯定理以及由此引发出的各种理论。</p><p>贝叶斯定理火起来之后，也导致了统计学的贝叶斯学派和频率学派的不休的争论。理解这二者的区别，对于理解贝叶斯定理也有一定的帮助，这里就简单的说一下。</p><h3 id="频率学派"><a href="#频率学派" class="headerlink" title="频率学派"></a>频率学派</h3><p>频率学派认为，我们要观察的现象，其分布是确定的，是一直不变的，而我们所需要做的就是不断的做试验来接近它。因此对于频率学派来说，可以通过大量的独立重复实验，观察事件出现的频率来估计它出现的概率。针对模型$P(x;θ)$来说，频率学派认为模型的参数是存在且固定的，我们要做的就是求出让$P(x;θ)$值最大的参数$θ$（我们认为这样的参数更接近于客观存在的那个真实的参数），也就是通过不断的调整参数来使得通过该模型在该参数下我们所观察到的现象出现的概率最大。</p><p>可以看出频率学派是针对似然来进行建模的，他更关心的的是似然$P(x|θ)$，也就是在怎样的参数$θ$下能使得我们所观察到的现象出现的概率最大。因此针对这样的关注重点，通常使用极大似然法来求解模型参数。<br>基于这种思想的方法，其缺点很明显，就是很容易过拟合，因为它的目标是尽最大努力来重现当前观察到的数据，这就是这种方法最大的问题所在。因此如何解决过拟合问题是基于频率思想方法必然要考虑的。通常我们会使用以下两种方法来缓解过拟合问题：（当然不限于此类问题的解决，很多其他的算法都可以用这些方法来解决 Over Fitting 的问题）</p><ul><li>使用 $L1 \;或\; L2$ 正则化，即在目标函数中加入正则项（罚项）；</li><li>使用交叉验证方法</li></ul><h3 id="贝叶斯学派"><a href="#贝叶斯学派" class="headerlink" title="贝叶斯学派"></a>贝叶斯学派</h3><p>对于贝叶斯学派，它不再相信上帝的存在，即不再相信任何的事件发生的背后都拥有一个固定不变的分布，而更倾向于认为世界上所有的事情都是不确定的，而这种不确定性更多是由于观察者自身所储备的先验知识所带来的。因此对于贝叶斯学派，其通常会基于观察到的事件来假设一个先验分布$P(y)$，然后利用贝叶斯公式：</p><script type="math/tex; mode=display">P(y|x)= \frac{P(x,y)}{p(x)} = \frac {P(x|y)P(y)} {P(x)} = \frac {P(x|y)P(y)} {\sum_{y \in Y} P(x|y)P(y)}</script><p>来求得后验分布。而后验分布我们又可以认为是在得到新的知识$x$后对先验分布的一个修正。因此对于贝叶斯学派，其认为对于事物的观察是一个不断学习不断修正的过程。</p><p>这里站在脑科学的层面对上面的贝叶斯公式做一个解释，假定现象 $y$ 是我们要了解的，观察资料 $x$ 是关于 $y$ 的证据，贝叶斯定理告诉我们，鉴于新证据 $x$ ，我们应该更新多少关于 $y$ 的知识。我们可以先不必担心这个等式的细节。重要的是，这个等式恰好是我们一直在寻找的关于信念的数学等式。在这里，表达信念的数学术语是概率。概率提供了我们对某事的信任尺度。当我们对于某件事是完全确定的时候（比如太阳从东方升起），概率就是 1，可以表示为 $p(日出东方)=1$。如果确定某件事不会发生，那么概率就是 0。但是，我们大部分的时候信念是不坚定的，处于 0 和 1 之间，比如 $p(今天上班可能要迟到)=0.5$，我得到了新的证据，那么这个处于中间的信念的概率就会不断地修正调整，比如上班之前，看了天气预报，等下要下大暴雨，那么这个信念可能就会发生显著地变化，当然有时候可能并不会发生什么变化。</p><p>贝叶斯定理可以精确的说明在已知新证据 $x$ 的情况下，我们应该改变多少关于 $y$ 的信念，这个等式中，$P(y)$ 是新证据 $x$ 出现之前我对于 $y$ 的先验信念。 $P(x|y)$ 是在 $y$ 确定的前提下，得到证据 $x$ 的可能性。 $P(y|x)$ 是在考虑新证据后我对于 $y$ 的后验信念。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>而事实上，我们可以认为我们对世界的感知是一种与现实相符的幻觉。</p><p>首先我们对于现实世界的感知的一切都来自于脑的反馈，而大脑是如何做出一个判断的呢？比如在你看到这篇文章的每个字，每个标点，每句话的时候，我们的大脑是如何做出判断的呢？</p><p>显然，脑的判断来自于各个感官（眼睛、耳朵等）的感觉，综合各个感官所提供的证据 $p(x|y)$，我们的大脑会做出一个基于我们已有的先验知识的判断。</p><p>当大脑的判断出现错误或者误差的时候，我们的大脑也会利用这些新的误差（新的证据）来更新我们对于世界的信念，并产生一个更好的信念 $p(y|x)$，一旦这种更新发生，我们的脑就对世界产生了一个新的信念，并通过感官察觉的活动模式进行新的预测。大脑每重复一次这样的过程，每循环一次，预测的误差就会减少一些，当误差变得足够小的时候，大脑就可以“知道”外在世界的东西到底是何物了，这在某程度上来说，这正是我们学习的过程。（而此时是否是真的知道呢？是否可以如这一节开头所说“我们对世界的感知是一种与现实相符的幻觉”？）。</p><p>这样一个认知的过程，除了在学习新的信念（比如学习新语言或者技能）的时候，我们能深刻的体会到，大部分时候我们是几乎体验不到的，因为，处理平常判断的时候，大脑的运算速度非常之快，快到我们自以为判断客观世界的物体到底是何物是一件轻而易举的事情，但是我们的大脑却永远的陷入这种永无止境的贝叶斯预测和更新循环当中。</p><p>所以，先验知识是非常重要的学习依据，当我们面对一个毫无先验知识的物体的时候，恐怕真的会像《West World》中的 host 那样脱口而出一句话：“It doesn’t look like anything to me”。</p><p>而这种思维在机器学习领域的应用也非常广泛且效果显著。</p><p>下一次，我将将贝叶斯定理应用于机器学习，和你分享如何使用朴素的贝叶斯方法来进行简单的分类工作，比如识别手写数字，新闻素材的主题分类。</p><blockquote><p>本文的大部分内容摘自<a href="https://book.douban.com/subject/10864488/" target="_blank" rel="noopener">《心智的构建——脑如何创造我们的精神世界》</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="Chris Frith . 心智的构建［M]. 华东师范大学出版社，2012-7.">[1]</span></a></sup>一书，这是一本很久前读的书，最近学习机器学习的时候，觉得贝叶斯这一块有种似曾相识的熟悉（先验知识的“作祟”），仔细一想便想到这本书中谈到过，因此，重新翻出，形成本文，对于脑科学和认知科学感兴趣的同学推荐阅读一下，是一本不可多得的好书。</p></blockquote><h2 id="文献引用"><a href="#文献引用" class="headerlink" title="文献引用"></a>文献引用</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Chris Frith . 心智的构建［M]. 华东师范大学出版社，2012-7.<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;1956年，让机器来做聪明的事情的科学被称为“人工智能”。直到1997年，人类才创造出来能下象棋的电脑并打败了世界冠军。通过这样的一个例子及数字计算机的发展历史表明，感知其实是一个很难解决的问题。但是，我们的脑却能够很简单的解决这个问题，这是否意味着，数字计算机不是人脑的一个好隐喻？或者，我们需要为计算机的运行找新的运算方式？&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://suool.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://suool.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论之线性空间和内积空间</title>
    <link href="http://suool.net/2018/06/18/%E7%9F%A9%E9%98%B5%E8%AE%BA%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E7%A7%AF%E7%A9%BA%E9%97%B4/"/>
    <id>http://suool.net/2018/06/18/矩阵论之线性空间和内积空间/</id>
    <published>2018-06-18T08:54:57.000Z</published>
    <updated>2018-07-01T14:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="预备知识-集合-映射-数域"><a href="#预备知识-集合-映射-数域" class="headerlink" title="预备知识:集合, 映射, 数域"></a>预备知识:集合, 映射, 数域</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>定义<ul><li>集合: 由具有某种性质所确定的事物的总体.<a id="more"></a></li></ul></li><li>表示法<ul><li>列举法</li><li>概括法</li></ul></li><li>其他概念<ul><li>子集</li><li>包含关系</li><li>集合相等</li><li>有限集</li><li>无限集</li><li>空集</li></ul></li><li>集合运算<ul><li>并集<script type="math/tex; mode=display">A \cup B = \{x\mid x \in A  \text { 或 } x\in B\} \tag{1}</script></li><li>交集<script type="math/tex; mode=display">A \cap B = \{ x \mid x \in A \text { 且 } x \in B \} \tag{2}</script></li><li>二元关系<ul><li>集合的 Descartes 积</li><li>$A \times B$ 的子集 R 是$A \times B$中的一个二元关系</li><li>等价关系</li><li>等价类</li><li>商集</li><li>分类</li></ul></li></ul></li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射是函数概念的推广, 描述了两个集合的元素之间的关系</p><ul><li><p>基本概念</p><ul><li>映射</li><li>像</li><li>原像</li><li>定义域</li><li>值域</li><li>符号<script type="math/tex; mode=display">f : A \to B \tag{3}</script></li><li>恒等映射/单位映射</li><li>单映射</li><li>满映射</li><li>双映射</li><li>映射相等</li><li>映射的乘积<ul><li>设 $A, B, C$ 是三个非空集合,并设有两个映射 $f_1: A \to B$ , $f_2: B \to C$ , 由$f_1 \text{ 和 } f_2 $ 确定的 $A$ 到 $C$ 的映射 $f_3: a \to f_2(f_1(a)), a \in A$  成为映射$f_1 \text{ 和 } f_2 $ 的乘积, 记为 $f_3 = f_2 \cdot f_1$</li><li>映射的乘积不具有交换律, 具有结合律</li></ul></li><li><p>逆映射 $f^{-1}$ </p><ul><li>可逆映射的逆映射唯一</li><li>可逆映射的充要条件是一一映射 </li></ul><h3 id="数域和代数运算"><a href="#数域和代数运算" class="headerlink" title="数域和代数运算"></a>数域和代数运算</h3></li><li><p>定义</p><ul><li>设 ${\displaystyle {\mathcal {P}}}$ 是复数域 ${\displaystyle \mathbb {C} } $ 的子集。若 ${\displaystyle {\mathcal {P}}}$ 中包含0与1，并且 ${\displaystyle {\mathcal {P}}}$ 中任两个数的和、差、乘积以及商（约定除数不为0）都仍在 ${\displaystyle {\mathcal {P}}}$ 中，就称 ${\displaystyle {\mathcal {P}}}$ 为一个数域</li></ul></li><li><p>代数运算</p></li><li>二元运算 </li></ul></li></ul><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h2 id="向量组的极大线性无关组和秩"><a href="#向量组的极大线性无关组和秩" class="headerlink" title="向量组的极大线性无关组和秩"></a>向量组的极大线性无关组和秩</h2><h2 id="矩阵的秩及等价标准形"><a href="#矩阵的秩及等价标准形" class="headerlink" title="矩阵的秩及等价标准形"></a>矩阵的秩及等价标准形</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;预备知识-集合-映射-数域&quot;&gt;&lt;a href=&quot;#预备知识-集合-映射-数域&quot; class=&quot;headerlink&quot; title=&quot;预备知识:集合, 映射, 数域&quot;&gt;&lt;/a&gt;预备知识:集合, 映射, 数域&lt;/h2&gt;&lt;h3 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义&lt;ul&gt;
&lt;li&gt;集合: 由具有某种性质所确定的事物的总体.
    
    </summary>
    
      <category term="数学" scheme="http://suool.net/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="线性代数" scheme="http://suool.net/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="矩阵论" scheme="http://suool.net/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中的数学基础--线性代数</title>
    <link href="http://suool.net/2018/06/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://suool.net/2018/06/18/机器学习中的数学基础-线性代数/</id>
    <published>2018-06-17T16:39:23.000Z</published>
    <updated>2018-07-01T14:10:09.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>换了个新的博客主题,开启新的学习主题.</p></blockquote><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="标量、向量、矩阵和张量"><a href="#标量、向量、矩阵和张量" class="headerlink" title="标量、向量、矩阵和张量"></a>标量、向量、矩阵和张量</h2><ul><li><p>标量(scalar): 一个标量就是一个单独的数，它不同于线性代数中研<br>究的其他大部分对象(通常是多个数的数组)。</p><a id="more"></a></li><li><p>向量(vector): 一个向量是一列数。这些数是有序排列的。通过次序中的索引，我们可以确定每个单独的数。</p></li><li>矩阵(matrix): 矩阵是一个二维数组，其中的每一个元素被两个索引(而非一个)所确定。</li><li>张量(tensor): 在某些情况下，我们会讨论坐标超过两维的数组。一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们称之为张量。</li></ul><p><strong>转置(transpose)</strong>是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像， 这条从左上角到右下角的对角线被称为 主对角线(main diagonal)。我们将矩阵 A 的转置表示为 $A^T$，定义如下</p><script type="math/tex; mode=display">(A^T)_{i,j} = A_{j,i} \tag{1}</script><p>向量可以看作只有一列的矩阵。对应地，向量的转置可以看作是只有一行的矩阵。标量可以看作是只有一个元素的矩阵。</p><p>只要矩阵的形状一样，我们可以把两个矩阵相加。两个矩阵相加是指对应位置的元素相加。</p><p>标量和矩阵相乘，或是和矩阵相加时，我们只需将其与矩阵的每个元素相乘或相加。</p><h2 id="矩阵和向量相乘"><a href="#矩阵和向量相乘" class="headerlink" title="矩阵和向量相乘"></a>矩阵和向量相乘</h2><p>两个矩阵 $\bf A$ 和 $ \bf B$ 的矩阵乘积 (matrix product) 是第三个矩阵 $\bf C$。为了使乘法定义良好，矩阵 $\bf A$ 的列数必须和矩阵 $\bf B$ 的行数相等。如果矩阵 $\bf A$的形状是 $m \times n$，矩阵 B 的形状是 $ n \times p$，那么矩阵$\bf C$的形状是 $ m \times p $ ，具体地，该乘法操作定义为 </p><script type="math/tex; mode=display">C _{i,j} = \sum_{k} {A_{i,k}}B_{k,j}\tag{2}</script><p>两个相同维数的向量 x 和 y 的 点积 (dot product) 可看作是矩阵乘积 $x^⊤y$。我 们可以把矩阵乘积 $C=AB$ 中计算 $C_{i,j}$ 的步骤看作是 $A$ 的第 $i$ 行和 $B$ 的第 $j$ 列之间的点积。</p><p>两个向量点积的结果是标量</p><h2 id="单位矩阵和逆矩阵"><a href="#单位矩阵和逆矩阵" class="headerlink" title="单位矩阵和逆矩阵"></a>单位矩阵和逆矩阵</h2><p> 单位矩阵 (identity matrix)<br> 矩阵逆 (matrix inversion)</p><p> 任意向量和单位矩阵相乘，都不会改变。</p><p>单位矩阵的结构很简单:所有沿主对角线的元素都是 1，而所有其他位置的元素都是 0。如下所示。</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\0 & 0 & 1 \\  \end{bmatrix} \tag{3}</script><p>矩阵 $A$ 的矩阵逆(matrix inversion)记作 $A^{−1}$，其定义的矩阵满足如下条件</p><script type="math/tex; mode=display">A^{−1}A = I_n.\tag{4}</script><p>一组向量的线性组合，是指每个向量乘以对应标量系数之后的和，即:</p><script type="math/tex; mode=display">\sum_{i} {c_iv^i}.\tag{5}</script><p>一组向量的<strong>生成子空间(span)</strong>是原始向量线性组合后所能抵达的点的集合</p><p>如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为<strong>线性无关 (linearly independent</strong>)。</p><p>一个列向量线性相关的方阵被称为<strong>奇异的(singular)</strong></p><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>在机器学习中，我们经常使用被称为<strong>范数 (norm)</strong>的函数衡量向量大小。形式上，$L^p$ 范数定义如下</p><script type="math/tex; mode=display">||x||_p=\left(\sum_{i}{|x_i|^p}\right)^{\frac{1}{p}}\tag{6}</script><p>其中 $p \in R , p \geq 1 $.</p><p>范数(包括 $L^p$ 范数)是将向量映射到非负值的函数。直观上来说，向量 $x$ 的范数衡量从原点到点 $x$ 的距离。</p><p>当 $p = 2$ 时，$L^2$ 范数被称为<strong>欧几里得范数(Euclidean norm)</strong>。它表示从原点出发到向量 $x$ 确定的点的欧几里得距离。$L^2$ 范数在机器学习中出现地十分频繁，经常简化表示为 $∥x∥$，略去了下标 2。平方 $L^2$ 范数也经常用来衡量向量的大小，可以简单地通过点积 $x^⊤x$ 计算。</p><p>平方 $L^2$ 范数在数学和计算上都比 $L^2$ 范数本身更方便。例如，平方 $L^2$ 范数对 $x$ 中每个元素的导数只取决于对应的元素，而 $L^2$ 范数对每个元素的导数却和整个向量相关。但是在很多情况下，平方 $L^2$ 范数也可能不受欢迎，因为它在原点附近增长 得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素 是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数:$L^1$ 范数. $L^1$ 范数可以简化如下:</p><script type="math/tex; mode=display">||x||_1 = \sum_i {|x_i|}\tag{7}</script><p>当机器学习问题中零和非零元素之间的差异非常重要时，通常会使用 $L^1$ 范数。每当<br>$x$ 中某个元素从 0 增加 $\epsilon$，对应的 L1 范数也会增加 $\epsilon$ 。</p><p>另外一个经常在机器学习中出现的范数是 $L^\infty$ 范数，也被称为<strong>最大范数(max norm)</strong>。这个范数表示向量中具有最大幅值的元素的绝对值:</p><script type="math/tex; mode=display">||x||_\infty = \underset{i}{max}|x_i|\tag{8}</script><p>有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用 <strong>Frobenius 范数(Frobenius norm)</strong>，</p><script type="math/tex; mode=display">||A||_F = \sqrt {\sum_{i,j}A^2_{i,j}}\tag{9}</script><p>其类似于向量的 $L^2$ 范数。<br>两个向量的<strong>点积(dot product)</strong>可以用范数来表示。具体地，</p><script type="math/tex; mode=display">x^Ty=||x||_2||y||_2\cos\theta  \tag{10}</script><p>其中 $θ$ 表示 $x$ 和 $y$ 之间的夹角。</p><p>如果 $x^⊤y = 0$，那么向量 $x$ 和向量 $y$ 互相<strong>正交(orthogonal)</strong>。如果两个向量都有非零范数，那么这两个向量之间的夹角是 90 度。在 $R^n$ 中，至多有 $n$ 个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为 1，那么我们称它们 是<strong>标准正交(orthonormal)</strong>。</p><p><strong>正交矩阵(orthogonal matrix)</strong>是指行向量和列向量是分别标准正交的方阵,$A^{−1} = A^⊤$</p><h2 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h2><p><strong>特征分解(eigendecomposition)</strong>是使用最广的矩阵分解之一，即我们将矩阵分解成一组<strong>特征向量</strong>和<strong>特征值</strong>。<br>方阵 A 的<strong>特征向量(eigenvector)</strong>是指与 A 相乘后相当于对该向量进行缩放的非零向量 v:</p><script type="math/tex; mode=display">Av = \lambda v\tag{11}</script><p>标量 $λ$ 被称为这个特征向量对应的<strong>特征值(eigenvalue)</strong></p><p>A 的<strong>特征分解(eigendecomposition)</strong>可以记作</p><script type="math/tex; mode=display">A=Vdiag(\lambda)V^{-1}\tag{12}</script><p>所有特征值都是正数的矩阵被称为<strong>正定(positive definite)</strong>;所有特征值都是非负数的矩阵被称为<strong>半正定(positive semidefinite)</strong>。同样地，所有特征值都是负数的 矩阵被称为<strong>负定(negative definite)</strong>;所有特征值都是非正数的矩阵被称为<strong>半负定(negative semidefinite)</strong>。半正定矩阵受到关注是因为它们保证 $∀x, x^⊤Ax ≥ 0$。此外，正定矩阵还保证 $x^⊤Ax = 0 ⇒ x = 0$。</p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p><strong>奇异值分解(singular value decomposition, SVD)</strong>，将矩阵分解为<strong>奇异向量(singular vector)</strong>和<strong>奇异值(singular value)</strong>。通过奇异值分解，我们会得到一些与特征分解相同类型的信息。每个实数矩阵都有一个奇异值分解，但不一定都有特征分解。例如，非方阵的矩阵没有特征分解，这时我们只能使用奇异值分解。</p><p>分解表达式:</p><script type="math/tex; mode=display">A = UDV^⊤. \tag{13}</script><p>假设 $A$ 是一个 $m×n$ 的矩阵，那么 $U$ 是一个 $m×m$ 的矩阵，$D$ 是一个 $m×n$<br>的矩阵，$V$ 是一个 $n × n$ 矩阵。 这些矩阵中的每一个经定义后都拥有特殊的结构。矩阵 $U$ 和 $V$ 都定义为正交矩阵，而矩阵 $D$ 定义为对角矩阵。注意，矩阵 $D$ 不一定是方阵。<br>对角矩阵 $D$ 对角线上的元素被称为矩阵 $A$ 的<strong>奇异值(singular value)</strong>。矩阵 $U$ 的列向量被称为<strong>左奇异向量(left singular vector)</strong>，矩阵 $V$ 的列向量被称<strong>右奇异向量(right singular vector)</strong>。<br>事实上，我们可以用与 $A$ 相关的特征分解去解释 $A$ 的奇异值分解。$A$的<strong>左奇异向量(left singular vector)</strong>是 $AA^⊤$ 的特征向量。$A$ 的<strong>右奇异向量(right singular vector)</strong>是 $A^⊤A$ 的特征向量。A 的非零奇异值是 $A^⊤A$ 特征值的平方根，同时也是 $AA^⊤$ 特征值的平方根。</p><h2 id="迹运算"><a href="#迹运算" class="headerlink" title="迹运算"></a>迹运算</h2><p>迹运算返回的是矩阵对角元素的和:</p><script type="math/tex; mode=display">Tr(A)=\sum_i {A_{i,i}}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;换了个新的博客主题,开启新的学习主题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;线性代数&quot;&gt;&lt;a href=&quot;#线性代数&quot; class=&quot;headerlink&quot; title=&quot;线性代数&quot;&gt;&lt;/a&gt;线性代数&lt;/h1&gt;&lt;h2 id=&quot;标量、向量、矩阵和张量&quot;&gt;&lt;a href=&quot;#标量、向量、矩阵和张量&quot; class=&quot;headerlink&quot; title=&quot;标量、向量、矩阵和张量&quot;&gt;&lt;/a&gt;标量、向量、矩阵和张量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标量(scalar): 一个标量就是一个单独的数，它不同于线性代数中研&lt;br&gt;究的其他大部分对象(通常是多个数的数组)。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://suool.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://suool.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性代数" scheme="http://suool.net/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾指南之将你树莓派变成智能家居中枢</title>
    <link href="http://suool.net/2018/01/13/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E5%B0%86%E4%BD%A0%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8F%98%E6%88%90%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%B8%AD%E6%9E%A2/"/>
    <id>http://suool.net/2018/01/13/树莓派折腾指南之将你树莓派变成智能家居中枢/</id>
    <published>2018-01-13T09:45:13.000Z</published>
    <updated>2018-07-01T14:10:09.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="将你树莓派变成智能家居中枢"><a href="#将你树莓派变成智能家居中枢" class="headerlink" title="将你树莓派变成智能家居中枢"></a>将你树莓派变成智能家居中枢</h1><p>树莓派由于本身足够的小巧且扩展性极高，所以它智能家居方面的应用具有天然的优势。对于喜欢折腾和 Geek 的人的而言，其扩展性具有无比的吸引力。<br><a id="more"></a></p><p>这次我们就来尝试将树莓派变身为智能家居的管理中枢，将其桥接到苹果家的 Home 应用当中，使用 Siri 来控制所有的智能家居。</p><p>由于 Apple 家认证的智能家居暂时承担不起，而刚好又可以使用树莓派加上 <code>HomeBridge</code> 相关的框架来将小米的智能家居产品加入 <code>HomeKit</code> 。</p><p>我使用的是小米智能家居全家桶套装，极客学院送的2017年元旦讲师礼物，在此表示感谢！其包含内容产品主要有：多功能网关，人体传感器，智能插座，无线开关，门窗传感器。效果图如下：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158306050366.jpg" alt="-w629"></p><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158306313468.jpg" alt="-w451"></p><p>用习惯之后，不得不说确实很方便，特别是寒冷的冬天不用起床就能开关灯。</p><p>下面就进入正题，如何将你的树莓派变身智能家居桥接中枢。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h3><p>硬件：</p><ul><li>Raspberry Pi</li><li>小米智能家居产品</li></ul><p>软件：</p><ul><li><a href="https://github.com/nfarina/homebridge" target="_blank" rel="noopener">HomeBridge</a></li><li><a href="https://github.com/YinHangCode/homebridge-mi-aqara" target="_blank" rel="noopener">homebridge-mi-aqara</a></li></ul><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li>硬件准备和连接</li><li>软件环境和依赖安装</li><li>安装运行 <code>Homebridge</code></li><li>安装及配置 <code>homebridge-mi-aqara</code></li><li>测试及后台运行</li><li>其他</li></ol><h2 id="步骤一：硬件准备和连接"><a href="#步骤一：硬件准备和连接" class="headerlink" title="步骤一：硬件准备和连接"></a>步骤一：硬件准备和连接</h2><p>首先将你的<a href="https://www.jianshu.com/p/b62a8229a74c" target="_blank" rel="noopener">树莓派安装好系统并配置好</a>，最好可以使用 SSR 全局代理可以科学上网，这样可以改善你的树莓派网络环境，一定程度加快安装过程。具体的方法参考<a href="https://www.jianshu.com/p/445256a2367b" target="_blank" rel="noopener">之前的文章</a>。</p><p>使用 SSH 远程连接你的树莓派：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="literal">pi</span><span class="meta">@raspberrypi</span>.<span class="keyword">local</span></span><br></pre></td></tr></table></figure><p>更新树莓派相关依赖环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> upgrade</span><br></pre></td></tr></table></figure><p>完成之后进入下一步。</p><h2 id="步骤二：软件环境和依赖安装"><a href="#步骤二：软件环境和依赖安装" class="headerlink" title="步骤二：软件环境和依赖安装"></a>步骤二：软件环境和依赖安装</h2><p>首先安装这两个库使用的都是 <code>Node</code> 环境的 <code>npm</code> 工具，因此要先安装 <code>Node</code>，命令如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL http<span class="variable">s:</span>//<span class="keyword">deb</span>.nodesource.<span class="keyword">com</span>/setup_8.<span class="keyword">x</span> | sudo -E bash -</span><br><span class="line">sudo apt-<span class="built_in">get</span> install -<span class="keyword">y</span> nodejs</span><br></pre></td></tr></table></figure><p>其次需要安装 <code>avahi</code> 包</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install libavahi-compat-libdnssd-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>如果上述包安装出现错误，可以参考这里的<a href="https://stackoverflow.com/questions/26571326/how-do-i-resolve-the-following-packages-have-unmet-dependencies" target="_blank" rel="noopener">解决方法</a></p><p>尝试使用 </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude <span class="keyword">install</span> libavahi-compat-libdnssd-dev</span><br></pre></td></tr></table></figure><p>命令安装依赖，可能需要将相关软件包降级就可以顺利安装了。</p><h2 id="步骤三：安装运行-Homebridge"><a href="#步骤三：安装运行-Homebridge" class="headerlink" title="步骤三：安装运行 Homebridge"></a>步骤三：安装运行 Homebridge</h2><p>这里具体的安装步骤可以直接去参考其 github 主页的 wiki 内容。简单的来说，步骤如下:<br>首先可以试一下使用如下命令安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g homebridge</span><br></pre></td></tr></table></figure><p>如果上述命令安装过程出现了错误，那么可以尝试使用如下的命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">sudo npm install -g --unsafe-perm homebridge hap-nodejs node-gyp</span><br><span class="line">cd /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">node_modules</span>/<span class="title">homebridge</span>/</span></span><br><span class="line">sudo npm install --unsafe-perm bignum</span><br><span class="line">cd /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">node_modules</span>/<span class="title">hap</span>-<span class="title">nodejs</span>/<span class="title">node_modules</span>/<span class="title">mdns</span></span></span><br><span class="line">sudo node-gyp BUILDTYPE=Release rebuild</span><br></pre></td></tr></table></figure><p>上面的 <code>/usr/lib/</code> 目录，如果你不是使用的 <code>apt-get</code> 命令安装的 <code>Node</code>，需要换成 <code>/usr/local/lib/</code> 。<br>一定要严格安装上述命令的步骤来安装，该切换目录就切换目录。</p><p>此时安装应该不会有什么问题了。</p><h2 id="步骤四：安装及配置-homebridge-mi-aqara"><a href="#步骤四：安装及配置-homebridge-mi-aqara" class="headerlink" title="步骤四：安装及配置 homebridge-mi-aqara"></a>步骤四：安装及配置 homebridge-mi-aqara</h2><p>其项目主页是 <a href="https://github.com/YinHangCode/homebridge-mi-aqara" target="_blank" rel="noopener">homebridge-mi-aqara</a>，可以在他的项目主页看到其支持的小米硬件，基本是非常全面的。</p><p>安装命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="keyword">install</span> -g homebridge-mi-aqara</span><br></pre></td></tr></table></figure><p>安装完成之后，需要对其进行基本的配置，从而能够将你的小米全家桶硬件加入到 <code>HomeBridge</code> 中。</p><p>首先要获取的是 局域网通信协议密码 以及 网关的 <code>MAC</code> 地址。</p><p>下载米家 APP，连接上你的智能网关以及其他小米智能家居硬件，打开米家 APP，选择你的多功能网关，点击 APP 右上角 <code>···</code> 符号，进入 <code>关于</code> 选项:<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158331055340.jpg" alt=""><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158331906989.jpg" alt=""><br>如上图所示，要不断的点击空白处，片刻后界面就会多了<code>局域网通信协议</code>还有<code>网关信息</code>等选项。<br>这时候，分别点选他们，记录你的网关的<code>局域网通信协议密码</code>以及<code>网关的MAC地址</code>，记得要开启局域网通信协议，记录下密码后，点击确定。网关的 MAC 地址位置如下：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158337428781.jpg" alt=""></p><p>上面的 <code>MAC</code> 地址去除冒号，全变成小写后记录下来，是一串12位的字符。局域网通信协议密码要保留大小写的记录下来。</p><p>记录下上述两个地址之后，就可以开始在终端中配置 <code>HomeBridge</code> 的配置文件了。执行的命令如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir ~/<span class="selector-class">.homebridge</span> </span><br><span class="line">cd ~/<span class="selector-class">.homebridge</span>      </span><br><span class="line">sudo nano config.json</span><br></pre></td></tr></table></figure><p>执行了上述 nano 命令之后，会创建一个配置的 <code>json</code> 文件，将以下内粘贴到终端编辑环境中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bridge"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"Homebridge"</span>,</span><br><span class="line">        <span class="attr">"username"</span>:<span class="string">"CC:22:3D:E3:CE:23"</span>,</span><br><span class="line">        <span class="attr">"port"</span>:<span class="number">51826</span>,</span><br><span class="line">        <span class="attr">"pin"</span>:<span class="string">"723-92-124"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"platforms"</span>: [&#123;</span><br><span class="line">        <span class="attr">"platform"</span>: <span class="string">"MiAqaraPlatform"</span>,</span><br><span class="line">        <span class="attr">"gateways"</span>: &#123;</span><br><span class="line">            <span class="attr">"网关 mac 地址"</span>: <span class="string">"局域网通信协议密码"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述的两个参数替换成刚刚你记录下来的即可。其他参数说明：<br><code>name</code> iOS 的 <code>Homekit</code> 在添加配件的时候看到的名字<br><code>username</code> 如果只是用 <code>Homebridge</code>，这里可以是任意一个类似 <code>MAC</code> 地址的字符串<br><code>port</code> 随意，只要不被占用的端口<br><code>pin</code> iOS 的 <code>Homekit</code> 在添加配件时需要的验证码</p><p>使用 <code>Ctrl + o</code> 保存， <code>Ctrl + x</code> 退出。</p><h2 id="步骤五：测试及后台运行"><a href="#步骤五：测试及后台运行" class="headerlink" title="步骤五：测试及后台运行"></a>步骤五：测试及后台运行</h2><p>在终端输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">homebridge -D</span></span><br></pre></td></tr></table></figure><p>这时候，界面也会出现刚刚你自己填写的 PIN 码<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158339825667.jpg" alt=""></p><p>进入你 iPhone 或者 iPad 的家庭APP，添加配件，扫码几乎不可能加入成功，直接选择输入 PIN 码，即是输入下方的<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158342592263.jpg" alt=""><br>添加完成之后，你就会看到所有网关所附带的配件了，如我刚开始所配图的一般，不过此时按钮的名字可能是一串英文符号，你需要自己确定各个按钮的作用，给他们一个你想好的名字即可。</p><p>但是上面这个只是在测试环境运行，如果断了 SSH，你手机或者 iPad 里面的所有设备都会处于无响应的状态，所以，我们还需要能够在后台运行的 <code>Homebridge</code>。</p><p>借助 <code>screen</code> 工具即可实现这一需求，具体安装命令如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install screen</span><br></pre></td></tr></table></figure><p>安装完成之后，首先开一一个名字叫做 <code>home</code> 的窗口，具体的名字你可以随意选取，命令如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S <span class="built_in">home</span></span><br></pre></td></tr></table></figure><p>然后所打开的 <code>screen</code> 进程中开启一个 <code>homebridge</code> 进程</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">homebridge -D</span></span><br></pre></td></tr></table></figure><p>在 <code>screen</code> 里开启的 <code>homebridge</code> 不会随着 SSH 关闭而被关闭。使用 <code>Ctrl+A</code> 然后按 <code>d</code> 就可以跳出来了。</p><p>具体关于 <code>screen</code> 命令的用法你可以查看这里的文章: <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-screen/" target="_blank" rel="noopener">linux 技巧：使用 screen 管理你的远程会话</a> 及 <a href="http://www.runoob.com/linux/linux-comm-screen.html" target="_blank" rel="noopener">Linux screen命令</a>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>完成上面的步骤，此时你只能在你的路由器所在的局域网内完成智能家居的控制，如果要在外网实现操作，及 home 的自动化操作，你需要一台 iPad 作为家居中枢，具体的参考 <a href="https://support.apple.com/zh-cn/HT207057" target="_blank" rel="noopener">自动化和远程访问 HomeKit 配件</a></p><p>上面就是一个利用树莓派实现让 Siri 帮你开关灯的过程，下一步可以使用 <code>HomeAssistant</code> 来实现更加智能化和扩展化的家居管理。</p><p>更下一步的尝试可能会比较底层一些了：</p><ul><li>尝试一下扩展温湿度感应器模块</li><li>尝试使用 <code>GPIO</code> 控制 RGB 彩色 LED 灯</li><li>扩展摄像头模块，尝试一下人脸识别等基本的人工智能</li><li>扩展私有云存储及远程下载</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;将你树莓派变成智能家居中枢&quot;&gt;&lt;a href=&quot;#将你树莓派变成智能家居中枢&quot; class=&quot;headerlink&quot; title=&quot;将你树莓派变成智能家居中枢&quot;&gt;&lt;/a&gt;将你树莓派变成智能家居中枢&lt;/h1&gt;&lt;p&gt;树莓派由于本身足够的小巧且扩展性极高，所以它智能家居方面的应用具有天然的优势。对于喜欢折腾和 Geek 的人的而言，其扩展性具有无比的吸引力。&lt;br&gt;
    
    </summary>
    
      <category term="硬件" scheme="http://suool.net/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="树莓派" scheme="http://suool.net/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾指南之将你的树莓派变身 Google Home</title>
    <link href="http://suool.net/2018/01/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E5%B0%86%E4%BD%A0%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8F%98%E8%BA%AB-Google-Home/"/>
    <id>http://suool.net/2018/01/11/树莓派折腾指南之将你的树莓派变身-Google-Home/</id>
    <published>2018-01-10T16:20:12.000Z</published>
    <updated>2018-07-01T14:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="将你的树莓派变身-Google-Home"><a href="#将你的树莓派变身-Google-Home" class="headerlink" title="将你的树莓派变身 Google Home"></a>将你的树莓派变身 Google Home</h1><p>目前的智能化已经对人们的生活影响越来越深刻，从智能音箱鼻祖 Amazon Echo 发布之后，智能数字助理就进入了人们的生活当中，也成为人们生活的一部分，特别是其与智能家居配合之后，以前科幻电影中的场景，目前已经渐渐成为现实。<br><a id="more"></a></p><p>当前国内的厂家也有发布类似的产品，比如小米的小爱同学，阿里的天猫精灵等智能助理产品，智能家居加上智能助理中枢，将是物联网真正进入人们平常生活的最深刻的体现。</p><p>而且 Google 和 Amazon 都发布了自己语音助手的 SDK ，今天就来看一下如何接入<br><code>Google Assistant SDK</code> ，来体验一下树莓派版本的 <code>Google Home</code> 。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h3><p>硬件：</p><ul><li>Raspberry Pi</li><li>USB 麦克风或者免驱声卡搭配 3.5mm 接口麦克风</li><li>3.5mm 接口的扬声器</li></ul><p>软件：</p><ul><li>Google 账户</li><li>科学上网环境</li></ul><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li>硬件准备和网络连接</li><li>配置测试声音设备</li><li>配置开发者项目及相关设置</li><li>安装 SDK 和示例项目</li><li>注册你的硬件设备</li><li>运行示例代码</li><li>其他</li></ol><h2 id="步骤一：硬件准备和网络连接"><a href="#步骤一：硬件准备和网络连接" class="headerlink" title="步骤一：硬件准备和网络连接"></a>步骤一：硬件准备和网络连接</h2><ol><li>已经安装好系统并且搭建好科学上网环境的树莓派</li><li><p>连接你的麦克风和扬声器到树莓派，麦克风你可以购买一个免驱声卡，连接你的 3.5 mm  麦克风，比如下面这样的，几块钱就能买到。树莓派有一个 3.5mm 的耳机插口，你的扬声器可以接入此接口。<br> <img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155927429534.jpg" alt=""></p></li><li><p>将你的树莓派连接网络</p></li><li>ssh 远程连接你的树莓派</li></ol><h2 id="步骤二：配置测试声音设备"><a href="#步骤二：配置测试声音设备" class="headerlink" title="步骤二：配置测试声音设备"></a>步骤二：配置测试声音设备</h2><h3 id="第一步：确认你的录音和播放设备正常工作"><a href="#第一步：确认你的录音和播放设备正常工作" class="headerlink" title="第一步：确认你的录音和播放设备正常工作"></a>第一步：确认你的录音和播放设备正常工作</h3><ol><li>在命令行输入以下命令，按下 <code>Ctrl+C</code> 来结束。</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">speaker-test -t wav</span></span><br></pre></td></tr></table></figure><p>如果你没有听到任何声音，请检查你的扬声器和树莓派连接是否正常，或者扬声器是不是声音调的太小了。同时你可以通过输入以下命令<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-<span class="built_in">config</span></span><br></pre></td></tr></table></figure></p><p>选择<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155932467591.jpg" alt=""><br>然后选择<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155932800447.jpg" alt=""><br>将你的声音输出从耳机插口输出<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155933119751.jpg" alt=""></p><ol><li>录制一个简短的声音片段，如果你这时出现了问题，请转到下面的第二步。</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arecord <span class="attribute">--format</span>=S16_LE <span class="attribute">--duration</span>=5 <span class="attribute">--rate</span>=16000 <span class="attribute">--file-type</span>=raw out.raw</span><br></pre></td></tr></table></figure><ol><li>播放刚刚录制的音频来检查录制效果。</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay <span class="attribute">--format</span>=S16_LE <span class="attribute">--rate</span>=16000 out.raw</span><br></pre></td></tr></table></figure><p>调整你的录制和播放设备，通过下面这个命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">alsamixer</span></span><br></pre></td></tr></table></figure><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155937585522.jpg" alt=""></p><p>如果你的录制和播放设备工作正常，那么这一步的声音设备的配置就完成了，如果你出现了错误，那么可以继续下面的步骤尝试修复问题。</p><h3 id="第二步：找到你的录制和播放设备。"><a href="#第二步：找到你的录制和播放设备。" class="headerlink" title="第二步：找到你的录制和播放设备。"></a>第二步：找到你的录制和播放设备。</h3><p>通过下面这个命令来显示你的声音捕捉设备列表，找到你的麦克风，并记录下设备卡号和设备号。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">arecord -l</span></span><br></pre></td></tr></table></figure></p><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155941154890.jpg" alt="录音设备"><br>如上图所示的 <code>card num</code>  是1，<code>device num</code> 为 0。</p><p>通过下面这个命令来显示你的声音播放设备列表，记录下你的 3.5 mm  接口的设备卡号和设备号，3.5mm 设备的特征是带有 <code>Analog</code> 或者 <code>bcm2835 ALSA</code> (不是 bcm2835 IEC958/HDMI) 字段。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">aplay -l</span></span><br></pre></td></tr></table></figure><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155944050157.jpg" alt="播放设备"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>在你的 /home/pi 目录下创建一个名为 .asoundrc 文件，可以直接输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">sudo nano <span class="string">.asoundrc</span></span><br></pre></td></tr></table></figure><p>粘贴以下内容到你的终端编辑器内：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pcm.!default &#123;</span><br><span class="line"> <span class="built_in"> type </span>asym</span><br><span class="line">  capture.pcm <span class="string">"mic"</span></span><br><span class="line">  playback.pcm <span class="string">"speaker"</span></span><br><span class="line">&#125;</span><br><span class="line">pcm.mic &#123;</span><br><span class="line"> <span class="built_in"> type </span>plug</span><br><span class="line">  slave &#123;</span><br><span class="line">    pcm <span class="string">"hw:&lt;card number&gt;,&lt;device number&gt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pcm.speaker &#123;</span><br><span class="line"> <span class="built_in"> type </span>plug</span><br><span class="line">  slave &#123;</span><br><span class="line">    pcm <span class="string">"hw:&lt;card number&gt;,&lt;device number&gt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的两处 <code>&lt;card number&gt;,&lt;device number&gt;</code> ，分别是刚刚让你记录的麦克风和扬声器的设备卡号和设备号，比如刚刚我展示的图片，我的是内容是<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155947400239.jpg" alt=""></p><p>如果你有一个 HDMI 的声音输出并且连接了耳机接口，那么请按照刚刚上面 <code>sudo raspi-config</code> 的设置将你的声音输出强制从耳机接口输出。</p><p>然后重复步骤一看看是不是依然存在问题，如果依然存在问题，可以尝试更换你的声音录制和播放设备。</p><h2 id="步骤三：配置开发者项目及相关设置"><a href="#步骤三：配置开发者项目及相关设置" class="headerlink" title="步骤三：配置开发者项目及相关设置"></a>步骤三：配置开发者项目及相关设置</h2><p>Google 的开发者项目允许你的设备能够访问 <code>Google Assistant API</code>，为了能够访问这个 API，需要进行以下的配置工作。<br>首先，进入 Google 的 Cloud Platform Console，在你的<a href="https://console.cloud.google.com/project" target="_blank" rel="noopener">项目页面</a>，创建一个项目或者选一个已经存在的项目。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155950828092.jpg" alt=""></p><p>然后允许你刚刚所选的项目使用 <code>Google Assistant API</code>，点击以下链接<a href="https://console.developers.google.com/apis/api/embeddedassistant.googleapis.com/overview" target="_blank" rel="noopener">开通 Google Assistant API</a><br>点击启用即可。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155953311656.jpg" alt=""></p><p>然后通过下面的步骤创建一个客户端认证 ID 凭证：</p><ol><li><a href="https://console.developers.google.com/apis/credentials/oauthclient" target="_blank" rel="noopener">创建客户端 ID</a><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155954695217.jpg" alt=""></li><li>输入产品名称及其他可选信息，点击保存即可。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155955232716.jpg" alt="输入名称"></li><li>应用类型选择其他，并输入一个名称。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155956528728.jpg" alt="类型"></li><li>点击创建后弹出一个提醒的窗口，这里可以直接点击确定关闭它。</li><li>此时出现这样的界面：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155957656082.jpg" alt="列表"><br>点在下载图标，下载这个 json 文件。名字类似与<code>client_secret_client-id.json</code></li></ol><p>最后上面下载的文件必须放到 pi 用户的 Downloads 目录下面以授权使 <code>Google Assistant SDK</code> 示例项目正常使用，不要重命名这个文件。<br>可以通过以下方法来将刚刚下载的文件传到 Downloads 目录。</p><ol><li>在你的电脑新打开一个终端，<strong>不要 ssh 连接 pi</strong>，输入以下命令：</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp <span class="regexp">~/Downloads/</span>client_secret_具体你的文件名.json pi<span class="meta">@raspberry</span>-pi-ip-<span class="string">address:</span><span class="regexp">/home/</span>pi/</span><br></pre></td></tr></table></figure><p>然后输入密码。</p><ol><li>如果你是 Windows，你可以使用 FileZilla 等 ftp 工具，如下:<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155961850035.jpg" alt=""><br>打开 Downloads 目录，将你的文件拖入即可。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155962460662.jpg" alt=""></li></ol><p>为了使用 Google Assistant 你必须要共享一些活动数据给 Google，授予 <code>Google Assistant</code> 一定的权限，否则你运行项目的时候，她会一直跟你说，她需要权限才能跟你说话。<br>打开<a href="https://myaccount.google.com/activitycontrols" target="_blank" rel="noopener">活动控制页面</a><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155964264654.jpg" alt=""><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155964345681.jpg" alt=""><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155964424810.jpg" alt=""></p><h2 id="步骤四：安装-SDK-和示例项目"><a href="#步骤四：安装-SDK-和示例项目" class="headerlink" title="步骤四：安装 SDK 和示例项目"></a>步骤四：安装 SDK 和示例项目</h2><p>Google 推荐在 Python 的虚拟环境运行该项目，避免对系统环境造成影响，具体运行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> python3-dev python3-venv </span><br><span class="line">python3 -m venv env</span><br><span class="line">env/<span class="keyword">bin</span>/python -m pip <span class="keyword">install</span> <span class="comment">--upgrade pip setuptools</span></span><br><span class="line"><span class="keyword">source</span> env/<span class="keyword">bin</span>/<span class="keyword">activate</span></span><br></pre></td></tr></table></figure><p>上面的最后一条命令是激活虚拟环境，然后安装依赖软件包：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install portaudio19-<span class="built_in">dev</span> libffi-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>使用 pip 来安装最新版本的依赖包：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip <span class="keyword">install</span> <span class="comment">--upgrade google-assistant-library</span></span><br><span class="line">python -m pip <span class="keyword">install</span> <span class="comment">--upgrade google-assistant-sdk[samples]</span></span><br></pre></td></tr></table></figure><p>生成授权资格<br>首先安装及升级授权工具<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip <span class="keyword">install</span> <span class="comment">--upgrade google-auth-oauthlib[tool]</span></span><br></pre></td></tr></table></figure></p><p>然后在命令行输入一下命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">google-oauthlib-tool <span class="params">--scope</span> https:<span class="string">//www.googleapis.com/auth/assistant-sdk-prototype</span> \</span><br><span class="line">          <span class="params">--save</span> <span class="params">--headless</span> <span class="params">--client-secrets</span> <span class="string">/home/pi/Downloads/client_secret_</span>你的文件名<span class="string">.json</span></span><br></pre></td></tr></table></figure><p>然后你应该会在命令行中看到一个网址<br><code>Please visit this URL to authorize this application: https://...</code></p><p>将这个网址完整的 copy 到浏览器中，登陆你的 Google 账号，然后点击授权允许，你会在浏览器中看到一行代码，类似<code>4/XXXX</code>，将这行代码 copy 到命令行<code>Enter the authorization code:</code>的后面<br>如果授权成功，那么你会在类似下面的响应。<br><code>credentials saved: /path/to/.config/google-oauthlib-tool/credentials.json</code></p><h2 id="步骤五：注册你的硬件设备"><a href="#步骤五：注册你的硬件设备" class="headerlink" title="步骤五：注册你的硬件设备"></a>步骤五：注册你的硬件设备</h2><p>使用 Google 的注册工具，首先设备名最好是数字和字母的组合，首字段必须是数字或字母。<br>使用下面的命令格式注册：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">googlesamples</span><span class="literal">-</span><span class="comment">assistant</span><span class="literal">-</span><span class="comment">devicetool</span> <span class="comment">register</span><span class="literal">-</span><span class="comment">model</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">manufacturer</span> <span class="comment">生产者</span> <span class="comment">\</span></span><br><span class="line"><span class="comment"></span>          <span class="literal">-</span><span class="literal">-</span><span class="comment">product</span><span class="literal">-</span><span class="comment">name</span> <span class="comment">产品名</span> <span class="title">[</span><span class="literal">-</span><span class="literal">-</span><span class="comment">description</span> <span class="comment">my</span><span class="literal">-</span><span class="comment">product</span><span class="literal">-</span><span class="comment">description</span><span class="title">]</span> <span class="comment">\</span></span><br><span class="line"><span class="comment"></span>          <span class="literal">-</span><span class="literal">-</span><span class="comment">type</span> <span class="comment">device</span><span class="literal">-</span><span class="comment">type</span> <span class="title">[</span><span class="literal">-</span><span class="literal">-</span><span class="comment">trait</span> <span class="comment">支持的特性</span><span class="title">]</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">model</span> <span class="comment">我的设备</span></span><br></pre></td></tr></table></figure><p>上面的我的设备这个必须是一个唯一的名字，所以你可以使用你的项目 ID 作为前缀，下面的是 Google 的一个示例命令：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">googlesamples-assistant-</span><span class="string">devicetool </span><span class="string">register-model </span><span class="built_in">--manufacturer</span> <span class="string">"Assistant SDK developer"</span> \</span><br><span class="line">          <span class="built_in">--product-name</span> <span class="string">"Assistant SDK light"</span> <span class="built_in">--type</span> <span class="string">LIGHT </span><span class="built_in">--model</span> <span class="string">my-model</span></span><br></pre></td></tr></table></figure><p>然后使用以下命令向服务器查询你刚刚创建的设备：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">googlesamples-assistant-devicetool <span class="keyword">get</span> <span class="comment">--model my-model</span></span><br></pre></td></tr></table></figure><p>比如下面<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155975614463.jpg" alt=""></p><h2 id="步骤六：运行示例代码"><a href="#步骤六：运行示例代码" class="headerlink" title="步骤六：运行示例代码"></a>步骤六：运行示例代码</h2><p>现在你就可以准备运行示例项目来和你的树莓派对话了，首先运行下面的命令：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">googlesamples</span><span class="literal">-</span><span class="comment">assistant</span><span class="literal">-</span><span class="comment">hotword</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">project_id</span> <span class="comment">你的项目</span> <span class="comment">iD</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">device_model_id</span>  <span class="comment">上一步创建的设备</span></span><br></pre></td></tr></table></figure><p>然后对着你的麦克风可以说话询问了，注意要是英文。激活的关键词是 <code>Ok Google</code> 或 <code>Hey Google</code>，你可以在终端中看到对话开始和结束的提示。</p><p>可以试着问问她你所在的城市的天气，让她唱首歌，让她叫你起床等等。</p><h2 id="步骤七：-其他"><a href="#步骤七：-其他" class="headerlink" title="步骤七： 其他"></a>步骤七： 其他</h2><p> 你还可以增加一个 LED 灯来为你的对话添加一些特性，通过 LED 灯提示对话开始等，也可以扩展这个项目及你的树莓派。具体的可以参考<a href="https://developers.google.com/assistant/sdk/guides/library/python/extend/install-hardware" target="_blank" rel="noopener">扩展 Google Assistant</a>。</p><p>以上就是变身 Google Home 的基本过程，下一步，我将我的树莓派变身成为智能家居中枢，让 Siri 为我开关灯！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;将你的树莓派变身-Google-Home&quot;&gt;&lt;a href=&quot;#将你的树莓派变身-Google-Home&quot; class=&quot;headerlink&quot; title=&quot;将你的树莓派变身 Google Home&quot;&gt;&lt;/a&gt;将你的树莓派变身 Google Home&lt;/h1&gt;&lt;p&gt;目前的智能化已经对人们的生活影响越来越深刻，从智能音箱鼻祖 Amazon Echo 发布之后，智能数字助理就进入了人们的生活当中，也成为人们生活的一部分，特别是其与智能家居配合之后，以前科幻电影中的场景，目前已经渐渐成为现实。&lt;br&gt;
    
    </summary>
    
      <category term="硬件" scheme="http://suool.net/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="树莓派" scheme="http://suool.net/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾指南之使用 SSR 实现科学上网</title>
    <link href="http://suool.net/2018/01/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E4%BD%BF%E7%94%A8-SSR-%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://suool.net/2018/01/09/树莓派折腾指南之使用-SSR-实现科学上网/</id>
    <published>2018-01-09T11:50:57.000Z</published>
    <updated>2018-07-01T14:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="树莓派折腾指南之使用-SSR-实现科学上网"><a href="#树莓派折腾指南之使用-SSR-实现科学上网" class="headerlink" title="树莓派折腾指南之使用 SSR 实现科学上网"></a>树莓派折腾指南之使用 SSR 实现科学上网</h1><p>p## 预备工作<br>首先确定你的 SSR 混淆加密方法，如果是 salsa20 或 chacha20 或 chacha20-ietf 就需要编译安装 libsodium 这个库。<br>其 github 地址是 <a href="https://github.com/jedisct1/libsodium/" target="_blank" rel="noopener">libsodium</a> ，编译安装的步骤如下：</p><a id="more"></a><p>首先安装 build-essential 软件包，其作用是提供编译程序必须软件包的列表信息，也即是，编译程序有了这个软件包它才能确定头文件在哪，才知道库函数在哪，还会下载依赖的软件包，最后才组成一个开发环境。<br>安装命令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><p>安装完成后，就是下载编译 libsodium 库了，首先你要去它的<a href="https://github.com/jedisct1/libsodium/releases" target="_blank" rel="noopener">发布页</a>，确定当前最新的发布版本，替代我下面的当前的 VERSION 。主要命令如下：</p><p>打开终端，首先定义两个变量，在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VERSION='1.0.15'</span><br><span class="line">CPUNUM=`cat /proc/cpuinfo | grep 'processor' | wc -l`</span><br></pre></td></tr></table></figure><p>然后回到当前根目录，下载及解压源码包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget -c "https://github.com/jedisct1/libsodium/releases/download/$&#123;VERSION&#125;/libsodium-$&#123;VERSION&#125;.tar.gz"  # 慢慢等</span><br><span class="line">tar xzf libsodium-$&#123;VERSION&#125;.tar.gz</span><br></pre></td></tr></table></figure><p>目录压栈，并进行编译安装，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushd libsodium-$&#123;VERSION&#125;</span><br><span class="line">./configure</span><br><span class="line">make -j$&#123;CPUNUM&#125;</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>出栈目录，并删除编译目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popd</span><br><span class="line">rm -rf libsodium-$&#123;VERSION&#125;*</span><br></pre></td></tr></table></figure><p>关于 pushd，popd 等目录操作命令，具体可以参见 <a href="http://www.361way.com/pushd/1118.html" target="_blank" rel="noopener">方便的目录切换——dirs、pushd、popd命令</a>。</p><h2 id="编译-SSR-及基本配置"><a href="#编译-SSR-及基本配置" class="headerlink" title="编译 SSR 及基本配置"></a>编译 SSR 及基本配置</h2><p>SSR 当前的 Python 版本的项目地址是 <a href="https://github.com/shadowsocksr-backup/shadowsocksr" target="_blank" rel="noopener">shadowsocksr</a> 。</p><p>首先安装 m2crypto，git，supervisor 等相关依赖软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install m2crypto git supervisor libevent-dev</span><br></pre></td></tr></table></figure><p>下载编译如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone -b manyuser https://github.com/shadowsocksr-backup/shadowsocksr</span><br><span class="line">cd ~/shadowsocksr</span><br><span class="line">bash initcfg.sh</span><br></pre></td></tr></table></figure><p>等待完成之后，编辑配置文件，在命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano user-config.json</span><br></pre></td></tr></table></figure><p>具体参数的意义及作用，参照 <a href="https://github.com/ssrbackup/shadowsocks-rss/wiki/config.json" target="_blank" rel="noopener">config.json</a> 。</p><p>local_address 和 local_port 不需要修改，其余的按照 Wiki 修改，基本上配置好： server 填服务器地址<br>server_port 填服务器端口<br>password 密码<br>method 加密方法<br>obfs 混淆插件<br>protocol 协议插件<br>等关键参数，具体看你的 SSR 服务端的设置。</p><p>编辑好后，运行一下命令测试一下是否能运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shadowsocks/local.py</span><br></pre></td></tr></table></figure><p>没报错的话 Ctrl+C 结束继续下一步，如果有报错继续改配置文件。</p><h2 id="协议转换代理"><a href="#协议转换代理" class="headerlink" title="协议转换代理"></a>协议转换代理</h2><p>因为 SS 系的协议走的是 Socks5 协议，对于 Terminal 的 get,wget 等走 Http 协议的地方是无能为力的，所以需要转换成 Http 代理。<br>此时可以选择使用 <a href="https://github.com/darkk/redsocks" target="_blank" rel="noopener">redsocks</a> 来实现。</p><p>下载编译的命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone https://github.com/darkk/redsocks</span><br><span class="line">pushd redsocks</span><br><span class="line">make</span><br><span class="line">cp redsocks.conf.example redsocks.conf</span><br><span class="line">sed -i "s/ip = example.org/ip = 127.0.0.1/" redsocks.conf</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><h2 id="SSR-开机自启"><a href="#SSR-开机自启" class="headerlink" title="SSR 开机自启"></a>SSR 开机自启</h2><p>首先新建一个用户专门用来运行 SSR 和 redsocks 的账号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -M -s /sbin/nologin ss</span><br></pre></td></tr></table></figure><p>然后使用 supervisor 守护进程和开机自启，直接将下面的命令全部粘贴进入命令行回车即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c "cat &gt; /etc/supervisor/conf.d/ss.conf" &lt;&lt;EOF</span><br><span class="line">[program:ss]</span><br><span class="line">directory = /home/pi/shadowsocksr/shadowsocks</span><br><span class="line">command = python /home/pi/shadowsocksr/shadowsocks/local.py</span><br><span class="line">autostart = true</span><br><span class="line">autorestart = true</span><br><span class="line">startsecs = 10</span><br><span class="line">startretries = 36</span><br><span class="line">user = ss</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile = /dev/null</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo bash -c "cat &gt; /etc/supervisor/conf.d/redsocks.conf" &lt;&lt;EOF</span><br><span class="line">[program:redsocks]</span><br><span class="line">directory = /home/pi/redsocks</span><br><span class="line">command = /home/pi/redsocks/redsocks -c /home/pi/redsocks/redsocks.conf</span><br><span class="line">autostart = true</span><br><span class="line">autorestart = true</span><br><span class="line">startsecs = 10</span><br><span class="line">startretries = 36</span><br><span class="line">user = ss</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile = /dev/null</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo supervisorctl update</span><br></pre></td></tr></table></figure><p>上面的配置把 log 全部扔掉了，如果有需要的可以自己改 stdout_logfile 项。</p><h2 id="设置-iptables-实现-nat-转发"><a href="#设置-iptables-实现-nat-转发" class="headerlink" title="设置 iptables 实现 nat 转发"></a>设置 iptables 实现 nat 转发</h2><p>主要步骤如下，<br>首先创建一个叫 REDSOCKS 的链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -N REDSOCKS</span><br></pre></td></tr></table></figure><p>然后进行基本的规则定制，首先忽略服务器的地址，下面的 server_ip 填服务器 ip 或域名，这里和 SSR 配置文件里的 server 值要一样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A REDSOCKS -d server_ip -j RETURN</span><br></pre></td></tr></table></figure><p>然后忽略本地地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN</span><br></pre></td></tr></table></figure><p>除了除上面之外的所有流量都转发到 socks 的本地端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345</span><br></pre></td></tr></table></figure><p>之后应用上面的规则,将 OUTPUT 出去的 tcp 流量全部经过 REDSOCKS 链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A OUTPUT -p tcp -j REDSOCKS</span><br></pre></td></tr></table></figure><p>保存规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c "iptables-save &gt; /etc/iptables.up.rules"</span><br></pre></td></tr></table></figure><h2 id="开机自动加载规则"><a href="#开机自动加载规则" class="headerlink" title="开机自动加载规则"></a>开机自动加载规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c "cat &gt; /etc/network/if-pre-up.d/iptables" &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">/sbin/iptables-restore &lt; /etc/iptables.up.rules</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>添加执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/network/if-pre-up.d/iptables</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl myip.ipip.net</span><br></pre></td></tr></table></figure><p>可以查看当前的ip，如果是你的服务器 IP 就表示可以了。<br>比如：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15154976353553.jpg" alt=""></p><h2 id="关闭全局代理"><a href="#关闭全局代理" class="headerlink" title="关闭全局代理"></a>关闭全局代理</h2><p>执行下面的命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的server_ip填服务器ip或域名，和上面添加的值要一样</span></span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d server_ip -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 0.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 10.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 127.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 169.254.0.0/16 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 172.16.0.0/12 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 192.168.0.0/16 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 224.0.0.0/4 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 240.0.0.0/4 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -p tcp -j REDIRECT --to-ports 12345</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D OUTPUT -p tcp -j REDSOCKS</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>更多关 iptables 的学习可以去 <a href="https://lesca.me/archives/iptables-nat-mangle-clear-rules.html" target="_blank" rel="noopener">iptables应用：NAT、数据报处理、清空iptables规则</a></p><h1 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h1><ol><li>实现了科学上网之后，下一步就可以 Google Assistant 的安装和试用，把你的树莓派变身成为一个 Google Home</li><li>接入 HomeKit，连入小米家具全家桶，让树莓派变身成为你的智能家居中枢。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树莓派折腾指南之使用-SSR-实现科学上网&quot;&gt;&lt;a href=&quot;#树莓派折腾指南之使用-SSR-实现科学上网&quot; class=&quot;headerlink&quot; title=&quot;树莓派折腾指南之使用 SSR 实现科学上网&quot;&gt;&lt;/a&gt;树莓派折腾指南之使用 SSR 实现科学上网&lt;/h1&gt;&lt;p&gt;p## 预备工作&lt;br&gt;首先确定你的 SSR 混淆加密方法，如果是 salsa20 或 chacha20 或 chacha20-ietf 就需要编译安装 libsodium 这个库。&lt;br&gt;其 github 地址是 &lt;a href=&quot;https://github.com/jedisct1/libsodium/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libsodium&lt;/a&gt; ，编译安装的步骤如下：&lt;/p&gt;
    
    </summary>
    
      <category term="硬件" scheme="http://suool.net/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="树莓派" scheme="http://suool.net/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾指南之系统安装及设备点亮</title>
    <link href="http://suool.net/2018/01/07/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E5%A4%87%E7%82%B9%E4%BA%AE/"/>
    <id>http://suool.net/2018/01/07/树莓派折腾指南之系统安装及设备点亮/</id>
    <published>2018-01-07T14:48:11.000Z</published>
    <updated>2018-07-01T14:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="树莓派折腾指南之系统安装及设备点亮"><a href="#树莓派折腾指南之系统安装及设备点亮" class="headerlink" title="树莓派折腾指南之系统安装及设备点亮"></a>树莓派折腾指南之系统安装及设备点亮</h1><p>树莓派的系统安装方法有两种，一种是完全无头安装即不用网线，不用连接屏幕完成系统安装及设备正常点亮；一种是官方所提供的方式使用<code>NOOBS</code>辅助来安装。</p><p>在我看来，直接无头安装是最快捷的，不需要额外的设备，不需要额外的系统，不需要那么多操作，也减少了出错的可能。所以，这里推荐大家直接使用屋无头安装的方式。<br><a id="more"></a></p><h2 id="无头安装速成指南"><a href="#无头安装速成指南" class="headerlink" title="无头安装速成指南"></a>无头安装速成指南</h2><p>所谓速成，是因为在30分钟以内你就能进入到自己的树莓派中一探其中的究竟了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>所需设备及材料：</p><ol><li>树莓派</li><li>SD 卡（起码 8G 以上）</li></ol><p>当然还有计算机，以及一台正常工作的路由器。</p><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>首先在你的计算机上前往官网选择需要下载的树莓派官方支持系统：<code>RASPBIAN</code> （当然还有一系列其他类型的系统也可在官网找到）。</p><p>官方系统的下载地址是 <a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="noopener">RASPBIAN</a> ,官方提供两种系统版本，一是 WITH DESKTOP 即配置了桌面 GUI 环境的操作系统，另一个是 LITE 版本无桌面的最小版本。</p><p>目前的系统版本及相关内容如下：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153326797958.jpg" alt=""></p><p>这里可以根据你的需要选择，如果是新手，推荐选择桌面版本。</p><p>下载好系统包之后，下一步就是将系统烧录进入 SD 卡内，可以选择使用官方推荐的系统烧录工具 <a href="https://etcher.io/" target="_blank" rel="noopener">Etcher</a> ，点击上链接进入官网下载对应系统的版本即可，我这里使用的是 Mac 所以下载的 macOS 版本，下载完成之后安装并启动 Etcher。</p><p>Etcher 的使用基本是傻瓜式的，如其在官网的动图所示，首先选择你刚刚下载的系统包，然后将你 SD 卡插入 USB 读卡器中，并将读卡器接入电脑，点击 <code>Select drive</code> 选择你插入的 USB 设备，点击 <code>Flash</code> 即进入烧录系统的过程了。<br>这个过程快慢取决于烧录速度，静静等待它烧录完成就行了。</p><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153330485682.jpg" alt=""></p><p>烧录完成之后，仅仅是完成了系统安装的第一步。</p><h2 id="启动系统前的基本配置"><a href="#启动系统前的基本配置" class="headerlink" title="启动系统前的基本配置"></a>启动系统前的基本配置</h2><p>在烧录完成之后，需要重新挂载刚刚携带 SD 卡的 USB 设备，打开其中的 <code>boot</code> 分区（文件夹），做以下三步操作</p><ol><li>打开 <code>boot</code> 文件夹内 <code>config.txt</code>  文件，如果是桌面版本需要将 <code>#hdmi_safe=1</code> 取消注释，即去掉前面的 <code>#</code></li><li>在 <code>config.txt</code> 同级目录下使用任一文本编辑器(UTF-8编码）新建一个名字是 <code>ssh</code> 的空白文件，无文件后缀名</li><li>在 <code>config.txt</code> 同级目录下新建一个名为 <code>wpa_supplicant.conf</code> 的文件，内容如下：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">country</span>=GB</span><br><span class="line"><span class="attribute">ctrl_interface</span>=DIR=/var/run/wpa_supplicant <span class="attribute">GROUP</span>=netdev</span><br><span class="line"><span class="attribute">update_config</span>=1</span><br><span class="line">network=&#123;</span><br><span class="line">    <span class="attribute">ssid</span>=<span class="string">"你的Wifi名称，最好不含中文"</span></span><br><span class="line">    <span class="attribute">psk</span>=<span class="string">"你的Wifi密码"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三步缺一不可。第一步是为了保证以后使用 HDMI 接入屏幕的时候有视频信号，第二步是为了能够使用 <code>ssh</code> 登录你的树莓派，第三步则保证你的树莓派一开机能够自动连接上你的路由器。</p><p>现在就完成了系统安装，选择弹出你的 sd 卡设备，将其插入到树莓派中。</p><p>系统启动后，上述刚刚新建的这两个文件都会被删除。如果你改了 Wifi 密码，还可以再做一次。</p><h2 id="启动树莓派并SSH远程登录系统"><a href="#启动树莓派并SSH远程登录系统" class="headerlink" title="启动树莓派并SSH远程登录系统"></a>启动树莓派并SSH远程登录系统</h2><p>将 SD 卡插入到树莓派后，将树莓派接通电源等待它自动开机，这里你可以使用 HDMI 线连接显示器以查看其启动结果，当然如果你有自信可以完全不用连接上显示器，直接使用 <code>ssh</code> 登录到树莓派内。</p><p>那么如何确定树莓派是否连接上了路由器呢？可以根据其是否在路由器内分配了 IP 地址来确定，这里有两种方法：</p><ol><li>直接进入到路由器的管理中心，比如使用浏览器打开 <code>http://192.168.1.1</code> ，查看已连接的设备中是否有一个名为 <code>raspberrypi</code> 的设备，查看其分配的路由器 IP 地址<br>如下图：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153343484307.jpg" alt=""></li><li>如果你的计算机是 <code>*nix</code> 设备，在终端使用 <code>arp -a</code>  命令，查看当前的路由中所有已连接的 IP 地址<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153344267473.jpg" alt=""></li></ol><p>找到了 IP 地址之后就可以使用 ssh 登陆到树莓派了，在 Mac 中使用终端即可，其步骤如下图<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153347383609.jpg" alt=""><br>注意用户名是 <code>pi</code>，点击连接即可，这里可能需要你添加 key 到本地 <code>know_host</code><br>中，输入 <code>yes</code> 即可。Windows 可以使用 <code>putty</code>，具体的操作这里不再赘述。</p><p><strong>默认的 <code>pi</code> 用户的密码是 <code>raspberry</code>。</strong></p><p>当然对于 macOS 或 linux 还有一种更加直接方便的 <code>ssh</code> 登陆方式，不需要 IP 地址，直接等树莓派通电启动之后，在终端内输入 <code>ssh pi@raspberrypi.local</code> 即可。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153349649992.jpg" alt=""></p><p>如果出现上界面即表示树莓派已经成功启动系统了。</p><h2 id="使用-VNC-远程登录"><a href="#使用-VNC-远程登录" class="headerlink" title="使用 VNC 远程登录"></a>使用 VNC 远程登录</h2><p>如果你安装的是带桌面版本的树莓派，可以使用 VNC 远程登录桌面环境而不必需要额外的 HDMI 设备线连接屏幕、额外的键鼠连接树莓派。</p><p>如何使用 VNC 呢？</p><p>首先在 ssh 登陆进入树莓派之后，先对系统进行基本的配置，第一个就是换源，因为国内网络环境导致从官方的地址来安装和更新软件及系统速度可能会非常慢，这里讲软件源换成国内的镜像源，比如阿里云的，其步骤如下：</p><p>在 ssh 终端中输入 <code>sudo nano /etc/apt/sources.list</code><br>可以直接删除原有的内容，也可以在前面加上 # 将其注释掉，然后在下面加入两行。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb <span class="symbol">http:</span>/<span class="regexp">/mirrors.aliyun.com/raspbian</span><span class="regexp">/raspbian/</span> stretch main non-free contrib rpi</span><br><span class="line">deb-src <span class="symbol">http:</span>/<span class="regexp">/mirrors.aliyun.com/raspbian</span><span class="regexp">/raspbian/</span> stretch main non-free contrib rpi</span><br></pre></td></tr></table></figure></p><p>然后输入 <code>sudo apt-get update</code> 更新软件索引清单，<br>输入 <code>sudo apt-get upgrade</code> 更新相关软件依赖。</p><p>完成之后输入 <code>sudo apt-get install tightvncserver</code> 为树莓派安装 VNC 服务，安装完成之后输入 <code>tightvncserver</code>，这里会需要你输入 VNC 连接密码，确定输入即可，启动 VNC 服务。</p><p>Mac 中，在文件夹 <code>Finder</code> 的菜单中，打开前往下的连接服务器，然后输入 <code>vnc://树莓派IP地址:5901</code> ,其中5901是默认的端口。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153356804072.jpg" alt=""><br>点击连接，输入你刚刚确定的密码，即可完成连接，看到你的树莓派桌面环境。</p><p>好了，这就是系统安装的基本过程，下一步是更深入的折腾的过程。</p><ol><li>使用 <code>SSR</code> 全局代理，让树莓派自由访问网络。</li><li>使用树莓派接入 <code>Google Assistant</code>，实现一个树莓派版的 <code>Google Home</code>。</li><li>使用树莓派接入有线音箱，将其变成无线音箱。</li><li>将树莓派安装 <code>Homebridge</code>，使你的 iPhone 连接你的智能设备。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树莓派折腾指南之系统安装及设备点亮&quot;&gt;&lt;a href=&quot;#树莓派折腾指南之系统安装及设备点亮&quot; class=&quot;headerlink&quot; title=&quot;树莓派折腾指南之系统安装及设备点亮&quot;&gt;&lt;/a&gt;树莓派折腾指南之系统安装及设备点亮&lt;/h1&gt;&lt;p&gt;树莓派的系统安装方法有两种，一种是完全无头安装即不用网线，不用连接屏幕完成系统安装及设备正常点亮；一种是官方所提供的方式使用&lt;code&gt;NOOBS&lt;/code&gt;辅助来安装。&lt;/p&gt;
&lt;p&gt;在我看来，直接无头安装是最快捷的，不需要额外的设备，不需要额外的系统，不需要那么多操作，也减少了出错的可能。所以，这里推荐大家直接使用屋无头安装的方式。&lt;br&gt;
    
    </summary>
    
      <category term="硬件" scheme="http://suool.net/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="树莓派" scheme="http://suool.net/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>云南五天四晚游</title>
    <link href="http://suool.net/2016/12/28/%E4%BA%91%E5%8D%97%E4%BA%94%E5%A4%A9%E5%9B%9B%E6%99%9A%E6%B8%B8/"/>
    <id>http://suool.net/2016/12/28/云南五天四晚游/</id>
    <published>2016-12-28T06:22:41.000Z</published>
    <updated>2018-07-01T14:10:09.701Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="一些基本原则："><a href="#一些基本原则：" class="headerlink" title="一些基本原则："></a>一些基本原则：</h2><ol><li><em>一定要防晒，不要问我为什么。</em></li><li><em>不推荐在古城买东西，不管是丽江古城，还是束河古镇，还是大理古城，里面东西不保证真假，而且价格虚高。</em></li><li><em>需要买东西可以直接去当地的超市或者批发市场，买东西都要杀价，觉得贵的直接对半砍价。</em></li><li><em>当地的昼夜温差很大，白天可以穿少点，晚上回来晚的话一定要带多点衣服，不然要冻成狗。</em></li><li><em>出行可以选择滴滴打车</em></li></ol><a id="more"></a><h2 id="液体随身-乘机"><a href="#液体随身-乘机" class="headerlink" title="液体随身(乘机)"></a>液体随身(乘机)</h2><ol><li>爽肤水 </li><li>防晒霜 </li><li>柔肤水 </li><li>护手霜 </li><li>隔离霜 </li><li>遮瑕霜 </li><li>洗面奶 </li><li>面霜 </li><li>洗头水 </li><li>沐浴露</li><li>精华液</li><li>身体乳</li><li>卸妆水</li></ol><p>PS： 坐飞机的话，注意每种不能带超过一百毫升，最好买分装瓶，我们买的是四合一那种的，买四个（16小瓶）就足够了，以后还能循环利用，并且这个要放在外面，乘飞机的时候拿出来安检。</p><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p>初步规划7号下午下班后出发去广州, 在广州机场附近休息一下, 在12号凌晨4:00左右赶往机场候机.<br>计划于12号从丽江机场返回广州.</p><p>中间的行程：</p><ul><li><em>8号安排</em></li></ul><p><code>早上9:30</code>飞机抵达到达丽江，预估10:30到达古城，去宾馆休息整顿之后。<br>下午和晚上可以逛一下古城及周边地区。<br>晚上<code>住在丽江</code></p><p>PS：束河古镇，从北门进入不需要门票</p><p>PPS： 丽江古城，晚上去比较好，而且晚上七点之后去不再需要门票。</p><hr><ul><li><em>9号安排</em></li></ul><p><code>早上9点</code>出发去玉龙雪山<code>(一小时车程)</code><br><code>上午10点到下午4点</code>游玩玉龙雪山。<br><code>下午5点</code>回程丽江。<br><code>晚上7点</code>出发去丽江火车站<br><code>晚上8点</code>坐火车出发去大理<code>(两个小时车程)</code><br><code>晚上10点</code>到大理<br>晚上<code>住在大理</code></p><p>PS：强烈推荐直接<em>报纯玩的一日团</em>（我们包的一个人580，相对于自己组织和购买门票等费用没差多少），包车来回，提供羽绒服和氧气，中午还有顿本地农家饭，我们体验的感觉很不错。不建议自己坐大巴或者其他包车方式。</p><p>PPS：关于登玉龙雪山</p><ol><li><em>氧气：</em>上雪山一定要备好氧气，学会如何使用氧气，有高原反应不能硬撑的，最好出发前几日就吃红景天，出发前一晚一定要休息好。</li><li><em>药物：</em>最好备用感冒药、头痛药、止吐药如维生素B6，不然到时一旦高原反应，又吐有头痛，没有药会很难受。</li><li><em>食物：</em>最好带点高热量的食物，比如巧克力，带点热水。</li><li><em>莫急：</em>登山的时候千万不能过赶，高原氧气本来就稀薄，一旦运动过赶，会严重的缺氧头晕。</li></ol><hr><ul><li><em>10号安排</em></li></ul><p>10号一天在洱海游玩（洱海周边）<br>晚上<code>住在大理</code></p><p>PS：推荐租小电驴，一天60块钱，可以骑车绕着环海西线或者东线转，去喜洲和海舌公园看日落与洱海的黄昏，非常值得一看。但是记得穿多点衣服，晚上的洱海旁边会非常非常非常的冷，海风也非常非常非常的大。如果条件允许，直接租一个小电车也是很不错的选择，不过预算可能需要多一点。</p><p>PPS：推荐住洱海边的民宿，大理古城附近的青旅和客栈都是酒店那个样子，不如直接去 Airbnb 上找靠海边的民宿是最好的，一晚上100块左右。民宿非常有当地特色而且安静。</p><hr><ul><li><em>11号安排</em></li></ul><p>离开洱海。<br>第一个推荐去的地方是<code>崇圣寺</code>，电视剧中经常出现的<code>大理国</code>很多镜头都是在这里，<code>三塔映月</code>及最大的佛教寺庙——<em>佛都</em>。<br>门票可以自己美团上定优惠票一个人88，官方价要121。<br>其次古城可以晚上去看，主要是买买买了。</p><p>晚上<code>住在大理古城附近</code></p><hr><ul><li><em>12号安排</em></li></ul><p><code>早上9:00</code>坐火车出发去丽江<code>(三个小时车程)</code><br><code>下午1:00</code>拉市海游玩<br><code>晚上9:00</code>到机场候机<br><code>晚上11:10</code>飞机回广州</p><p>PS：游玩拉市海可以直接报团，也可以自己找个车来回，自己去的时候选线路之后记得砍价，而且冬季的话，玩那个线路都没什么差别…山上差不多都没什么东西，就骑马转一圈。砍价的空间非常的大….</p><p>PPS：买拉市海的票记得要求他包括划船的费用，去拉市海划船，看海鸟很不错。</p><p>PPPS: 可以试一下那边的高山茶，很不错，买的时候也要杀价。对半砍都可以。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些基本原则：&quot;&gt;&lt;a href=&quot;#一些基本原则：&quot; class=&quot;headerlink&quot; title=&quot;一些基本原则：&quot;&gt;&lt;/a&gt;一些基本原则：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;em&gt;一定要防晒，不要问我为什么。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;不推荐在古城买东西，不管是丽江古城，还是束河古镇，还是大理古城，里面东西不保证真假，而且价格虚高。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;需要买东西可以直接去当地的超市或者批发市场，买东西都要杀价，觉得贵的直接对半砍价。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;当地的昼夜温差很大，白天可以穿少点，晚上回来晚的话一定要带多点衣服，不然要冻成狗。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;出行可以选择滴滴打车&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 引导图组件使用文档</title>
    <link href="http://suool.net/2016/12/05/iOS-%E5%BC%95%E5%AF%BC%E5%9B%BE%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>http://suool.net/2016/12/05/iOS-引导图组件使用文档/</id>
    <published>2016-12-05T02:48:04.000Z</published>
    <updated>2018-07-01T14:10:09.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="iOS-引导图组件使用文档"><a href="#iOS-引导图组件使用文档" class="headerlink" title="iOS 引导图组件使用文档"></a>iOS 引导图组件使用文档</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h3><ul><li>引导图实际显示效果截图如下:<a id="more"></a></li></ul><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/2016120576244Simulator Screen Shot Dec 5, 2016, 9.43.40 AM.png" alt="引导图示例.png"></p><ul><li>引导图的动态显示效果如下视频：<br><a href="https://appetize.io/embed/29xabc89e2u0j8uh3y0dkkk0yg?device=iphone5s&amp;scale=75&amp;orientation=portrait&amp;osVersion=9.3" target="_blank" rel="noopener">引导图 Live Video</a></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当 APP 第一次安装启动或者大版本更新第一次启动的时候，运营有新的引导图介绍 APP 的重点功能或更新的，需要使用引导图完成。</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>本引导图组件基于 <a href="https://github.com/squarezw/ZWIntroductionViewController" target="_blank" rel="noopener">ZWIntroductionViewController</a>修改。</p><p>只要设置引导图组件的 cover images ，初始化后将其加入到APPDelegate 的window即可， 对 APP 侵入性小，使用灵活。</p><h2 id="使用文档"><a href="#使用文档" class="headerlink" title="使用文档"></a>使用文档</h2><ul><li>首先是滑动的需求：<br>在组件的<code>ZWIntroductionViewController</code>类中的<code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</code>方法中几行关键代码：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当滑动到最后一个的时候,禁止左滑动,只能通过点击按钮来去除引导图</span></span><br><span class="line"><span class="built_in">CGFloat</span> x = (_pageControl.numberOfPages<span class="number">-1</span>) * YYScreenSize().width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (scrollView.contentOffset.x&gt;x) &#123;</span><br><span class="line">    [scrollView setContentOffset:<span class="built_in">CGPointMake</span>(x, scrollView.contentOffset.y) animated:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个的时候不能右滑动</span></span><br><span class="line"><span class="keyword">if</span> (scrollView.contentOffset.x&lt;=<span class="number">0.0</span>) &#123;</span><br><span class="line">    [scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0.0</span>, scrollView.contentOffset.y) animated:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码是控制在引导图第一页的时候不能向右滑动，在最后一页的时候不能通过继续左滑结束引导，只能通过点击按钮进入 APP 中。<br>（如果没有以上需求，将代码注释即可。）</p><ul><li>其次是指示器颜色和进入按钮的需求：<br>如果对于<code>pageControl</code>的指示器颜色有特殊的需求，比如需要指示器的颜色及进入 APP 的按钮样式，需要修改<code>ZWIntroductionViewController</code>类中的<code>- (void)viewDidLoad</code>方法，指示器颜色修改具体的代码如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.pageControl.pageIndicatorTintColor = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line"><span class="keyword">self</span>.pageControl.currentPageIndicatorTintColor = GlobalColor;</span><br></pre></td></tr></table></figure><p>按钮相关的修改如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.enterButton setTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"立即体验"</span>, <span class="literal">nil</span>) forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[<span class="keyword">self</span>.enterButton setTitleColor:GlobalColor forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">self</span>.enterButton.layer.borderWidth = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">self</span>.enterButton.layer.cornerRadius = <span class="number">20.0</span>;</span><br><span class="line"><span class="keyword">self</span>.enterButton.layer.borderColor = GlobalColor.CGColor;</span><br></pre></td></tr></table></figure><ul><li>最后是使用的规范：<br>下面是一个使用示例：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)isFirstLaunch&#123;</span><br><span class="line">    <span class="keyword">if</span>(![[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@"firstStart_V2"</span>])&#123;</span><br><span class="line">  <span class="comment">// 如果是第一次启动，设置对应的版本标示</span></span><br><span class="line">        [[LSUserDefaults sharedInstance]setNewVeisonCode:<span class="string">@"1"</span>];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:<span class="literal">YES</span> forKey:<span class="string">@"firstStart_V2"</span>];</span><br><span class="line">  <span class="comment">// 设置引导图的图片</span></span><br><span class="line">        <span class="built_in">NSArray</span> *coverImageNames = @[<span class="string">@"leadPage_1"</span>, <span class="string">@"leadPage_2"</span>, <span class="string">@"leadPage_3"</span>,<span class="string">@"leadPage_4"</span>];</span><br><span class="line">  <span class="comment">// 初始化引导图组件</span></span><br><span class="line">        <span class="keyword">self</span>.introductionView = [[ZWIntroductionViewController alloc] initWithCoverImageNames:coverImageNames backgroundImageNames:<span class="literal">nil</span>];</span><br><span class="line">  <span class="comment">// 添加组件</span></span><br><span class="line">        [<span class="keyword">self</span>.window addSubview:<span class="keyword">self</span>.introductionView.view];</span><br><span class="line">        __<span class="keyword">weak</span> AppDelegate *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">  <span class="comment">// 引导完成后的回调</span></span><br><span class="line">        <span class="keyword">self</span>.introductionView.didSelectedEnter = ^() &#123;</span><br><span class="line">            [weakSelf.introductionView.view removeFromSuperview];</span><br><span class="line">            weakSelf.introductionView = <span class="literal">nil</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个使用的过程如上代码所示。</p><p><em>以上就是引导图组件的文档说明</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-引导图组件使用文档&quot;&gt;&lt;a href=&quot;#iOS-引导图组件使用文档&quot; class=&quot;headerlink&quot; title=&quot;iOS 引导图组件使用文档&quot;&gt;&lt;/a&gt;iOS 引导图组件使用文档&lt;/h1&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;h3 id=&quot;实际效果&quot;&gt;&lt;a href=&quot;#实际效果&quot; class=&quot;headerlink&quot; title=&quot;实际效果&quot;&gt;&lt;/a&gt;实际效果&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;引导图实际显示效果截图如下:
    
    </summary>
    
      <category term="技术" scheme="http://suool.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://suool.net/tags/iOS/"/>
    
      <category term="组件文档" scheme="http://suool.net/tags/%E7%BB%84%E4%BB%B6%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>iOS网络层说明</title>
    <link href="http://suool.net/2016/11/30/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%B4%E6%98%8E/"/>
    <id>http://suool.net/2016/11/30/iOS网络层说明/</id>
    <published>2016-11-30T08:44:02.000Z</published>
    <updated>2018-07-01T14:10:09.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="iOS-网络层文档"><a href="#iOS-网络层文档" class="headerlink" title="iOS 网络层文档"></a>iOS 网络层文档</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>iOS 的网络层使用 <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a>作为网络层底层架构，在  <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a>的<code>YTKRequest</code>类和具体的业务请求层之间架设了一个中间业务类<code>LSBaseRequest</code>，所有具体的 API 请求都继承于此类。<br> <a id="more"></a></p><p>关于 <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a> </p><blockquote><p>YTKNetwork主要用于请求的发送及回调处理，YTKNetwork 的基本的思想是把每一个网络请求封装成对象。使用 YTKNetwork，每一个请求都需要继承 YTKRequest 类，通过覆盖父类的一些方法来构造指定的网络请求。</p></blockquote><p>这里为了避免我们具体业务类的相关回调逻辑与 YTKNetwork 耦合过高，所以封装了<code>LSBaseRequest</code>来处理请求回调的公共逻辑。</p><p>下面来一一说明。</p><h2 id="LSBaseRequest-类的设计"><a href="#LSBaseRequest-类的设计" class="headerlink" title="LSBaseRequest 类的设计"></a>LSBaseRequest 类的设计</h2><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/2016113096998iOS Network.png" alt="iOS Network.png"></p><p>继承关系及中间层的 <code>BaseRequest</code>  的设计如上图所示。</p><h3 id="基本的原理和字段说明："><a href="#基本的原理和字段说明：" class="headerlink" title="基本的原理和字段说明："></a>基本的原理和字段说明：</h3><p>首先一个请求的回调都是直接一个 JSON 的字符串，网络层的底层可以将这个字符串转化为<code>NSDictionary</code>类型的数据，这个是请求回调的第一次处理得到的数据。处理的具体过程如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处是在网络请求完成的回调方法内拿到responseString的回调字符串的处理</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="keyword">self</span>.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  DDLogError(<span class="string">@"返回内容为空."</span>);</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果 API 的请求没有特殊的要求，可能直接拿到这个 <code>data</code>数据来提供给 ViewController 使用。</p><p>但是，一般的请求并不会简单的直接要求<code>NSMutableDictionary</code>的 <code>data</code>数据，ViewController 希望能够直接拿到其需要的数据类型。而展示数据一般也只需要两种类型，分别是展示一个列表数据和展示一个实体模型的数据。所以业务请求 API 能够自己处理回调数据的“深加工”是View 和 ViewController希望看到的。因此，这里直接给 <code>BaseRequest</code>添加了两个属性，分别是泛型的回调列表数据和泛型的实体模型数据，而<code>NSDictionary</code>类型的<code>resultDic</code>属性是第一次处理的结果。</p><p>根据以上的需求，具体的业务请求的 API 都会具有三种附加的状态属性，分别是该请求是否需要登录，该请求是否需要一个列表的回调数据，该请求是否需要一个实体模型的回调数据。在初始化具体的 API 请求的时候就会对这三个属性进行初始化。</p><p>具体的对应数属性是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isLogin;  <span class="comment">// 是否需登录</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isRetAry; <span class="comment">// 是否需要返回数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isRetObj; <span class="comment">// 是否需要返回实体 model</span></span><br></pre></td></tr></table></figure><p>所以<code>BaseRequest</code>的对外暴露的方法也只有三个，此处甚至可以减少到两个，即是所有的 API 请求自己处理自己的初始化，而不是像上面的使用中间类的初始化方法。</p><p>而 API 的初始化方法中，需要传入该 API 请求需要的参数及其相关的状态属性。请求参数会根据请求的登录状态属性来决定是否添加<code>AccessToken 参数</code>。</p><p>在具体的发送 API 请求的时候，会根据以上三个状态属性来确定如何发送请求，具体的处理逻辑如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startRequest&#123;</span><br><span class="line">    sendCount ++; <span class="comment">// 请求重发的次数</span></span><br><span class="line">    <span class="built_in">BOOL</span> isOnline = [[LSUserDefaults sharedInstance] isOnLine];</span><br><span class="line">    <span class="keyword">if</span> (_isLogin &amp;&amp; isOnline) &#123;  <span class="comment">// 需要登录且目前用户已经登录</span></span><br><span class="line">        [<span class="keyword">self</span> start];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(_isLogin &amp;&amp; !isOnline) &#123; <span class="comment">// 需要登录但目前用户并没有登录</span></span><br><span class="line">        <span class="keyword">self</span>.failure(@&#123;<span class="string">@"code"</span> : NoLogin&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!_isLogin) &#123;         <span class="comment">// 不需要登录，直接登录</span></span><br><span class="line">        [<span class="keyword">self</span> start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求完成之后的公共逻辑处理在<code>requestCompleteFilter</code>和<code>requestFailedFilter</code>回调方法中实现，这两个回调方法是 YTKNetwork 中暴露出来给请求结果回调处理使用的。</p><p>而一旦请求发送成功，获得回调数据之后，回调数据统一处理逻辑会根据 API 初始化携带的状态来加工回调数据，具体如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestCompleteFilter&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span>.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">  <span class="comment">// 初次加工数据</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSEnumerator</span> *enumerator = [dictionary keyEnumerator];</span><br><span class="line">        <span class="built_in">NSString</span> *key = <span class="string">@"code"</span>;</span><br><span class="line">        <span class="keyword">int</span> code = [dictionary[key] intValue];</span><br><span class="line">        <span class="built_in">BOOL</span> isExist = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">while</span> ((key = [enumerator nextObject])) &#123;</span><br><span class="line">            isExist = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">                    <span class="keyword">if</span> (_isRetAry) &#123; <span class="comment">// 如果要求返回的是数组，则在具体的 API 中再次深加工数据，并将加工之后的数据回调</span></span><br><span class="line">                        <span class="keyword">self</span>.successArray(<span class="keyword">self</span>.resultData);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_isRetObj) <span class="comment">// 如果要求返回的是实体，则在具体的 API 中再次深加工数据，并将加工之后的数据回调</span></span><br><span class="line">                        <span class="keyword">self</span>.successObject(<span class="keyword">self</span>.model);</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// 如果要求返回没有额外的要求，则在数据回调中直接将初加工数据回调</span></span><br><span class="line">                        <span class="keyword">self</span>.success(dictionary);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 请求成功但是获取的不是预期的成功数据</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">801</span>:&#123;</span><br><span class="line">                    <span class="comment">// 访问令牌失效，重新获取</span></span><br><span class="line">                    [<span class="keyword">self</span> requestTokenWithRetArray:_isRetAry retObj:_isRetObj];</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">802</span>:</span><br><span class="line">                    [[PMStore store] removeUserDataAndLogOff];</span><br><span class="line">                    <span class="keyword">self</span>.failure(dictionary);</span><br><span class="line">  <span class="comment">// 其他情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"服务暂时不可用，请稍后重试"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// 请求成功但是没有获取到数据</span></span><br><span class="line">        DDLogWarn(<span class="string">@"self.success(nil)"</span>);</span><br><span class="line">        <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"服务暂时不可用，请稍后重试"</span>&#125;);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的深加工过程，在具体的 API 类中再做介绍。</p><p>请求发送失败的公共处理逻辑：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestFailedFilter &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span>.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">self</span>.failure(dictionary);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        DDLogError(<span class="string">@"返回内容为空."</span>);</span><br><span class="line">        <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"服务暂时不可用，请稍后重试"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处在请求成功发送并获取回调之后，会出现一种特殊的情况（上面 Code 为801 的情况）：如果该请求需要登录状态，即是会携带<code>AccessToken</code>来发送请求，但是请求的结果是服务端提示<code>AccessToken</code>过期，此时不能立即回调该结果给 API 的调用者，而是要发送一个<code>LSServerTokenAPI</code>请求来尝试跟服务端请求换取新的<code>AccessToken</code>，如果服务端成功的返回了新的<code>AccessToken</code>，则应该让该请求重新携带新的<code>AccessToken</code>重发请求数据。如果没有获取到新的<code>AccessToken</code>，则此时应该失败回调给调用者，告诉调用者该用户已经掉线，需要重新登录才能继续请求。<br>此处的具体处理逻辑代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestTokenWithRetArray:(<span class="built_in">BOOL</span>)isAry retObj:(<span class="built_in">BOOL</span>)isObj&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *requrestDic = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:<span class="keyword">self</span>.requestArgument];</span><br><span class="line">    <span class="comment">// accessToken 过期</span></span><br><span class="line">    LSServerTokenAPI *accessAPI = [[LSServerTokenAPI alloc]init];</span><br><span class="line">    [accessAPI startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123;   <span class="comment">// 此处是直接使用的 YTKRequest 的回调方法</span></span><br><span class="line">        <span class="comment">// you can use self here, retain cycle won't happen</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</span><br><span class="line">        <span class="built_in">NSData</span> *data = [request.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dic = (<span class="built_in">NSDictionary</span> *)dictionary[<span class="string">@"data"</span>][<span class="string">@"result"</span>];</span><br><span class="line">        HNUserModel *user = [HNUserModel mj_objectWithKeyValues:dic];</span><br><span class="line">        <span class="keyword">if</span> (user.accessToken) &#123;   <span class="comment">// 如果换取到新的 Token</span></span><br><span class="line">            [[PMStore store]saveDataWithUserInfo:user];</span><br><span class="line">            requrestDic[<span class="string">@"accessToken"</span>] = user.accessToken;</span><br><span class="line">            <span class="keyword">self</span>.baseRequestArgument = requrestDic;</span><br><span class="line">            <span class="keyword">if</span> (sendCount &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"重发系统错误，请稍后重试"</span>&#125;);  <span class="comment">// 重发最多三次，多余三次的直接回调失败</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               [<span class="keyword">self</span> startRequest];  <span class="comment">// 重发该请求</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            [[PMStore store] removeUserDataAndLogOff];</span><br><span class="line">            <span class="keyword">self</span>.failure(@&#123;<span class="string">@"code"</span> : NoLogin&#125;);  <span class="comment">// 没有获取到新的 Token，回调数据登录失效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(YTKBaseRequest *request) &#123;</span><br><span class="line">        <span class="comment">// you can use self here, retain cycle won't happen</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</span><br><span class="line">        <span class="built_in">NSData</span> *data = [request.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">            DDLogError(<span class="string">@"发送请求更新 accessToken 失败，返回内容：\n%@"</span>,dictionary);</span><br><span class="line">            <span class="keyword">self</span>.failure(dictionary);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"刷新 Token 系统错误，请稍后重试"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是为了避免无限的循环调用，<code>LSServerTokenAPI</code>本身不是<code>LSBaseRequest</code>类型的，而是和<code>LSBaseRequest</code>一样都是直接继承自<code>YTKRequest</code>的，因此此处的<code>LSServerTokenAPI</code>请求的回调不会再次经过<code>LSBaseRequest</code> 在<code>requestCompleteFilter</code>和<code>requestFailedFilter</code>回调方法中的公共逻辑，而是直接调用的<code>startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success failure:(YTKRequestCompletionBlock)failure</code>方法处理数据回调数据。</p><h2 id="operationAPI-类的设计"><a href="#operationAPI-类的设计" class="headerlink" title="operationAPI 类的设计"></a>operationAPI 类的设计</h2><p>具体的业务类非常的简单，因此非常多的回调处理逻辑都在<code>LSBaseRequest</code>内部完成处理了。<br>如果需要创建一个新的业务请求 API，只要创建一个继承自<code>LSBaseRequest</code>的 API 类，在类的头文件声明中，除特殊情况外，不需要做任何的处理，比如一个典型的请求个人信息的 API 接口声明如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">HNUserInfoAPI </span>: LSBaseRequest</span><br><span class="line"><span class="comment">// 此处一般不需要声明任何额外的属性和方法</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>  而具体业务的 API 实现，也只需要配置该 API 的 URL，API 的请求方式即可。</p><h3 id="额外的数据逻辑处理需求"><a href="#额外的数据逻辑处理需求" class="headerlink" title="额外的数据逻辑处理需求"></a>额外的数据逻辑处理需求</h3><p>如果该 API 请求对于回调数据有特殊的加工需求：</p><ul><li>需要一个列表数据，则会增加下面这些处理逻辑，实现<code>LSBaseRequest</code>的<code>resultData</code>的获取方法 ，比如请求交易记录的 API ：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处是实现LSBaseRequest的属性</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)resultData&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> handleData:<span class="keyword">self</span>.resultDic];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对请求的回调数据进行深加工，JSON 转列表</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)handleData:(<span class="built_in">NSDictionary</span> *)dictionary&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *resultArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">if</span> ([dictionary count]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultDic = (<span class="built_in">NSDictionary</span> *)[[dictionary objectForKey:<span class="string">@"data"</span>] objectForKey:<span class="string">@"result"</span>];</span><br><span class="line">        [resultArray addObjectsFromArray:[HNTradeRecordModel mj_objectArrayWithKeyValuesArray:resultDic]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要一个模型数据，则会增加下面这些处理逻辑， 实现<code>LSBaseRequest</code>的<code>model</code>的获取方法 ，比如请求个人信息的 API ：</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id)model&#123;</span><br><span class="line">    <span class="keyword">return</span> [self <span class="string">handleData:</span>self.resultDic];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对请求的数据进行深加工，JSON 转模型</span></span><br><span class="line">- (HNUserModel *)<span class="string">handleData:</span>(NSDictionary *)dictionary&#123;</span><br><span class="line">    <span class="keyword">if</span> ([dictionary count]) &#123;</span><br><span class="line">        [[PMStore store]<span class="string">handleUserDictionary:</span>dictionary <span class="string">resiterJpush:</span>NO];</span><br><span class="line">        NSDictionary *dic = [[dictionary <span class="string">objectForKey:</span>@<span class="string">"data"</span>] <span class="string">objectForKey:</span>@<span class="string">"result"</span>];</span><br><span class="line">        HNUserModel *model = [HNUserModel <span class="string">mj_objectWithKeyValues:</span>dic];</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果没有额外的数据需求，则上面这些逻辑都不需要。</li></ul><h2 id="具体业务流程说明："><a href="#具体业务流程说明：" class="headerlink" title="具体业务流程说明："></a>具体业务流程说明：</h2><p>如果需要新增一个新的业务请求类：</p><ol><li>新建一个新的基于<code>LSBaseRequest</code>类</li><li>完成 API 类的基本配置，包括 URL 和请求方式的配置</li><li>如果 该 API 类有更多的数据处理需求，按照上面所写的方式来处理</li></ol><p>在 ViewController 或者 View 中初始化 API，一个实例如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadDataFromService&#123;</span><br><span class="line">    <span class="comment">// API 请求的参数</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dic = [[<span class="built_in">NSMutableDictionary</span> alloc]initWithDictionary:@&#123;<span class="string">@"offset"</span>:<span class="keyword">self</span>.offset,</span><br><span class="line">                                                                                <span class="string">@"limit"</span>:<span class="string">@"10"</span>&#125;];</span><br><span class="line">  <span class="comment">// 初始化 API 请求，传入需要的参数及状态信息</span></span><br><span class="line">    HNInquiryListAPI *request = [[HNInquiryListAPI alloc]initWithArgumentValueDictionary:dic isLogin:<span class="literal">YES</span> isRetAry:<span class="literal">YES</span> isRetObj:<span class="literal">NO</span>];</span><br><span class="line">    [request setSuccessArray:^(<span class="built_in">NSArray</span> *resultData) &#123;</span><br><span class="line">        <span class="comment">// 初始化的要求 API 能够对回调数据进行深加工——返回列表，所以这里直接设置列表的 block 回调处理逻辑。</span></span><br><span class="line">    &#125;];</span><br><span class="line">    [request setFailure:^(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">  <span class="comment">// 请求失败的回调</span></span><br><span class="line">    &#125;];</span><br><span class="line">    [request startRequest];  <span class="comment">// 发送请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是完整的网络层架构的说明及具体业务处理的流程。</p><h2 id="其他说明——图片及文件上传请求"><a href="#其他说明——图片及文件上传请求" class="headerlink" title="其他说明——图片及文件上传请求"></a>其他说明——图片及文件上传请求</h2><p>上传图片的 API 不同于其他的业务处理 API，它不需要处理一堆的业务逻辑，而且目前也不需要登录等状态，因此网络层将上传图片的 API 直接独立了出来，直接继承与<code>YTKRequest</code>。目前的图片 API 如下，已经封装完成，图片微服务不做大的重构，此 API 也不需要做修改：</p><p>声明：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;YTKRequest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HNUploadImageApi</span> : <span class="title">YTKRequest</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithImage:(<span class="built_in">NSArray</span> *)image;  <span class="comment">// 需要上传的图片文件数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> baseRequestArgument;  <span class="comment">// 请求的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现部分 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"HNUploadImageApi.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HNUploadImageApi</span></span>&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *_image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithImage:(<span class="built_in">NSArray</span> *)image &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _image = image;  <span class="comment">// 初始化图片数组的属性</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (YTKRequestMethod)requestMethod &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建请求参数</span></span><br><span class="line">- (<span class="keyword">void</span>)setBaseRequestArgument:(<span class="keyword">id</span>)baseRequestArgument&#123;</span><br><span class="line">    <span class="keyword">if</span> (baseRequestArgument) &#123;</span><br><span class="line">        _baseRequestArgument = baseRequestArgument;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)requestArgument &#123;</span><br><span class="line">    <span class="keyword">if</span> (_baseRequestArgument) &#123;</span><br><span class="line">        <span class="keyword">return</span> _baseRequestArgument;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</span><br><span class="line">    <span class="keyword">return</span> UploadImageAPI;  <span class="comment">// 上传 URL 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求的 body 的构造</span></span><br><span class="line">- (AFConstructingBlock)constructingBodyBlock &#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; _image.count; i++)&#123;</span><br><span class="line">            <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(_image[i], <span class="number">0.5</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">float</span>)data.length/<span class="number">1024</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                data = <span class="built_in">UIImageJPEGRepresentation</span>(_image[i], <span class="number">1024</span>*<span class="number">1000.0</span>/(<span class="keyword">float</span>)data.length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"image%d.png"</span>,i];</span><br><span class="line">            <span class="built_in">NSString</span> *type = <span class="string">@"image/jpeg"</span>;</span><br><span class="line">            [formData appendPartWithFileData:data name:<span class="string">@"image"</span> fileName:name mimeType:type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>具体构建及发送请求的流程如下，以上传头像为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HNUploadImageApi *api = [[HNUploadImageApi alloc] <span class="string">initWithImage:</span>@[scaleImage]]; <span class="comment">// 初始化请求，并传递需要上传的图片数组</span></span><br><span class="line">api.baseRequestArgument = @&#123;@<span class="string">"type"</span>:@<span class="string">"0"</span>&#125;;   <span class="comment">// 构造请求的参数</span></span><br><span class="line">[api <span class="string">startWithCompletionBlockWithSuccess:</span>^(YTKBaseRequest *request)&#123;</span><br><span class="line">    NSData *data = [request.responseString <span class="string">dataUsingEncoding:</span>NSUTF8StringEncoding];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        NSMutableDictionary *dic = [NSJSONSerialization <span class="string">JSONObjectWithData:</span>data <span class="string">options:</span>NSJSONReadingMutableContainers <span class="string">error:</span>nil];</span><br><span class="line">  <span class="comment">// 初次处理上传成功后的数据回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="string">failure:</span>^(YTKBaseRequest *request)&#123;</span><br><span class="line">    <span class="comment">// 上传失败后是回调</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-网络层文档&quot;&gt;&lt;a href=&quot;#iOS-网络层文档&quot; class=&quot;headerlink&quot; title=&quot;iOS 网络层文档&quot;&gt;&lt;/a&gt;iOS 网络层文档&lt;/h1&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;iOS 的网络层使用 &lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YTKNetwork&lt;/a&gt;作为网络层底层架构，在  &lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YTKNetwork&lt;/a&gt;的&lt;code&gt;YTKRequest&lt;/code&gt;类和具体的业务请求层之间架设了一个中间业务类&lt;code&gt;LSBaseRequest&lt;/code&gt;，所有具体的 API 请求都继承于此类。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://suool.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://suool.net/tags/iOS/"/>
    
      <category term="组件文档" scheme="http://suool.net/tags/%E7%BB%84%E4%BB%B6%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://suool.net/2016/10/27/%E6%97%A0%E9%A2%98/"/>
    <id>http://suool.net/2016/10/27/无题/</id>
    <published>2016-10-27T02:20:49.000Z</published>
    <updated>2018-07-01T14:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>不知道到底该取什么样的题目了, 就像打的标签一样, 想写的东西有点多, 取什么名字都有点不合适.</p><p>马克思说,人和动物的根本区别在于能够制造和利用工具. 确实是这样, 但是真正使得人类进步的却应该是mistake, 是不断的犯错, 不断的改正和积累, 才能不断的进化, 才成为人.<br><a id="more"></a></p><h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><p>可能是工作的原因, 对于无限循环这样的事情是有些恐惧的, 无限循环意味着你所做的的东西不能正常的结束, 同时对我而言陷入到无限的循环当中是一件非常恐怖的事情, 你无法决定自己什么时候能够真正走到正确的道路上, 也不知道何时能够选择正确的方向.</p><p>但是另一方面, 几年前读到的一本书, 里面说到这样的一段话:</p><blockquote><p>我们都在for循环，区别在于你是什么情况下break;的。有的人退出阈值高，这是能坚持的一类人，有的人退出阈值低，这类人很可能遇到一些障碍就退出了。过早退出的原因往往在于对于未来的不确定性，对于投资时间最终无法收到回报的恐惧，感受到的困难越大，这种恐惧越大，因为越大的困难往往暗示着这个任务需要投资的时间越大。所以其实我们都是直觉经济学家，当我们说“畏难”的时候，其实我们畏惧的不是困难本身，而是困难所暗示的时间经济学意义。</p><p>模仿高德纳先生的名言：过早退出是一切失败的根源。</p></blockquote><p>所以, 关于循环的思考到这里就出现了一些问题.</p><p>显然, 我需要纠正我对于循环的态度, 我得承认我现在对循环的态度和选择是错误的, 害怕循环其实根本上来说是自己不够自信, 不相信自己能够掌控循环的节奏和走向.</p><p>同时, 需要结合的一点是, 所有的事情都是和人关联在一起的. 所有的事情也不是孤立存在的, 都是有关联的.</p><p>所以, 对待事情的态度其实就对人的态度, 当选择解决问题的方式的时候, 要先思考一下这个问题对应的人是谁, 对应的位置在哪里, 对应的态度应该是什么, 最终的方式也就确定了.</p><p>而所谓循环也只是上面”事情”的一种特殊情况, 既然选择了这样的位置, 就要用对应的态度去面对, 不要急于顺着自己一时的反应的走, 要真正的成长就要真正的去思考.</p><h2 id="关于希望"><a href="#关于希望" class="headerlink" title="关于希望"></a>关于希望</h2><p>总是不断的有新的希望产生和旧的希望破灭, 也总有一些希望成为了现实, 这样才能不断向前走.</p><p>所谓的希望也都是面向未来的, 每个希望都是自己对未来的路的一种认识. 所以, 我说生活中充满了失望和绝望也挺好的, 起码可以消除很多自己给自己的不必要的期望和羁绊, 让脚下的路更加真实, 也让自己对未来的认识更加清晰.</p><p>所以, 希望本来就是一个不确定的事情, 没有成为现实也是一个完全可以理解的事情, 生活就是这样的残酷, 不能拿着自己的标准去要求所有人都按照你的方式来.</p><p>只需要记住, 概率上的事情, 失败是很显然和正常的.</p><p>只能说, 很可惜, 自己欠缺了一些思考, 没有能够选择一个正确的方式去面对, 徒劳后悔也是没用的事情.</p><p>不能说”如果”, 生活是不存在如果的. 做错了一件事就是做错了, 是不能抱着”挽回”这样的期望的, 这样的期望是妄想.</p><p>这个时候唯一的能抱有的希望也稚只能是, 希望生活再给你一次机会, 自己能够选择一个”正确而合适”的方式解决问题, 这也是人一直会变的原因, 也是使人进步的原因.</p><p>所以, 用发展的眼光看未来, 用不断变化的观念去看待一个人.</p><h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>多读书, 多思考.</p><p>不要急于做决定, 不要急于判断一个人, 一件事情.</p><p>要知道生活是没有”如果”的, 那么急做什么呢.</p><p>未来还是有很多希望的.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道到底该取什么样的题目了, 就像打的标签一样, 想写的东西有点多, 取什么名字都有点不合适.&lt;/p&gt;
&lt;p&gt;马克思说,人和动物的根本区别在于能够制造和利用工具. 确实是这样, 但是真正使得人类进步的却应该是mistake, 是不断的犯错, 不断的改正和积累, 才能不断的进化, 才成为人.&lt;br&gt;
    
    </summary>
    
      <category term="思考" scheme="http://suool.net/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="希望" scheme="http://suool.net/tags/%E5%B8%8C%E6%9C%9B/"/>
    
      <category term="未来" scheme="http://suool.net/tags/%E6%9C%AA%E6%9D%A5/"/>
    
      <category term="循环" scheme="http://suool.net/tags/%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>踏过所有的过往</title>
    <link href="http://suool.net/2016/10/02/%E8%B8%8F%E8%BF%87%E6%89%80%E6%9C%89%E7%9A%84%E8%BF%87%E5%BE%80/"/>
    <id>http://suool.net/2016/10/02/踏过所有的过往/</id>
    <published>2016-10-02T02:20:49.000Z</published>
    <updated>2018-07-01T14:10:09.703Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>睡到凌晨被噩梦惊醒。<br><a id="more"></a></p><p>这些日子又何曾不像处在梦魇，只是自己不愿醒来，不想对过去说再见。一直想着如果有假如那又会是怎样的一副光景，不敢去接受其实只有自己停留在过去的事实。所谓贱人就是矫情，没想过只要自己用心改变，未来不需要假如也能很好，何苦一直留恋从前呢？</p><p>是啊，何苦一直留恋从前，何苦为难自己也为难别人呢？应该只是觉得还有一丝希望还有一点机会就不想放弃。</p><p>一丝希望可以让你丢掉所有的尊严和骄傲，让你恨不得把自己埋在地底下去。一丝希望也能抵挡住无限的伤害。</p><p>但是，其实也只是一丝希望而已，总有耗尽的一天，总有被现实击穿的一天，没了就永远没了。</p><p>连这些都没了，还想要停留在过去吗？</p><p>是时候say goodbye了。</p><p>总要向前看，不然谁愿意跟着一个人停留在过去，谁想带着一个不敢相信未来的人闯荡呢？</p><p>或许生活总能继续，但是生命中总能感觉到死的诱惑。</p><p>我想彻底抹除出现在我身上的你的痕迹了。我的未来不会再有从前那个我，我也不会遇见曾经那个你。</p><p>嗯，噩梦也挺好的，起码让人不继续活在梦里。</p><p>这些日子，我丧失对生活的希望，怀疑自己的人生。不止一次的想着即使现在死掉和以后死掉没有什么区别。</p><p>这些都拜你所赐。</p><p>我应该永远都不会理解你的想法了，我想我该醒过来了，再不醒过来，恐怕我真的要死在这梦里，死在过去了。</p><p>你确实很坏。</p><p>我要踏过这所有的绝望和过往，我要走了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;睡到凌晨被噩梦惊醒。&lt;br&gt;
    
    </summary>
    
      <category term="思考" scheme="http://suool.net/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="希望" scheme="http://suool.net/tags/%E5%B8%8C%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://suool.net/2016/08/17/hello-world/"/>
    <id>http://suool.net/2016/08/17/hello-world/</id>
    <published>2016-08-17T02:20:49.000Z</published>
    <updated>2018-07-01T14:10:09.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="假如"><a href="#假如" class="headerlink" title="假如"></a>假如</h1><p>如果时光倒流，我能做什么？</p><p>这一辈子就这么长, 怎么过完全看你的选择了.<br><a id="more"></a></p><ul><li>2016-8-18</li></ul><p>最近愈发的感觉到绝望和无助, 感觉自己所想的很多东西都是自己的妄想. 连白日梦都算不得.</p><ul><li>2016-9-5</li></ul><p>感觉没必要存在这样一个博客, 对于表达自己已经彻底的失去了兴趣.</p><p>当前这个环境, 大家不会关注别人真正需要什么, 也对你在思考什么不感兴趣. 我们都是这个社会创造出来的程式罢了, 按照一些约定俗成的规则去行事, 按照所谓的主流来制定自己存在的逻辑.</p><p>所以, 表达自己什么的, 没有必要, 不想过多的去争辩什么了, 没意思.</p><p>就这样吧.</p><ul><li>2016-9-11</li></ul><p>心情低落到了极点, 也悲观到极点.</p><p>我现在深深的感觉到自己的幼稚和孩子气, 一直都想要找个人来依靠. 这就是我的心理吧.</p><p>凡人皆有一死, 纵然多活几十年, 无甚成就, 又有什么意思呢?</p><p>其实不是我对未来绝望, 而是我对自己绝望, 过了这么多年, 我依然是如此怯懦的本性.</p><p>性格真是一个难以改变的东西, 你能挣脱性格的限制, 那么是不是也挣脱了命运的掌控呢?</p><p>这些想法以及现在这些日子总是让我不经意的想起高中那段阴暗的人生.</p><ul><li>2016-9-25</li></ul><p>昨天为了看程璧的演唱会回了广州.</p><p>感觉程璧的现场真的很让人享受, 差不多是按着一曲中文一曲日语歌的节奏, 偶尔还会朗读几首小诗.</p><p>嗯, 感觉女孩子读诗的样子真的是美极了.</p><p>整个演唱会感觉很棒, 下次有机会肯定还要听.</p><p>而且一定要去次好妹妹的.</p><p>今天回到了学校, 借了行志的饭卡混进了图书馆, 写了一天代码……</p><p>中午还和一个老朋友弘毅一起吃了饭, 聊了很多东西.</p><p>图书馆真是一个学习的好地方啊, 可惜来的机会太少了.</p><p>以后有机会一定要常回来~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;假如&quot;&gt;&lt;a href=&quot;#假如&quot; class=&quot;headerlink&quot; title=&quot;假如&quot;&gt;&lt;/a&gt;假如&lt;/h1&gt;&lt;p&gt;如果时光倒流，我能做什么？&lt;/p&gt;
&lt;p&gt;这一辈子就这么长, 怎么过完全看你的选择了.&lt;br&gt;
    
    </summary>
    
      <category term="思考" scheme="http://suool.net/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="杂感" scheme="http://suool.net/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
</feed>
