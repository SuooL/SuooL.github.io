<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SuooL&#39;s Blog</title>
  
  <subtitle>胡振生写字的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suool.net/"/>
  <updated>2018-06-17T17:22:27.956Z</updated>
  <id>http://suool.net/</id>
  
  <author>
    <name>SuooL</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习中的数学基础--线性代数</title>
    <link href="http://suool.net/2018/06/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://suool.net/2018/06/18/机器学习中的数学基础-线性代数/</id>
    <published>2018-06-17T16:39:23.000Z</published>
    <updated>2018-06-17T17:22:27.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="标量、向量、矩阵和张量"><a href="#标量、向量、矩阵和张量" class="headerlink" title="标量、向量、矩阵和张量"></a>标量、向量、矩阵和张量</h2><ul><li>标量(scalar): 一个标量就是一个单独的数，它不同于线性代数中研究的其他大部分对象(通常是多个数的数组)。</li><li>向量(vector): 一个向量是一列数。这些数是有序排列的。通过次序中的索引，我们可以确定每个单独的数。</li><li>矩阵(matrix): 矩阵是一个二维数组，其中的每一个元素被两个索引(而非一个)所确定。</li><li>张量(tensor): 在某些情况下，我们会讨论坐标超过两维的数组。一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们称之为张量。</li></ul><p><strong>转置(transpose)</strong>是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像， 这条从左上角到右下角的对角线被称为 主对角线(main diagonal)。我们将矩阵 A 的转置表示为 $A^T$，定义如下</p><p>$$(A^T)<em>{i,j} = A</em>{j,i} \tag{1}$$</p><p>向量可以看作只有一列的矩阵。对应地，向量的转置可以看作是只有一行的矩阵。标量可以看作是只有一个元素的矩阵。</p><p>只要矩阵的形状一样，我们可以把两个矩阵相加。两个矩阵相加是指对应位置的元素相加。</p><p>标量和矩阵相乘，或是和矩阵相加时，我们只需将其与矩阵的每个元素相乘或相加。</p><h2 id="矩阵和向量相乘"><a href="#矩阵和向量相乘" class="headerlink" title="矩阵和向量相乘"></a>矩阵和向量相乘</h2><p>两个矩阵 $\bf A$ 和 $ \bf B$ 的矩阵乘积 (matrix product) 是第三个矩阵 $\bf C$。为了使乘法定义良好，矩阵 $\bf A$ 的列数必须和矩阵 $\bf B$ 的行数相等。如果矩阵 $\bf A$的形状是 $m \times n$，矩阵 B 的形状是 $ n \times p$，那么矩阵$\bf C$的形状是 $ m \times p $ ，具体地，该乘法操作定义为 </p><p>$$<br>C <em>{i,j} = \sum</em>{k} {A_{i,k}}B_{k,j}<br>\tag{2}<br>$$</p><p>两个相同维数的向量 x 和 y 的 点积 (dot product) 可看作是矩阵乘积 $x^⊤y$。我 们可以把矩阵乘积 $C=AB$ 中计算 $C_{i,j}$ 的步骤看作是 $A$ 的第 $i$ 行和 $B$ 的第 $j$ 列之间的点积。</p><p>两个向量点积的结果是标量</p><h2 id="单位矩阵和逆矩阵"><a href="#单位矩阵和逆矩阵" class="headerlink" title="单位矩阵和逆矩阵"></a>单位矩阵和逆矩阵</h2><p> 单位矩阵 (identity matrix)<br> 矩阵逆 (matrix inversion)</p><p> 任意向量和单位矩阵相乘，都不会改变。</p><p>单位矩阵的结构很简单:所有沿主对角线的元素都是 1，而所有其他位置的元素都是 0。如下所示。</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0 \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>\tag{3}<br>$$</p><p>矩阵 $A$ 的矩阵逆(matrix inversion)记作 $A^{−1}$，其定义的矩阵满足如下条件<br>$$A^{−1}A = I_n.\tag{4}$$</p><p>一组向量的线性组合，是指每个向量乘以对应标量系数之后的和，即:<br>$$<br>\sum_{i} {c_iv^i}.\tag{5}<br>$$</p><p>一组向量的<strong>生成子空间(span)</strong>是原始向量线性组合后所能抵达的点的集合</p><p>如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量称为<strong>线性无关 (linearly independent</strong>)。</p><p>一个列向量线性相关的方阵被称为<strong>奇异的(singular)</strong></p><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>在机器学习中，我们经常使用被称为<strong>范数 (norm)</strong>的函数衡量向量大小。形式上，$L^p$ 范数定义如下</p><p>$$<br>||x||<em>p=<br>\left(<br>\sum</em>{i}{|x_i|^p}<br>\right)^{\frac{1}{p}}<br>\tag{6}<br>$$</p><p>其中 $p \in R , p \geq 1 $.</p><p>范数(包括 $L^p$ 范数)是将向量映射到非负值的函数。直观上来说，向量 $x$ 的范数衡量从原点到点 $x$ 的距离。</p><p>当 $p = 2$ 时，$L^2$ 范数被称为<strong>欧几里得范数(Euclidean norm)</strong>。它表示从原点出发到向量 $x$ 确定的点的欧几里得距离。$L^2$ 范数在机器学习中出现地十分频繁，经常简化表示为 $∥x∥$，略去了下标 2。平方 $L^2$ 范数也经常用来衡量向量的大小，可以简单地通过点积 $x^⊤x$ 计算。</p><p>平方 $L^2$ 范数在数学和计算上都比 $L^2$ 范数本身更方便。例如，平方 $L^2$ 范数对 $x$ 中每个元素的导数只取决于对应的元素，而 $L^2$ 范数对每个元素的导数却和整个向量相关。但是在很多情况下，平方 $L^2$ 范数也可能不受欢迎，因为它在原点附近增长 得十分缓慢。在某些机器学习应用中，区分恰好是零的元素和非零但值很小的元素 是很重要的。在这些情况下，我们转而使用在各个位置斜率相同，同时保持简单的数学形式的函数:$L^1$ 范数. $L^1$ 范数可以简化如下:</p><p>$$<br>||x||_1 = \sum_i {|x_i|}<br>\tag{7}<br>$$</p><p>当机器学习问题中零和非零元素之间的差异非常重要时，通常会使用 $L^1$ 范数。每当<br>$x$ 中某个元素从 0 增加 $\epsilon$，对应的 L1 范数也会增加 $\epsilon$ 。</p><p>另外一个经常在机器学习中出现的范数是 $L^\infty$ 范数，也被称为<strong>最大范数(max norm)</strong>。这个范数表示向量中具有最大幅值的元素的绝对值:</p><p>$$<br>||x||_\infty = \underset{i}{max}|x_i|<br>\tag{8}<br>$$</p><p>有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用 <strong>Frobenius 范数(Frobenius norm)</strong>，</p><p>$$<br>||A||<em>F = \sqrt {\sum</em>{i,j}A^2_{i,j}}<br>\tag{9}<br>$$</p><p>其类似于向量的 $L^2$ 范数。<br>两个向量的<strong>点积(dot product)</strong>可以用范数来表示。具体地，</p><p>$$<br>x^Ty=||x||_2||y||_2\cos\theta  \tag{10}<br>$$</p><p>其中 $θ$ 表示 $x$ 和 $y$ 之间的夹角。</p><p>如果 $x^⊤y = 0$，那么向量 $x$ 和向量 $y$ 互相<strong>正交(orthogonal)</strong>。如果两个向量都有非零范数，那么这两个向量之间的夹角是 90 度。在 $R^n$ 中，至多有 $n$ 个范数非零向量互相正交。如果这些向量不仅互相正交，并且范数都为 1，那么我们称它们 是<strong>标准正交(orthonormal)</strong>。</p><p><strong>正交矩阵(orthogonal matrix)</strong>是指行向量和列向量是分别标准正交的方阵,$A^{−1} = A^⊤$</p><h2 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h2><p><strong>特征分解(eigendecomposition)</strong>是使用最广的矩阵分解之一，即我们将矩阵分解成一组<strong>特征向量</strong>和<strong>特征值</strong>。<br>方阵 A 的<strong>特征向量(eigenvector)</strong>是指与 A 相乘后相当于对该向量进行缩放的非零向量 v:<br>$$<br>Av = \lambda v<br>\tag{11}<br>$$<br>标量 $λ$ 被称为这个特征向量对应的<strong>特征值(eigenvalue)</strong></p><p>A 的<strong>特征分解(eigendecomposition)</strong>可以记作</p><p>$$<br>A=Vdiag(\lambda)V^{-1}<br>\tag{12}<br>$$</p><p>所有特征值都是正数的矩阵被称为<strong>正定(positive definite)</strong>;所有特征值都是非负数的矩阵被称为<strong>半正定(positive semidefinite)</strong>。同样地，所有特征值都是负数的 矩阵被称为<strong>负定(negative definite)</strong>;所有特征值都是非正数的矩阵被称为<strong>半负定(negative semidefinite)</strong>。半正定矩阵受到关注是因为它们保证 $∀x, x^⊤Ax ≥ 0$。此外，正定矩阵还保证 $x^⊤Ax = 0 ⇒ x = 0$。</p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p><strong>奇异值分解(singular value decomposition, SVD)</strong>，将矩阵分解为<strong>奇异向量(singular vector)</strong>和<strong>奇异值(singular value)</strong>。通过奇异值分解，我们会得到一些与特征分解相同类型的信息。每个实数矩阵都有一个奇异值分解，但不一定都有特征分解。例如，非方阵的矩阵没有特征分解，这时我们只能使用奇异值分解。</p><p>分解表达式:<br>$$<br>A = UDV^⊤. \tag{13}<br>$$</p><p>假设 $A$ 是一个 $m×n$ 的矩阵，那么 $U$ 是一个 $m×m$ 的矩阵，$D$ 是一个 $m×n$<br>的矩阵，$V$ 是一个 $n × n$ 矩阵。 这些矩阵中的每一个经定义后都拥有特殊的结构。矩阵 $U$ 和 $V$ 都定义为正交矩阵，而矩阵 $D$ 定义为对角矩阵。注意，矩阵 $D$ 不一定是方阵。<br>对角矩阵 $D$ 对角线上的元素被称为矩阵 $A$ 的<strong>奇异值(singular value)</strong>。矩阵 $U$ 的列向量被称为<strong>左奇异向量(left singular vector)</strong>，矩阵 $V$ 的列向量被称<strong>右奇异向量(right singular vector)</strong>。<br>事实上，我们可以用与 $A$ 相关的特征分解去解释 $A$ 的奇异值分解。$A$的<strong>左奇异向量(left singular vector)</strong>是 $AA^⊤$ 的特征向量。$A$ 的<strong>右奇异向量(right singular vector)</strong>是 $A^⊤A$ 的特征向量。A 的非零奇异值是 $A^⊤A$ 特征值的平方根，同时也是 $AA^⊤$ 特征值的平方根。</p><h2 id="迹运算"><a href="#迹运算" class="headerlink" title="迹运算"></a>迹运算</h2><p>迹运算返回的是矩阵对角元素的和:<br>$$<br>Tr(A)=\sum_i {A_{i,i}}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性代数&quot;&gt;&lt;a href=&quot;#线性代数&quot; class=&quot;headerlink&quot; title=&quot;线性代数&quot;&gt;&lt;/a&gt;线性代数&lt;/h1&gt;&lt;h2 id=&quot;标量、向量、矩阵和张量&quot;&gt;&lt;a href=&quot;#标量、向量、矩阵和张量&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="机器学习" scheme="http://suool.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="线性代数" scheme="http://suool.net/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="机器学习" scheme="http://suool.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾指南之将你树莓派变成智能家居中枢</title>
    <link href="http://suool.net/2018/01/13/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E5%B0%86%E4%BD%A0%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8F%98%E6%88%90%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%B8%AD%E6%9E%A2/"/>
    <id>http://suool.net/2018/01/13/树莓派折腾指南之将你树莓派变成智能家居中枢/</id>
    <published>2018-01-13T09:45:13.000Z</published>
    <updated>2018-01-13T09:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将你树莓派变成智能家居中枢"><a href="#将你树莓派变成智能家居中枢" class="headerlink" title="将你树莓派变成智能家居中枢"></a>将你树莓派变成智能家居中枢</h1><p>树莓派由于本身足够的小巧且扩展性极高，所以它智能家居方面的应用具有天然的优势。对于喜欢折腾和 Geek 的人的而言，其扩展性具有无比的吸引力。</p><p>这次我们就来尝试将树莓派变身为智能家居的管理中枢，将其桥接到苹果家的 Home 应用当中，使用 Siri 来控制所有的智能家居。</p><p>由于 Apple 家认证的智能家居暂时承担不起，而刚好又可以使用树莓派加上 <code>HomeBridge</code> 相关的框架来将小米的智能家居产品加入 <code>HomeKit</code> 。</p><p>我使用的是小米智能家居全家桶套装，极客学院送的2017年元旦讲师礼物，在此表示感谢！其包含内容产品主要有：多功能网关，人体传感器，智能插座，无线开关，门窗传感器。效果图如下：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158306050366.jpg" alt="-w629"></p><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158306313468.jpg" alt="-w451"></p><p>用习惯之后，不得不说确实很方便，特别是寒冷的冬天不用起床就能开关灯。</p><p>下面就进入正题，如何将你的树莓派变身智能家居桥接中枢。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h3><p>硬件：</p><ul><li>Raspberry Pi</li><li>小米智能家居产品</li></ul><p>软件：</p><ul><li><a href="https://github.com/nfarina/homebridge" target="_blank" rel="noopener">HomeBridge</a></li><li><a href="https://github.com/YinHangCode/homebridge-mi-aqara" target="_blank" rel="noopener">homebridge-mi-aqara</a></li></ul><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li>硬件准备和连接</li><li>软件环境和依赖安装</li><li>安装运行 <code>Homebridge</code></li><li>安装及配置 <code>homebridge-mi-aqara</code></li><li>测试及后台运行</li><li>其他</li></ol><h2 id="步骤一：硬件准备和连接"><a href="#步骤一：硬件准备和连接" class="headerlink" title="步骤一：硬件准备和连接"></a>步骤一：硬件准备和连接</h2><p>首先将你的<a href="https://www.jianshu.com/p/b62a8229a74c" target="_blank" rel="noopener">树莓派安装好系统并配置好</a>，最好可以使用 SSR 全局代理可以科学上网，这样可以改善你的树莓派网络环境，一定程度加快安装过程。具体的方法参考<a href="https://www.jianshu.com/p/445256a2367b" target="_blank" rel="noopener">之前的文章</a>。</p><p>使用 SSH 远程连接你的树莓派：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="literal">pi</span><span class="meta">@raspberrypi</span>.<span class="keyword">local</span></span><br></pre></td></tr></table></figure><p>更新树莓派相关依赖环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> upgrade</span><br></pre></td></tr></table></figure><p>完成之后进入下一步。</p><h2 id="步骤二：软件环境和依赖安装"><a href="#步骤二：软件环境和依赖安装" class="headerlink" title="步骤二：软件环境和依赖安装"></a>步骤二：软件环境和依赖安装</h2><p>首先安装这两个库使用的都是 <code>Node</code> 环境的 <code>npm</code> 工具，因此要先安装 <code>Node</code>，命令如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL http<span class="variable">s:</span>//<span class="keyword">deb</span>.nodesource.<span class="keyword">com</span>/setup_8.<span class="keyword">x</span> | sudo -E bash -</span><br><span class="line">sudo apt-<span class="built_in">get</span> install -<span class="keyword">y</span> nodejs</span><br></pre></td></tr></table></figure><p>其次需要安装 <code>avahi</code> 包</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install libavahi-compat-libdnssd-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>如果上述包安装出现错误，可以参考这里的<a href="https://stackoverflow.com/questions/26571326/how-do-i-resolve-the-following-packages-have-unmet-dependencies" target="_blank" rel="noopener">解决方法</a></p><p>尝试使用 </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude <span class="keyword">install</span> libavahi-compat-libdnssd-dev</span><br></pre></td></tr></table></figure><p>命令安装依赖，可能需要将相关软件包降级就可以顺利安装了。</p><h2 id="步骤三：安装运行-Homebridge"><a href="#步骤三：安装运行-Homebridge" class="headerlink" title="步骤三：安装运行 Homebridge"></a>步骤三：安装运行 Homebridge</h2><p>这里具体的安装步骤可以直接去参考其 github 主页的 wiki 内容。简单的来说，步骤如下:<br>首先可以试一下使用如下命令安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g homebridge</span><br></pre></td></tr></table></figure><p>如果上述命令安装过程出现了错误，那么可以尝试使用如下的命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">sudo npm install -g --unsafe-perm homebridge hap-nodejs node-gyp</span><br><span class="line">cd /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">node_modules</span>/<span class="title">homebridge</span>/</span></span><br><span class="line">sudo npm install --unsafe-perm bignum</span><br><span class="line">cd /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">node_modules</span>/<span class="title">hap</span>-<span class="title">nodejs</span>/<span class="title">node_modules</span>/<span class="title">mdns</span></span></span><br><span class="line">sudo node-gyp BUILDTYPE=Release rebuild</span><br></pre></td></tr></table></figure><p>上面的 <code>/usr/lib/</code> 目录，如果你不是使用的 <code>apt-get</code> 命令安装的 <code>Node</code>，需要换成 <code>/usr/local/lib/</code> 。<br>一定要严格安装上述命令的步骤来安装，该切换目录就切换目录。</p><p>此时安装应该不会有什么问题了。</p><h2 id="步骤四：安装及配置-homebridge-mi-aqara"><a href="#步骤四：安装及配置-homebridge-mi-aqara" class="headerlink" title="步骤四：安装及配置 homebridge-mi-aqara"></a>步骤四：安装及配置 homebridge-mi-aqara</h2><p>其项目主页是 <a href="https://github.com/YinHangCode/homebridge-mi-aqara" target="_blank" rel="noopener">homebridge-mi-aqara</a>，可以在他的项目主页看到其支持的小米硬件，基本是非常全面的。</p><p>安装命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="keyword">install</span> -g homebridge-mi-aqara</span><br></pre></td></tr></table></figure><p>安装完成之后，需要对其进行基本的配置，从而能够将你的小米全家桶硬件加入到 <code>HomeBridge</code> 中。</p><p>首先要获取的是 局域网通信协议密码 以及 网关的 <code>MAC</code> 地址。</p><p>下载米家 APP，连接上你的智能网关以及其他小米智能家居硬件，打开米家 APP，选择你的多功能网关，点击 APP 右上角 <code>···</code> 符号，进入 <code>关于</code> 选项:<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158331055340.jpg" alt=""><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158331906989.jpg" alt=""><br>如上图所示，要不断的点击空白处，片刻后界面就会多了<code>局域网通信协议</code>还有<code>网关信息</code>等选项。<br>这时候，分别点选他们，记录你的网关的<code>局域网通信协议密码</code>以及<code>网关的MAC地址</code>，记得要开启局域网通信协议，记录下密码后，点击确定。网关的 MAC 地址位置如下：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158337428781.jpg" alt=""></p><p>上面的 <code>MAC</code> 地址去除冒号，全变成小写后记录下来，是一串12位的字符。局域网通信协议密码要保留大小写的记录下来。</p><p>记录下上述两个地址之后，就可以开始在终端中配置 <code>HomeBridge</code> 的配置文件了。执行的命令如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir ~/<span class="selector-class">.homebridge</span> </span><br><span class="line">cd ~/<span class="selector-class">.homebridge</span>      </span><br><span class="line">sudo nano config.json</span><br></pre></td></tr></table></figure><p>执行了上述 nano 命令之后，会创建一个配置的 <code>json</code> 文件，将以下内粘贴到终端编辑环境中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bridge"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"Homebridge"</span>,</span><br><span class="line">        <span class="attr">"username"</span>:<span class="string">"CC:22:3D:E3:CE:23"</span>,</span><br><span class="line">        <span class="attr">"port"</span>:<span class="number">51826</span>,</span><br><span class="line">        <span class="attr">"pin"</span>:<span class="string">"723-92-124"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"platforms"</span>: [&#123;</span><br><span class="line">        <span class="attr">"platform"</span>: <span class="string">"MiAqaraPlatform"</span>,</span><br><span class="line">        <span class="attr">"gateways"</span>: &#123;</span><br><span class="line">            <span class="attr">"网关 mac 地址"</span>: <span class="string">"局域网通信协议密码"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述的两个参数替换成刚刚你记录下来的即可。其他参数说明：<br><code>name</code> iOS 的 <code>Homekit</code> 在添加配件的时候看到的名字<br><code>username</code> 如果只是用 <code>Homebridge</code>，这里可以是任意一个类似 <code>MAC</code> 地址的字符串<br><code>port</code> 随意，只要不被占用的端口<br><code>pin</code> iOS 的 <code>Homekit</code> 在添加配件时需要的验证码</p><p>使用 <code>Ctrl + o</code> 保存， <code>Ctrl + x</code> 退出。</p><h2 id="步骤五：测试及后台运行"><a href="#步骤五：测试及后台运行" class="headerlink" title="步骤五：测试及后台运行"></a>步骤五：测试及后台运行</h2><p>在终端输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">homebridge -D</span></span><br></pre></td></tr></table></figure><p>这时候，界面也会出现刚刚你自己填写的 PIN 码<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158339825667.jpg" alt=""></p><p>进入你 iPhone 或者 iPad 的家庭APP，添加配件，扫码几乎不可能加入成功，直接选择输入 PIN 码，即是输入下方的<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15158342592263.jpg" alt=""><br>添加完成之后，你就会看到所有网关所附带的配件了，如我刚开始所配图的一般，不过此时按钮的名字可能是一串英文符号，你需要自己确定各个按钮的作用，给他们一个你想好的名字即可。</p><p>但是上面这个只是在测试环境运行，如果断了 SSH，你手机或者 iPad 里面的所有设备都会处于无响应的状态，所以，我们还需要能够在后台运行的 <code>Homebridge</code>。</p><p>借助 <code>screen</code> 工具即可实现这一需求，具体安装命令如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install screen</span><br></pre></td></tr></table></figure><p>安装完成之后，首先开一一个名字叫做 <code>home</code> 的窗口，具体的名字你可以随意选取，命令如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S <span class="built_in">home</span></span><br></pre></td></tr></table></figure><p>然后所打开的 <code>screen</code> 进程中开启一个 <code>homebridge</code> 进程</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">homebridge -D</span></span><br></pre></td></tr></table></figure><p>在 <code>screen</code> 里开启的 <code>homebridge</code> 不会随着 SSH 关闭而被关闭。使用 <code>Ctrl+A</code> 然后按 <code>d</code> 就可以跳出来了。</p><p>具体关于 <code>screen</code> 命令的用法你可以查看这里的文章: <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-screen/" target="_blank" rel="noopener">linux 技巧：使用 screen 管理你的远程会话</a> 及 <a href="http://www.runoob.com/linux/linux-comm-screen.html" target="_blank" rel="noopener">Linux screen命令</a>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>完成上面的步骤，此时你只能在你的路由器所在的局域网内完成智能家居的控制，如果要在外网实现操作，及 home 的自动化操作，你需要一台 iPad 作为家居中枢，具体的参考 <a href="https://support.apple.com/zh-cn/HT207057" target="_blank" rel="noopener">自动化和远程访问 HomeKit 配件</a></p><p>上面就是一个利用树莓派实现让 Siri 帮你开关灯的过程，下一步可以使用 <code>HomeAssistant</code> 来实现更加智能化和扩展化的家居管理。</p><p>更下一步的尝试可能会比较底层一些了：</p><ul><li>尝试一下扩展温湿度感应器模块</li><li>尝试使用 <code>GPIO</code> 控制 RGB 彩色 LED 灯</li><li>扩展摄像头模块，尝试一下人脸识别等基本的人工智能</li><li>扩展私有云存储及远程下载</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;将你树莓派变成智能家居中枢&quot;&gt;&lt;a href=&quot;#将你树莓派变成智能家居中枢&quot; class=&quot;headerlink&quot; title=&quot;将你树莓派变成智能家居中枢&quot;&gt;&lt;/a&gt;将你树莓派变成智能家居中枢&lt;/h1&gt;&lt;p&gt;树莓派由于本身足够的小巧且扩展性极高，所以它智能家居
      
    
    </summary>
    
      <category term="硬件" scheme="http://suool.net/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="树莓派" scheme="http://suool.net/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾指南之将你的树莓派变身 Google Home</title>
    <link href="http://suool.net/2018/01/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E5%B0%86%E4%BD%A0%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8F%98%E8%BA%AB-Google-Home/"/>
    <id>http://suool.net/2018/01/11/树莓派折腾指南之将你的树莓派变身-Google-Home/</id>
    <published>2018-01-10T16:20:12.000Z</published>
    <updated>2018-01-10T16:29:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将你的树莓派变身-Google-Home"><a href="#将你的树莓派变身-Google-Home" class="headerlink" title="将你的树莓派变身 Google Home"></a>将你的树莓派变身 Google Home</h1><p>目前的智能化已经对人们的生活影响越来越深刻，从智能音箱鼻祖 Amazon Echo 发布之后，智能数字助理就进入了人们的生活当中，也成为人们生活的一部分，特别是其与智能家居配合之后，以前科幻电影中的场景，目前已经渐渐成为现实。</p><p>当前国内的厂家也有发布类似的产品，比如小米的小爱同学，阿里的天猫精灵等智能助理产品，智能家居加上智能助理中枢，将是物联网真正进入人们平常生活的最深刻的体现。</p><p>而且 Google 和 Amazon 都发布了自己语音助手的 SDK ，今天就来看一下如何接入<br><code>Google Assistant SDK</code> ，来体验一下树莓派版本的 <code>Google Home</code> 。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h3><p>硬件：</p><ul><li>Raspberry Pi</li><li>USB 麦克风或者免驱声卡搭配 3.5mm 接口麦克风</li><li>3.5mm 接口的扬声器</li></ul><p>软件：</p><ul><li>Google 账户</li><li>科学上网环境</li></ul><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li>硬件准备和网络连接</li><li>配置测试声音设备</li><li>配置开发者项目及相关设置</li><li>安装 SDK 和示例项目</li><li>注册你的硬件设备</li><li>运行示例代码</li><li>其他</li></ol><h2 id="步骤一：硬件准备和网络连接"><a href="#步骤一：硬件准备和网络连接" class="headerlink" title="步骤一：硬件准备和网络连接"></a>步骤一：硬件准备和网络连接</h2><ol><li>已经安装好系统并且搭建好科学上网环境的树莓派</li><li><p>连接你的麦克风和扬声器到树莓派，麦克风你可以购买一个免驱声卡，连接你的 3.5 mm  麦克风，比如下面这样的，几块钱就能买到。树莓派有一个 3.5mm 的耳机插口，你的扬声器可以接入此接口。<br> <img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155927429534.jpg" alt=""></p></li><li><p>将你的树莓派连接网络</p></li><li>ssh 远程连接你的树莓派</li></ol><h2 id="步骤二：配置测试声音设备"><a href="#步骤二：配置测试声音设备" class="headerlink" title="步骤二：配置测试声音设备"></a>步骤二：配置测试声音设备</h2><h3 id="第一步：确认你的录音和播放设备正常工作"><a href="#第一步：确认你的录音和播放设备正常工作" class="headerlink" title="第一步：确认你的录音和播放设备正常工作"></a>第一步：确认你的录音和播放设备正常工作</h3><ol><li>在命令行输入以下命令，按下 <code>Ctrl+C</code> 来结束。</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">speaker-test -t wav</span></span><br></pre></td></tr></table></figure><p>如果你没有听到任何声音，请检查你的扬声器和树莓派连接是否正常，或者扬声器是不是声音调的太小了。同时你可以通过输入以下命令<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-<span class="built_in">config</span></span><br></pre></td></tr></table></figure></p><p>选择<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155932467591.jpg" alt=""><br>然后选择<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155932800447.jpg" alt=""><br>将你的声音输出从耳机插口输出<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155933119751.jpg" alt=""></p><ol start="2"><li>录制一个简短的声音片段，如果你这时出现了问题，请转到下面的第二步。</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arecord <span class="attribute">--format</span>=S16_LE <span class="attribute">--duration</span>=5 <span class="attribute">--rate</span>=16000 <span class="attribute">--file-type</span>=raw out.raw</span><br></pre></td></tr></table></figure><ol start="3"><li>播放刚刚录制的音频来检查录制效果。</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay <span class="attribute">--format</span>=S16_LE <span class="attribute">--rate</span>=16000 out.raw</span><br></pre></td></tr></table></figure><p>调整你的录制和播放设备，通过下面这个命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">alsamixer</span></span><br></pre></td></tr></table></figure><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155937585522.jpg" alt=""></p><p>如果你的录制和播放设备工作正常，那么这一步的声音设备的配置就完成了，如果你出现了错误，那么可以继续下面的步骤尝试修复问题。</p><h3 id="第二步：找到你的录制和播放设备。"><a href="#第二步：找到你的录制和播放设备。" class="headerlink" title="第二步：找到你的录制和播放设备。"></a>第二步：找到你的录制和播放设备。</h3><p>通过下面这个命令来显示你的声音捕捉设备列表，找到你的麦克风，并记录下设备卡号和设备号。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">arecord -l</span></span><br></pre></td></tr></table></figure></p><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155941154890.jpg" alt="录音设备"><br>如上图所示的 <code>card num</code>  是1，<code>device num</code> 为 0。</p><p>通过下面这个命令来显示你的声音播放设备列表，记录下你的 3.5 mm  接口的设备卡号和设备号，3.5mm 设备的特征是带有 <code>Analog</code> 或者 <code>bcm2835 ALSA</code> (不是 bcm2835 IEC958/HDMI) 字段。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">aplay -l</span></span><br></pre></td></tr></table></figure><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155944050157.jpg" alt="播放设备"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>在你的 /home/pi 目录下创建一个名为 .asoundrc 文件，可以直接输入</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">sudo nano <span class="string">.asoundrc</span></span><br></pre></td></tr></table></figure><p>粘贴以下内容到你的终端编辑器内：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pcm.!default &#123;</span><br><span class="line"> <span class="built_in"> type </span>asym</span><br><span class="line">  capture.pcm <span class="string">"mic"</span></span><br><span class="line">  playback.pcm <span class="string">"speaker"</span></span><br><span class="line">&#125;</span><br><span class="line">pcm.mic &#123;</span><br><span class="line"> <span class="built_in"> type </span>plug</span><br><span class="line">  slave &#123;</span><br><span class="line">    pcm <span class="string">"hw:&lt;card number&gt;,&lt;device number&gt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pcm.speaker &#123;</span><br><span class="line"> <span class="built_in"> type </span>plug</span><br><span class="line">  slave &#123;</span><br><span class="line">    pcm <span class="string">"hw:&lt;card number&gt;,&lt;device number&gt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的两处 <code>&lt;card number&gt;,&lt;device number&gt;</code> ，分别是刚刚让你记录的麦克风和扬声器的设备卡号和设备号，比如刚刚我展示的图片，我的是内容是<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155947400239.jpg" alt=""></p><p>如果你有一个 HDMI 的声音输出并且连接了耳机接口，那么请按照刚刚上面 <code>sudo raspi-config</code> 的设置将你的声音输出强制从耳机接口输出。</p><p>然后重复步骤一看看是不是依然存在问题，如果依然存在问题，可以尝试更换你的声音录制和播放设备。</p><h2 id="步骤三：配置开发者项目及相关设置"><a href="#步骤三：配置开发者项目及相关设置" class="headerlink" title="步骤三：配置开发者项目及相关设置"></a>步骤三：配置开发者项目及相关设置</h2><p>Google 的开发者项目允许你的设备能够访问 <code>Google Assistant API</code>，为了能够访问这个 API，需要进行以下的配置工作。<br>首先，进入 Google 的 Cloud Platform Console，在你的<a href="https://console.cloud.google.com/project" target="_blank" rel="noopener">项目页面</a>，创建一个项目或者选一个已经存在的项目。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155950828092.jpg" alt=""></p><p>然后允许你刚刚所选的项目使用 <code>Google Assistant API</code>，点击以下链接<a href="https://console.developers.google.com/apis/api/embeddedassistant.googleapis.com/overview" target="_blank" rel="noopener">开通 Google Assistant API</a><br>点击启用即可。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155953311656.jpg" alt=""></p><p>然后通过下面的步骤创建一个客户端认证 ID 凭证：</p><ol><li><a href="https://console.developers.google.com/apis/credentials/oauthclient" target="_blank" rel="noopener">创建客户端 ID</a><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155954695217.jpg" alt=""></li><li>输入产品名称及其他可选信息，点击保存即可。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155955232716.jpg" alt="输入名称"></li><li>应用类型选择其他，并输入一个名称。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155956528728.jpg" alt="类型"></li><li>点击创建后弹出一个提醒的窗口，这里可以直接点击确定关闭它。</li><li>此时出现这样的界面：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155957656082.jpg" alt="列表"><br>点在下载图标，下载这个 json 文件。名字类似与<code>client_secret_client-id.json</code></li></ol><p>最后上面下载的文件必须放到 pi 用户的 Downloads 目录下面以授权使 <code>Google Assistant SDK</code> 示例项目正常使用，不要重命名这个文件。<br>可以通过以下方法来将刚刚下载的文件传到 Downloads 目录。</p><ol><li>在你的电脑新打开一个终端，<strong>不要 ssh 连接 pi</strong>，输入以下命令：</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp <span class="regexp">~/Downloads/</span>client_secret_具体你的文件名.json pi<span class="meta">@raspberry</span>-pi-ip-<span class="string">address:</span><span class="regexp">/home/</span>pi/</span><br></pre></td></tr></table></figure><p>然后输入密码。</p><ol start="2"><li>如果你是 Windows，你可以使用 FileZilla 等 ftp 工具，如下:<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155961850035.jpg" alt=""><br>打开 Downloads 目录，将你的文件拖入即可。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155962460662.jpg" alt=""></li></ol><p>为了使用 Google Assistant 你必须要共享一些活动数据给 Google，授予 <code>Google Assistant</code> 一定的权限，否则你运行项目的时候，她会一直跟你说，她需要权限才能跟你说话。<br>打开<a href="https://myaccount.google.com/activitycontrols" target="_blank" rel="noopener">活动控制页面</a><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155964264654.jpg" alt=""><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155964345681.jpg" alt=""><br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155964424810.jpg" alt=""></p><h2 id="步骤四：安装-SDK-和示例项目"><a href="#步骤四：安装-SDK-和示例项目" class="headerlink" title="步骤四：安装 SDK 和示例项目"></a>步骤四：安装 SDK 和示例项目</h2><p>Google 推荐在 Python 的虚拟环境运行该项目，避免对系统环境造成影响，具体运行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> python3-dev python3-venv </span><br><span class="line">python3 -m venv env</span><br><span class="line">env/<span class="keyword">bin</span>/python -m pip <span class="keyword">install</span> <span class="comment">--upgrade pip setuptools</span></span><br><span class="line"><span class="keyword">source</span> env/<span class="keyword">bin</span>/<span class="keyword">activate</span></span><br></pre></td></tr></table></figure><p>上面的最后一条命令是激活虚拟环境，然后安装依赖软件包：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install portaudio19-<span class="built_in">dev</span> libffi-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>使用 pip 来安装最新版本的依赖包：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip <span class="keyword">install</span> <span class="comment">--upgrade google-assistant-library</span></span><br><span class="line">python -m pip <span class="keyword">install</span> <span class="comment">--upgrade google-assistant-sdk[samples]</span></span><br></pre></td></tr></table></figure><p>生成授权资格<br>首先安装及升级授权工具<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip <span class="keyword">install</span> <span class="comment">--upgrade google-auth-oauthlib[tool]</span></span><br></pre></td></tr></table></figure></p><p>然后在命令行输入一下命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">google-oauthlib-tool <span class="params">--scope</span> https:<span class="string">//www.googleapis.com/auth/assistant-sdk-prototype</span> \</span><br><span class="line">          <span class="params">--save</span> <span class="params">--headless</span> <span class="params">--client-secrets</span> <span class="string">/home/pi/Downloads/client_secret_</span>你的文件名<span class="string">.json</span></span><br></pre></td></tr></table></figure><p>然后你应该会在命令行中看到一个网址<br><code>Please visit this URL to authorize this application: https://...</code></p><p>将这个网址完整的 copy 到浏览器中，登陆你的 Google 账号，然后点击授权允许，你会在浏览器中看到一行代码，类似<code>4/XXXX</code>，将这行代码 copy 到命令行<code>Enter the authorization code:</code>的后面<br>如果授权成功，那么你会在类似下面的响应。<br><code>credentials saved: /path/to/.config/google-oauthlib-tool/credentials.json</code></p><h2 id="步骤五：注册你的硬件设备"><a href="#步骤五：注册你的硬件设备" class="headerlink" title="步骤五：注册你的硬件设备"></a>步骤五：注册你的硬件设备</h2><p>使用 Google 的注册工具，首先设备名最好是数字和字母的组合，首字段必须是数字或字母。<br>使用下面的命令格式注册：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">googlesamples</span><span class="literal">-</span><span class="comment">assistant</span><span class="literal">-</span><span class="comment">devicetool</span> <span class="comment">register</span><span class="literal">-</span><span class="comment">model</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">manufacturer</span> <span class="comment">生产者</span> <span class="comment">\</span></span><br><span class="line"><span class="comment"></span>          <span class="literal">-</span><span class="literal">-</span><span class="comment">product</span><span class="literal">-</span><span class="comment">name</span> <span class="comment">产品名</span> <span class="title">[</span><span class="literal">-</span><span class="literal">-</span><span class="comment">description</span> <span class="comment">my</span><span class="literal">-</span><span class="comment">product</span><span class="literal">-</span><span class="comment">description</span><span class="title">]</span> <span class="comment">\</span></span><br><span class="line"><span class="comment"></span>          <span class="literal">-</span><span class="literal">-</span><span class="comment">type</span> <span class="comment">device</span><span class="literal">-</span><span class="comment">type</span> <span class="title">[</span><span class="literal">-</span><span class="literal">-</span><span class="comment">trait</span> <span class="comment">支持的特性</span><span class="title">]</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">model</span> <span class="comment">我的设备</span></span><br></pre></td></tr></table></figure><p>上面的我的设备这个必须是一个唯一的名字，所以你可以使用你的项目 ID 作为前缀，下面的是 Google 的一个示例命令：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">googlesamples-assistant-</span><span class="string">devicetool </span><span class="string">register-model </span><span class="built_in">--manufacturer</span> <span class="string">"Assistant SDK developer"</span> \</span><br><span class="line">          <span class="built_in">--product-name</span> <span class="string">"Assistant SDK light"</span> <span class="built_in">--type</span> <span class="string">LIGHT </span><span class="built_in">--model</span> <span class="string">my-model</span></span><br></pre></td></tr></table></figure><p>然后使用以下命令向服务器查询你刚刚创建的设备：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">googlesamples-assistant-devicetool <span class="keyword">get</span> <span class="comment">--model my-model</span></span><br></pre></td></tr></table></figure><p>比如下面<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15155975614463.jpg" alt=""></p><h2 id="步骤六：运行示例代码"><a href="#步骤六：运行示例代码" class="headerlink" title="步骤六：运行示例代码"></a>步骤六：运行示例代码</h2><p>现在你就可以准备运行示例项目来和你的树莓派对话了，首先运行下面的命令：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">googlesamples</span><span class="literal">-</span><span class="comment">assistant</span><span class="literal">-</span><span class="comment">hotword</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">project_id</span> <span class="comment">你的项目</span> <span class="comment">iD</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">device_model_id</span>  <span class="comment">上一步创建的设备</span></span><br></pre></td></tr></table></figure><p>然后对着你的麦克风可以说话询问了，注意要是英文。激活的关键词是 <code>Ok Google</code> 或 <code>Hey Google</code>，你可以在终端中看到对话开始和结束的提示。</p><p>可以试着问问她你所在的城市的天气，让她唱首歌，让她叫你起床等等。</p><h2 id="步骤七：-其他"><a href="#步骤七：-其他" class="headerlink" title="步骤七： 其他"></a>步骤七： 其他</h2><p> 你还可以增加一个 LED 灯来为你的对话添加一些特性，通过 LED 灯提示对话开始等，也可以扩展这个项目及你的树莓派。具体的可以参考<a href="https://developers.google.com/assistant/sdk/guides/library/python/extend/install-hardware" target="_blank" rel="noopener">扩展 Google Assistant</a>。</p><p>以上就是变身 Google Home 的基本过程，下一步，我将我的树莓派变身成为智能家居中枢，让 Siri 为我开关灯！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;将你的树莓派变身-Google-Home&quot;&gt;&lt;a href=&quot;#将你的树莓派变身-Google-Home&quot; class=&quot;headerlink&quot; title=&quot;将你的树莓派变身 Google Home&quot;&gt;&lt;/a&gt;将你的树莓派变身 Google Home&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="硬件" scheme="http://suool.net/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="树莓派" scheme="http://suool.net/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾指南之使用 SSR 实现科学上网</title>
    <link href="http://suool.net/2018/01/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E4%BD%BF%E7%94%A8-SSR-%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://suool.net/2018/01/09/树莓派折腾指南之使用-SSR-实现科学上网/</id>
    <published>2018-01-09T11:50:57.000Z</published>
    <updated>2018-01-09T11:57:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树莓派折腾指南之使用-SSR-实现科学上网"><a href="#树莓派折腾指南之使用-SSR-实现科学上网" class="headerlink" title="树莓派折腾指南之使用 SSR 实现科学上网"></a>树莓派折腾指南之使用 SSR 实现科学上网</h1><p>p## 预备工作<br>首先确定你的 SSR 混淆加密方法，如果是 salsa20 或 chacha20 或 chacha20-ietf 就需要编译安装 libsodium 这个库。<br>其 github 地址是 <a href="https://github.com/jedisct1/libsodium/" target="_blank" rel="noopener">libsodium</a> ，编译安装的步骤如下：</p><p>首先安装 build-essential 软件包，其作用是提供编译程序必须软件包的列表信息，也即是，编译程序有了这个软件包它才能确定头文件在哪，才知道库函数在哪，还会下载依赖的软件包，最后才组成一个开发环境。<br>安装命令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><p>安装完成后，就是下载编译 libsodium 库了，首先你要去它的<a href="https://github.com/jedisct1/libsodium/releases" target="_blank" rel="noopener">发布页</a>，确定当前最新的发布版本，替代我下面的当前的 VERSION 。主要命令如下：</p><p>打开终端，首先定义两个变量，在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VERSION='1.0.15'</span><br><span class="line">CPUNUM=`cat /proc/cpuinfo | grep 'processor' | wc -l`</span><br></pre></td></tr></table></figure><p>然后回到当前根目录，下载及解压源码包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget -c "https://github.com/jedisct1/libsodium/releases/download/$&#123;VERSION&#125;/libsodium-$&#123;VERSION&#125;.tar.gz"  # 慢慢等</span><br><span class="line">tar xzf libsodium-$&#123;VERSION&#125;.tar.gz</span><br></pre></td></tr></table></figure><p>目录压栈，并进行编译安装，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushd libsodium-$&#123;VERSION&#125;</span><br><span class="line">./configure</span><br><span class="line">make -j$&#123;CPUNUM&#125;</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>出栈目录，并删除编译目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popd</span><br><span class="line">rm -rf libsodium-$&#123;VERSION&#125;*</span><br></pre></td></tr></table></figure><p>关于 pushd，popd 等目录操作命令，具体可以参见 <a href="http://www.361way.com/pushd/1118.html" target="_blank" rel="noopener">方便的目录切换——dirs、pushd、popd命令</a>。</p><h2 id="编译-SSR-及基本配置"><a href="#编译-SSR-及基本配置" class="headerlink" title="编译 SSR 及基本配置"></a>编译 SSR 及基本配置</h2><p>SSR 当前的 Python 版本的项目地址是 <a href="https://github.com/shadowsocksr-backup/shadowsocksr" target="_blank" rel="noopener">shadowsocksr</a> 。</p><p>首先安装 m2crypto，git，supervisor 等相关依赖软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install m2crypto git supervisor libevent-dev</span><br></pre></td></tr></table></figure><p>下载编译如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone -b manyuser https://github.com/shadowsocksr-backup/shadowsocksr</span><br><span class="line">cd ~/shadowsocksr</span><br><span class="line">bash initcfg.sh</span><br></pre></td></tr></table></figure><p>等待完成之后，编辑配置文件，在命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano user-config.json</span><br></pre></td></tr></table></figure><p>具体参数的意义及作用，参照 <a href="https://github.com/ssrbackup/shadowsocks-rss/wiki/config.json" target="_blank" rel="noopener">config.json</a> 。</p><p>local_address 和 local_port 不需要修改，其余的按照 Wiki 修改，基本上配置好： server 填服务器地址<br>server_port 填服务器端口<br>password 密码<br>method 加密方法<br>obfs 混淆插件<br>protocol 协议插件<br>等关键参数，具体看你的 SSR 服务端的设置。</p><p>编辑好后，运行一下命令测试一下是否能运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shadowsocks/local.py</span><br></pre></td></tr></table></figure><p>没报错的话 Ctrl+C 结束继续下一步，如果有报错继续改配置文件。</p><h2 id="协议转换代理"><a href="#协议转换代理" class="headerlink" title="协议转换代理"></a>协议转换代理</h2><p>因为 SS 系的协议走的是 Socks5 协议，对于 Terminal 的 get,wget 等走 Http 协议的地方是无能为力的，所以需要转换成 Http 代理。<br>此时可以选择使用 <a href="https://github.com/darkk/redsocks" target="_blank" rel="noopener">redsocks</a> 来实现。</p><p>下载编译的命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone https://github.com/darkk/redsocks</span><br><span class="line">pushd redsocks</span><br><span class="line">make</span><br><span class="line">cp redsocks.conf.example redsocks.conf</span><br><span class="line">sed -i "s/ip = example.org/ip = 127.0.0.1/" redsocks.conf</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><h2 id="SSR-开机自启"><a href="#SSR-开机自启" class="headerlink" title="SSR 开机自启"></a>SSR 开机自启</h2><p>首先新建一个用户专门用来运行 SSR 和 redsocks 的账号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -M -s /sbin/nologin ss</span><br></pre></td></tr></table></figure><p>然后使用 supervisor 守护进程和开机自启，直接将下面的命令全部粘贴进入命令行回车即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c "cat &gt; /etc/supervisor/conf.d/ss.conf" &lt;&lt;EOF</span><br><span class="line">[program:ss]</span><br><span class="line">directory = /home/pi/shadowsocksr/shadowsocks</span><br><span class="line">command = python /home/pi/shadowsocksr/shadowsocks/local.py</span><br><span class="line">autostart = true</span><br><span class="line">autorestart = true</span><br><span class="line">startsecs = 10</span><br><span class="line">startretries = 36</span><br><span class="line">user = ss</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile = /dev/null</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo bash -c "cat &gt; /etc/supervisor/conf.d/redsocks.conf" &lt;&lt;EOF</span><br><span class="line">[program:redsocks]</span><br><span class="line">directory = /home/pi/redsocks</span><br><span class="line">command = /home/pi/redsocks/redsocks -c /home/pi/redsocks/redsocks.conf</span><br><span class="line">autostart = true</span><br><span class="line">autorestart = true</span><br><span class="line">startsecs = 10</span><br><span class="line">startretries = 36</span><br><span class="line">user = ss</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile = /dev/null</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo supervisorctl update</span><br></pre></td></tr></table></figure><p>上面的配置把 log 全部扔掉了，如果有需要的可以自己改 stdout_logfile 项。</p><h2 id="设置-iptables-实现-nat-转发"><a href="#设置-iptables-实现-nat-转发" class="headerlink" title="设置 iptables 实现 nat 转发"></a>设置 iptables 实现 nat 转发</h2><p>主要步骤如下，<br>首先创建一个叫 REDSOCKS 的链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -N REDSOCKS</span><br></pre></td></tr></table></figure><p>然后进行基本的规则定制，首先忽略服务器的地址，下面的 server_ip 填服务器 ip 或域名，这里和 SSR 配置文件里的 server 值要一样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A REDSOCKS -d server_ip -j RETURN</span><br></pre></td></tr></table></figure><p>然后忽略本地地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN</span><br><span class="line">sudo iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN</span><br></pre></td></tr></table></figure><p>除了除上面之外的所有流量都转发到 socks 的本地端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345</span><br></pre></td></tr></table></figure><p>之后应用上面的规则,将 OUTPUT 出去的 tcp 流量全部经过 REDSOCKS 链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A OUTPUT -p tcp -j REDSOCKS</span><br></pre></td></tr></table></figure><p>保存规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c "iptables-save &gt; /etc/iptables.up.rules"</span><br></pre></td></tr></table></figure><h2 id="开机自动加载规则"><a href="#开机自动加载规则" class="headerlink" title="开机自动加载规则"></a>开机自动加载规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c "cat &gt; /etc/network/if-pre-up.d/iptables" &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">/sbin/iptables-restore &lt; /etc/iptables.up.rules</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>添加执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/network/if-pre-up.d/iptables</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl myip.ipip.net</span><br></pre></td></tr></table></figure><p>可以查看当前的ip，如果是你的服务器 IP 就表示可以了。<br>比如：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15154976353553.jpg" alt=""></p><h2 id="关闭全局代理"><a href="#关闭全局代理" class="headerlink" title="关闭全局代理"></a>关闭全局代理</h2><p>执行下面的命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的server_ip填服务器ip或域名，和上面添加的值要一样</span></span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d server_ip -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 0.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 10.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 127.0.0.0/8 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 169.254.0.0/16 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 172.16.0.0/12 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 192.168.0.0/16 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 224.0.0.0/4 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -d 240.0.0.0/4 -j RETURN</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D REDSOCKS -p tcp -j REDIRECT --to-ports 12345</span><br><span class="line">sudo iptables -t<span class="built_in"> nat </span>-D OUTPUT -p tcp -j REDSOCKS</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>更多关 iptables 的学习可以去 <a href="https://lesca.me/archives/iptables-nat-mangle-clear-rules.html" target="_blank" rel="noopener">iptables应用：NAT、数据报处理、清空iptables规则</a></p><h1 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h1><ol><li>实现了科学上网之后，下一步就可以 Google Assistant 的安装和试用，把你的树莓派变身成为一个 Google Home</li><li>接入 HomeKit，连入小米家具全家桶，让树莓派变身成为你的智能家居中枢。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树莓派折腾指南之使用-SSR-实现科学上网&quot;&gt;&lt;a href=&quot;#树莓派折腾指南之使用-SSR-实现科学上网&quot; class=&quot;headerlink&quot; title=&quot;树莓派折腾指南之使用 SSR 实现科学上网&quot;&gt;&lt;/a&gt;树莓派折腾指南之使用 SSR 实现科学上网&lt;/
      
    
    </summary>
    
      <category term="硬件" scheme="http://suool.net/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="树莓派" scheme="http://suool.net/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派折腾指南之系统安装及设备点亮</title>
    <link href="http://suool.net/2018/01/07/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AE%BE%E5%A4%87%E7%82%B9%E4%BA%AE/"/>
    <id>http://suool.net/2018/01/07/树莓派折腾指南之系统安装及设备点亮/</id>
    <published>2018-01-07T14:48:11.000Z</published>
    <updated>2018-01-07T15:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树莓派折腾指南之系统安装及设备点亮"><a href="#树莓派折腾指南之系统安装及设备点亮" class="headerlink" title="树莓派折腾指南之系统安装及设备点亮"></a>树莓派折腾指南之系统安装及设备点亮</h1><p>树莓派的系统安装方法有两种，一种是完全无头安装即不用网线，不用连接屏幕完成系统安装及设备正常点亮；一种是官方所提供的方式使用<code>NOOBS</code>辅助来安装。</p><p>在我看来，直接无头安装是最快捷的，不需要额外的设备，不需要额外的系统，不需要那么多操作，也减少了出错的可能。所以，这里推荐大家直接使用屋无头安装的方式。</p><h2 id="无头安装速成指南"><a href="#无头安装速成指南" class="headerlink" title="无头安装速成指南"></a>无头安装速成指南</h2><p>所谓速成，是因为在30分钟以内你就能进入到自己的树莓派中一探其中的究竟了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>所需设备及材料：</p><ol><li>树莓派</li><li>SD 卡（起码 8G 以上）</li></ol><p>当然还有计算机，以及一台正常工作的路由器。</p><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>首先在你的计算机上前往官网选择需要下载的树莓派官方支持系统：<code>RASPBIAN</code> （当然还有一系列其他类型的系统也可在官网找到）。</p><p>官方系统的下载地址是 <a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="noopener">RASPBIAN</a> ,官方提供两种系统版本，一是 WITH DESKTOP 即配置了桌面 GUI 环境的操作系统，另一个是 LITE 版本无桌面的最小版本。</p><p>目前的系统版本及相关内容如下：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153326797958.jpg" alt=""></p><p>这里可以根据你的需要选择，如果是新手，推荐选择桌面版本。</p><p>下载好系统包之后，下一步就是将系统烧录进入 SD 卡内，可以选择使用官方推荐的系统烧录工具 <a href="https://etcher.io/" target="_blank" rel="noopener">Etcher</a> ，点击上链接进入官网下载对应系统的版本即可，我这里使用的是 Mac 所以下载的 macOS 版本，下载完成之后安装并启动 Etcher。</p><p>Etcher 的使用基本是傻瓜式的，如其在官网的动图所示，首先选择你刚刚下载的系统包，然后将你 SD 卡插入 USB 读卡器中，并将读卡器接入电脑，点击 <code>Select drive</code> 选择你插入的 USB 设备，点击 <code>Flash</code> 即进入烧录系统的过程了。<br>这个过程快慢取决于烧录速度，静静等待它烧录完成就行了。</p><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153330485682.jpg" alt=""></p><p>烧录完成之后，仅仅是完成了系统安装的第一步。</p><h2 id="启动系统前的基本配置"><a href="#启动系统前的基本配置" class="headerlink" title="启动系统前的基本配置"></a>启动系统前的基本配置</h2><p>在烧录完成之后，需要重新挂载刚刚携带 SD 卡的 USB 设备，打开其中的 <code>boot</code> 分区（文件夹），做以下三步操作</p><ol><li>打开 <code>boot</code> 文件夹内 <code>config.txt</code>  文件，如果是桌面版本需要将 <code>#hdmi_safe=1</code> 取消注释，即去掉前面的 <code>#</code></li><li>在 <code>config.txt</code> 同级目录下使用任一文本编辑器(UTF-8编码）新建一个名字是 <code>ssh</code> 的空白文件，无文件后缀名</li><li>在 <code>config.txt</code> 同级目录下新建一个名为 <code>wpa_supplicant.conf</code> 的文件，内容如下：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">country</span>=GB</span><br><span class="line"><span class="attribute">ctrl_interface</span>=DIR=/var/run/wpa_supplicant <span class="attribute">GROUP</span>=netdev</span><br><span class="line"><span class="attribute">update_config</span>=1</span><br><span class="line">network=&#123;</span><br><span class="line">    <span class="attribute">ssid</span>=<span class="string">"你的Wifi名称，最好不含中文"</span></span><br><span class="line">    <span class="attribute">psk</span>=<span class="string">"你的Wifi密码"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三步缺一不可。第一步是为了保证以后使用 HDMI 接入屏幕的时候有视频信号，第二步是为了能够使用 <code>ssh</code> 登录你的树莓派，第三步则保证你的树莓派一开机能够自动连接上你的路由器。</p><p>现在就完成了系统安装，选择弹出你的 sd 卡设备，将其插入到树莓派中。</p><p>系统启动后，上述刚刚新建的这两个文件都会被删除。如果你改了 Wifi 密码，还可以再做一次。</p><h2 id="启动树莓派并SSH远程登录系统"><a href="#启动树莓派并SSH远程登录系统" class="headerlink" title="启动树莓派并SSH远程登录系统"></a>启动树莓派并SSH远程登录系统</h2><p>将 SD 卡插入到树莓派后，将树莓派接通电源等待它自动开机，这里你可以使用 HDMI 线连接显示器以查看其启动结果，当然如果你有自信可以完全不用连接上显示器，直接使用 <code>ssh</code> 登录到树莓派内。</p><p>那么如何确定树莓派是否连接上了路由器呢？可以根据其是否在路由器内分配了 IP 地址来确定，这里有两种方法：</p><ol><li>直接进入到路由器的管理中心，比如使用浏览器打开 <code>http://192.168.1.1</code> ，查看已连接的设备中是否有一个名为 <code>raspberrypi</code> 的设备，查看其分配的路由器 IP 地址<br>如下图：<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153343484307.jpg" alt=""></li><li>如果你的计算机是 <code>*nix</code> 设备，在终端使用 <code>arp -a</code>  命令，查看当前的路由中所有已连接的 IP 地址<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153344267473.jpg" alt=""></li></ol><p>找到了 IP 地址之后就可以使用 ssh 登陆到树莓派了，在 Mac 中使用终端即可，其步骤如下图<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153347383609.jpg" alt=""><br>注意用户名是 <code>pi</code>，点击连接即可，这里可能需要你添加 key 到本地 <code>know_host</code><br>中，输入 <code>yes</code> 即可。Windows 可以使用 <code>putty</code>，具体的操作这里不再赘述。</p><p><strong>默认的 <code>pi</code> 用户的密码是 <code>raspberry</code>。</strong></p><p>当然对于 macOS 或 linux 还有一种更加直接方便的 <code>ssh</code> 登陆方式，不需要 IP 地址，直接等树莓派通电启动之后，在终端内输入 <code>ssh pi@raspberrypi.local</code> 即可。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153349649992.jpg" alt=""></p><p>如果出现上界面即表示树莓派已经成功启动系统了。</p><h2 id="使用-VNC-远程登录"><a href="#使用-VNC-远程登录" class="headerlink" title="使用 VNC 远程登录"></a>使用 VNC 远程登录</h2><p>如果你安装的是带桌面版本的树莓派，可以使用 VNC 远程登录桌面环境而不必需要额外的 HDMI 设备线连接屏幕、额外的键鼠连接树莓派。</p><p>如何使用 VNC 呢？</p><p>首先在 ssh 登陆进入树莓派之后，先对系统进行基本的配置，第一个就是换源，因为国内网络环境导致从官方的地址来安装和更新软件及系统速度可能会非常慢，这里讲软件源换成国内的镜像源，比如阿里云的，其步骤如下：</p><p>在 ssh 终端中输入 <code>sudo nano /etc/apt/sources.list</code><br>可以直接删除原有的内容，也可以在前面加上 # 将其注释掉，然后在下面加入两行。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb <span class="symbol">http:</span>/<span class="regexp">/mirrors.aliyun.com/raspbian</span><span class="regexp">/raspbian/</span> stretch main non-free contrib rpi</span><br><span class="line">deb-src <span class="symbol">http:</span>/<span class="regexp">/mirrors.aliyun.com/raspbian</span><span class="regexp">/raspbian/</span> stretch main non-free contrib rpi</span><br></pre></td></tr></table></figure></p><p>然后输入 <code>sudo apt-get update</code> 更新软件索引清单，<br>输入 <code>sudo apt-get upgrade</code> 更新相关软件依赖。</p><p>完成之后输入 <code>sudo apt-get install tightvncserver</code> 为树莓派安装 VNC 服务，安装完成之后输入 <code>tightvncserver</code>，这里会需要你输入 VNC 连接密码，确定输入即可，启动 VNC 服务。</p><p>Mac 中，在文件夹 <code>Finder</code> 的菜单中，打开前往下的连接服务器，然后输入 <code>vnc://树莓派IP地址:5901</code> ,其中5901是默认的端口。<br><img src="http://7xjsv3.com1.z0.glb.clouddn.com/15153356804072.jpg" alt=""><br>点击连接，输入你刚刚确定的密码，即可完成连接，看到你的树莓派桌面环境。</p><p>好了，这就是系统安装的基本过程，下一步是更深入的折腾的过程。</p><ol><li>使用 <code>SSR</code> 全局代理，让树莓派自由访问网络。</li><li>使用树莓派接入 <code>Google Assistant</code>，实现一个树莓派版的 <code>Google Home</code>。</li><li>使用树莓派接入有线音箱，将其变成无线音箱。</li><li>将树莓派安装 <code>Homebridge</code>，使你的 iPhone 连接你的智能设备。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树莓派折腾指南之系统安装及设备点亮&quot;&gt;&lt;a href=&quot;#树莓派折腾指南之系统安装及设备点亮&quot; class=&quot;headerlink&quot; title=&quot;树莓派折腾指南之系统安装及设备点亮&quot;&gt;&lt;/a&gt;树莓派折腾指南之系统安装及设备点亮&lt;/h1&gt;&lt;p&gt;树莓派的系统安装方法
      
    
    </summary>
    
      <category term="硬件" scheme="http://suool.net/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="树莓派" scheme="http://suool.net/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>云南五天四晚游</title>
    <link href="http://suool.net/2016/12/28/%E4%BA%91%E5%8D%97%E4%BA%94%E5%A4%A9%E5%9B%9B%E6%99%9A%E6%B8%B8/"/>
    <id>http://suool.net/2016/12/28/云南五天四晚游/</id>
    <published>2016-12-28T06:22:41.000Z</published>
    <updated>2016-12-30T01:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些基本原则："><a href="#一些基本原则：" class="headerlink" title="一些基本原则："></a>一些基本原则：</h2><ol><li><em>一定要防晒，不要问我为什么。</em></li><li><em>不推荐在古城买东西，不管是丽江古城，还是束河古镇，还是大理古城，里面东西不保证真假，而且价格虚高。</em></li><li><em>需要买东西可以直接去当地的超市或者批发市场，买东西都要杀价，觉得贵的直接对半砍价。</em></li><li><em>当地的昼夜温差很大，白天可以穿少点，晚上回来晚的话一定要带多点衣服，不然要冻成狗。</em></li><li><em>出行可以选择滴滴打车</em></li></ol><a id="more"></a><h2 id="液体随身-乘机"><a href="#液体随身-乘机" class="headerlink" title="液体随身(乘机)"></a>液体随身(乘机)</h2><ol><li>爽肤水 </li><li>防晒霜 </li><li>柔肤水 </li><li>护手霜 </li><li>隔离霜 </li><li>遮瑕霜 </li><li>洗面奶 </li><li>面霜 </li><li>洗头水 </li><li>沐浴露</li><li>精华液</li><li>身体乳</li><li>卸妆水</li></ol><p>PS： 坐飞机的话，注意每种不能带超过一百毫升，最好买分装瓶，我们买的是四合一那种的，买四个（16小瓶）就足够了，以后还能循环利用，并且这个要放在外面，乘飞机的时候拿出来安检。</p><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p>初步规划7号下午下班后出发去广州, 在广州机场附近休息一下, 在12号凌晨4:00左右赶往机场候机.<br>计划于12号从丽江机场返回广州.</p><p>中间的行程：</p><ul><li><em>8号安排</em></li></ul><p><code>早上9:30</code>飞机抵达到达丽江，预估10:30到达古城，去宾馆休息整顿之后。<br>下午和晚上可以逛一下古城及周边地区。<br>晚上<code>住在丽江</code></p><p>PS：束河古镇，从北门进入不需要门票</p><p>PPS： 丽江古城，晚上去比较好，而且晚上七点之后去不再需要门票。</p><hr><ul><li><em>9号安排</em></li></ul><p><code>早上9点</code>出发去玉龙雪山<code>(一小时车程)</code><br><code>上午10点到下午4点</code>游玩玉龙雪山。<br><code>下午5点</code>回程丽江。<br><code>晚上7点</code>出发去丽江火车站<br><code>晚上8点</code>坐火车出发去大理<code>(两个小时车程)</code><br><code>晚上10点</code>到大理<br>晚上<code>住在大理</code></p><p>PS：强烈推荐直接<em>报纯玩的一日团</em>（我们包的一个人580，相对于自己组织和购买门票等费用没差多少），包车来回，提供羽绒服和氧气，中午还有顿本地农家饭，我们体验的感觉很不错。不建议自己坐大巴或者其他包车方式。</p><p>PPS：关于登玉龙雪山</p><ol><li><em>氧气：</em>上雪山一定要备好氧气，学会如何使用氧气，有高原反应不能硬撑的，最好出发前几日就吃红景天，出发前一晚一定要休息好。</li><li><em>药物：</em>最好备用感冒药、头痛药、止吐药如维生素B6，不然到时一旦高原反应，又吐有头痛，没有药会很难受。</li><li><em>食物：</em>最好带点高热量的食物，比如巧克力，带点热水。</li><li><em>莫急：</em>登山的时候千万不能过赶，高原氧气本来就稀薄，一旦运动过赶，会严重的缺氧头晕。</li></ol><hr><ul><li><em>10号安排</em></li></ul><p>10号一天在洱海游玩（洱海周边）<br>晚上<code>住在大理</code></p><p>PS：推荐租小电驴，一天60块钱，可以骑车绕着环海西线或者东线转，去喜洲和海舌公园看日落与洱海的黄昏，非常值得一看。但是记得穿多点衣服，晚上的洱海旁边会非常非常非常的冷，海风也非常非常非常的大。如果条件允许，直接租一个小电车也是很不错的选择，不过预算可能需要多一点。</p><p>PPS：推荐住洱海边的民宿，大理古城附近的青旅和客栈都是酒店那个样子，不如直接去 Airbnb 上找靠海边的民宿是最好的，一晚上100块左右。民宿非常有当地特色而且安静。</p><hr><ul><li><em>11号安排</em></li></ul><p>离开洱海。<br>第一个推荐去的地方是<code>崇圣寺</code>，电视剧中经常出现的<code>大理国</code>很多镜头都是在这里，<code>三塔映月</code>及最大的佛教寺庙——<em>佛都</em>。<br>门票可以自己美团上定优惠票一个人88，官方价要121。<br>其次古城可以晚上去看，主要是买买买了。</p><p>晚上<code>住在大理古城附近</code></p><hr><ul><li><em>12号安排</em></li></ul><p><code>早上9:00</code>坐火车出发去丽江<code>(三个小时车程)</code><br><code>下午1:00</code>拉市海游玩<br><code>晚上9:00</code>到机场候机<br><code>晚上11:10</code>飞机回广州</p><p>PS：游玩拉市海可以直接报团，也可以自己找个车来回，自己去的时候选线路之后记得砍价，而且冬季的话，玩那个线路都没什么差别…山上差不多都没什么东西，就骑马转一圈。砍价的空间非常的大….</p><p>PPS：买拉市海的票记得要求他包括划船的费用，去拉市海划船，看海鸟很不错。</p><p>PPPS: 可以试一下那边的高山茶，很不错，买的时候也要杀价。对半砍都可以。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些基本原则：&quot;&gt;&lt;a href=&quot;#一些基本原则：&quot; class=&quot;headerlink&quot; title=&quot;一些基本原则：&quot;&gt;&lt;/a&gt;一些基本原则：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;em&gt;一定要防晒，不要问我为什么。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;不推荐在古城买东西，不管是丽江古城，还是束河古镇，还是大理古城，里面东西不保证真假，而且价格虚高。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;需要买东西可以直接去当地的超市或者批发市场，买东西都要杀价，觉得贵的直接对半砍价。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;当地的昼夜温差很大，白天可以穿少点，晚上回来晚的话一定要带多点衣服，不然要冻成狗。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;出行可以选择滴滴打车&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 引导图组件使用文档</title>
    <link href="http://suool.net/2016/12/05/iOS-%E5%BC%95%E5%AF%BC%E5%9B%BE%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>http://suool.net/2016/12/05/iOS-引导图组件使用文档/</id>
    <published>2016-12-05T02:48:04.000Z</published>
    <updated>2016-12-05T03:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-引导图组件使用文档"><a href="#iOS-引导图组件使用文档" class="headerlink" title="iOS 引导图组件使用文档"></a>iOS 引导图组件使用文档</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h3><ul><li>引导图实际显示效果截图如下:</li></ul><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/2016120576244Simulator Screen Shot Dec 5, 2016, 9.43.40 AM.png" alt="引导图示例.png"></p><ul><li>引导图的动态显示效果如下视频：<br><a href="https://appetize.io/embed/29xabc89e2u0j8uh3y0dkkk0yg?device=iphone5s&amp;scale=75&amp;orientation=portrait&amp;osVersion=9.3" target="_blank" rel="noopener">引导图 Live Video</a></li></ul><a id="more"></a><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当 APP 第一次安装启动或者大版本更新第一次启动的时候，运营有新的引导图介绍 APP 的重点功能或更新的，需要使用引导图完成。</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>本引导图组件基于 <a href="https://github.com/squarezw/ZWIntroductionViewController" target="_blank" rel="noopener">ZWIntroductionViewController</a>修改。</p><p>只要设置引导图组件的 cover images ，初始化后将其加入到APPDelegate 的window即可， 对 APP 侵入性小，使用灵活。</p><h2 id="使用文档"><a href="#使用文档" class="headerlink" title="使用文档"></a>使用文档</h2><ul><li>首先是滑动的需求：<br>在组件的<code>ZWIntroductionViewController</code>类中的<code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</code>方法中几行关键代码：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当滑动到最后一个的时候,禁止左滑动,只能通过点击按钮来去除引导图</span></span><br><span class="line"><span class="built_in">CGFloat</span> x = (_pageControl.numberOfPages<span class="number">-1</span>) * YYScreenSize().width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (scrollView.contentOffset.x&gt;x) &#123;</span><br><span class="line">    [scrollView setContentOffset:<span class="built_in">CGPointMake</span>(x, scrollView.contentOffset.y) animated:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个的时候不能右滑动</span></span><br><span class="line"><span class="keyword">if</span> (scrollView.contentOffset.x&lt;=<span class="number">0.0</span>) &#123;</span><br><span class="line">    [scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0.0</span>, scrollView.contentOffset.y) animated:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码是控制在引导图第一页的时候不能向右滑动，在最后一页的时候不能通过继续左滑结束引导，只能通过点击按钮进入 APP 中。<br>（如果没有以上需求，将代码注释即可。）</p><ul><li>其次是指示器颜色和进入按钮的需求：<br>如果对于<code>pageControl</code>的指示器颜色有特殊的需求，比如需要指示器的颜色及进入 APP 的按钮样式，需要修改<code>ZWIntroductionViewController</code>类中的<code>- (void)viewDidLoad</code>方法，指示器颜色修改具体的代码如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.pageControl.pageIndicatorTintColor = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line"><span class="keyword">self</span>.pageControl.currentPageIndicatorTintColor = GlobalColor;</span><br></pre></td></tr></table></figure><p>按钮相关的修改如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.enterButton setTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"立即体验"</span>, <span class="literal">nil</span>) forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[<span class="keyword">self</span>.enterButton setTitleColor:GlobalColor forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">self</span>.enterButton.layer.borderWidth = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">self</span>.enterButton.layer.cornerRadius = <span class="number">20.0</span>;</span><br><span class="line"><span class="keyword">self</span>.enterButton.layer.borderColor = GlobalColor.CGColor;</span><br></pre></td></tr></table></figure><ul><li>最后是使用的规范：<br>下面是一个使用示例：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)isFirstLaunch&#123;</span><br><span class="line">    <span class="keyword">if</span>(![[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@"firstStart_V2"</span>])&#123;</span><br><span class="line">  <span class="comment">// 如果是第一次启动，设置对应的版本标示</span></span><br><span class="line">        [[LSUserDefaults sharedInstance]setNewVeisonCode:<span class="string">@"1"</span>];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:<span class="literal">YES</span> forKey:<span class="string">@"firstStart_V2"</span>];</span><br><span class="line">  <span class="comment">// 设置引导图的图片</span></span><br><span class="line">        <span class="built_in">NSArray</span> *coverImageNames = @[<span class="string">@"leadPage_1"</span>, <span class="string">@"leadPage_2"</span>, <span class="string">@"leadPage_3"</span>,<span class="string">@"leadPage_4"</span>];</span><br><span class="line">  <span class="comment">// 初始化引导图组件</span></span><br><span class="line">        <span class="keyword">self</span>.introductionView = [[ZWIntroductionViewController alloc] initWithCoverImageNames:coverImageNames backgroundImageNames:<span class="literal">nil</span>];</span><br><span class="line">  <span class="comment">// 添加组件</span></span><br><span class="line">        [<span class="keyword">self</span>.window addSubview:<span class="keyword">self</span>.introductionView.view];</span><br><span class="line">        __<span class="keyword">weak</span> AppDelegate *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">  <span class="comment">// 引导完成后的回调</span></span><br><span class="line">        <span class="keyword">self</span>.introductionView.didSelectedEnter = ^() &#123;</span><br><span class="line">            [weakSelf.introductionView.view removeFromSuperview];</span><br><span class="line">            weakSelf.introductionView = <span class="literal">nil</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个使用的过程如上代码所示。</p><p><em>以上就是引导图组件的文档说明</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-引导图组件使用文档&quot;&gt;&lt;a href=&quot;#iOS-引导图组件使用文档&quot; class=&quot;headerlink&quot; title=&quot;iOS 引导图组件使用文档&quot;&gt;&lt;/a&gt;iOS 引导图组件使用文档&lt;/h1&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;h3 id=&quot;实际效果&quot;&gt;&lt;a href=&quot;#实际效果&quot; class=&quot;headerlink&quot; title=&quot;实际效果&quot;&gt;&lt;/a&gt;实际效果&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;引导图实际显示效果截图如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7xjsv3.com1.z0.glb.clouddn.com/2016120576244Simulator Screen Shot Dec 5, 2016, 9.43.40 AM.png&quot; alt=&quot;引导图示例.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引导图的动态显示效果如下视频：&lt;br&gt;&lt;a href=&quot;https://appetize.io/embed/29xabc89e2u0j8uh3y0dkkk0yg?device=iphone5s&amp;amp;scale=75&amp;amp;orientation=portrait&amp;amp;osVersion=9.3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引导图 Live Video&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://suool.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://suool.net/tags/iOS/"/>
    
      <category term="组件文档" scheme="http://suool.net/tags/%E7%BB%84%E4%BB%B6%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>iOS网络层说明</title>
    <link href="http://suool.net/2016/11/30/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%B4%E6%98%8E/"/>
    <id>http://suool.net/2016/11/30/iOS网络层说明/</id>
    <published>2016-11-30T08:44:02.000Z</published>
    <updated>2016-12-05T02:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-网络层文档"><a href="#iOS-网络层文档" class="headerlink" title="iOS 网络层文档"></a>iOS 网络层文档</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>iOS 的网络层使用 <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a>作为网络层底层架构，在  <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a>的<code>YTKRequest</code>类和具体的业务请求层之间架设了一个中间业务类<code>LSBaseRequest</code>，所有具体的 API 请求都继承于此类。</p><p>关于 <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a> </p><blockquote><p>YTKNetwork主要用于请求的发送及回调处理，YTKNetwork 的基本的思想是把每一个网络请求封装成对象。使用 YTKNetwork，每一个请求都需要继承 YTKRequest 类，通过覆盖父类的一些方法来构造指定的网络请求。</p></blockquote><p>这里为了避免我们具体业务类的相关回调逻辑与 YTKNetwork 耦合过高，所以封装了<code>LSBaseRequest</code>来处理请求回调的公共逻辑。</p><p>下面来一一说明。</p><a id="more"></a><h2 id="LSBaseRequest-类的设计"><a href="#LSBaseRequest-类的设计" class="headerlink" title="LSBaseRequest 类的设计"></a>LSBaseRequest 类的设计</h2><p><img src="http://7xjsv3.com1.z0.glb.clouddn.com/2016113096998iOS Network.png" alt="iOS Network.png"></p><p>继承关系及中间层的 <code>BaseRequest</code>  的设计如上图所示。</p><h3 id="基本的原理和字段说明："><a href="#基本的原理和字段说明：" class="headerlink" title="基本的原理和字段说明："></a>基本的原理和字段说明：</h3><p>首先一个请求的回调都是直接一个 JSON 的字符串，网络层的底层可以将这个字符串转化为<code>NSDictionary</code>类型的数据，这个是请求回调的第一次处理得到的数据。处理的具体过程如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处是在网络请求完成的回调方法内拿到responseString的回调字符串的处理</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="keyword">self</span>.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  DDLogError(<span class="string">@"返回内容为空."</span>);</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果 API 的请求没有特殊的要求，可能直接拿到这个 <code>data</code>数据来提供给 ViewController 使用。</p><p>但是，一般的请求并不会简单的直接要求<code>NSMutableDictionary</code>的 <code>data</code>数据，ViewController 希望能够直接拿到其需要的数据类型。而展示数据一般也只需要两种类型，分别是展示一个列表数据和展示一个实体模型的数据。所以业务请求 API 能够自己处理回调数据的“深加工”是View 和 ViewController希望看到的。因此，这里直接给 <code>BaseRequest</code>添加了两个属性，分别是泛型的回调列表数据和泛型的实体模型数据，而<code>NSDictionary</code>类型的<code>resultDic</code>属性是第一次处理的结果。</p><p>根据以上的需求，具体的业务请求的 API 都会具有三种附加的状态属性，分别是该请求是否需要登录，该请求是否需要一个列表的回调数据，该请求是否需要一个实体模型的回调数据。在初始化具体的 API 请求的时候就会对这三个属性进行初始化。</p><p>具体的对应数属性是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isLogin;  <span class="comment">// 是否需登录</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isRetAry; <span class="comment">// 是否需要返回数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isRetObj; <span class="comment">// 是否需要返回实体 model</span></span><br></pre></td></tr></table></figure><p>所以<code>BaseRequest</code>的对外暴露的方法也只有三个，此处甚至可以减少到两个，即是所有的 API 请求自己处理自己的初始化，而不是像上面的使用中间类的初始化方法。</p><p>而 API 的初始化方法中，需要传入该 API 请求需要的参数及其相关的状态属性。请求参数会根据请求的登录状态属性来决定是否添加<code>AccessToken 参数</code>。</p><p>在具体的发送 API 请求的时候，会根据以上三个状态属性来确定如何发送请求，具体的处理逻辑如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startRequest&#123;</span><br><span class="line">    sendCount ++; <span class="comment">// 请求重发的次数</span></span><br><span class="line">    <span class="built_in">BOOL</span> isOnline = [[LSUserDefaults sharedInstance] isOnLine];</span><br><span class="line">    <span class="keyword">if</span> (_isLogin &amp;&amp; isOnline) &#123;  <span class="comment">// 需要登录且目前用户已经登录</span></span><br><span class="line">        [<span class="keyword">self</span> start];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(_isLogin &amp;&amp; !isOnline) &#123; <span class="comment">// 需要登录但目前用户并没有登录</span></span><br><span class="line">        <span class="keyword">self</span>.failure(@&#123;<span class="string">@"code"</span> : NoLogin&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!_isLogin) &#123;         <span class="comment">// 不需要登录，直接登录</span></span><br><span class="line">        [<span class="keyword">self</span> start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求完成之后的公共逻辑处理在<code>requestCompleteFilter</code>和<code>requestFailedFilter</code>回调方法中实现，这两个回调方法是 YTKNetwork 中暴露出来给请求结果回调处理使用的。</p><p>而一旦请求发送成功，获得回调数据之后，回调数据统一处理逻辑会根据 API 初始化携带的状态来加工回调数据，具体如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestCompleteFilter&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span>.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">  <span class="comment">// 初次加工数据</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSEnumerator</span> *enumerator = [dictionary keyEnumerator];</span><br><span class="line">        <span class="built_in">NSString</span> *key = <span class="string">@"code"</span>;</span><br><span class="line">        <span class="keyword">int</span> code = [dictionary[key] intValue];</span><br><span class="line">        <span class="built_in">BOOL</span> isExist = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">while</span> ((key = [enumerator nextObject])) &#123;</span><br><span class="line">            isExist = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">                    <span class="keyword">if</span> (_isRetAry) &#123; <span class="comment">// 如果要求返回的是数组，则在具体的 API 中再次深加工数据，并将加工之后的数据回调</span></span><br><span class="line">                        <span class="keyword">self</span>.successArray(<span class="keyword">self</span>.resultData);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_isRetObj) <span class="comment">// 如果要求返回的是实体，则在具体的 API 中再次深加工数据，并将加工之后的数据回调</span></span><br><span class="line">                        <span class="keyword">self</span>.successObject(<span class="keyword">self</span>.model);</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// 如果要求返回没有额外的要求，则在数据回调中直接将初加工数据回调</span></span><br><span class="line">                        <span class="keyword">self</span>.success(dictionary);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 请求成功但是获取的不是预期的成功数据</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">801</span>:&#123;</span><br><span class="line">                    <span class="comment">// 访问令牌失效，重新获取</span></span><br><span class="line">                    [<span class="keyword">self</span> requestTokenWithRetArray:_isRetAry retObj:_isRetObj];</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">802</span>:</span><br><span class="line">                    [[PMStore store] removeUserDataAndLogOff];</span><br><span class="line">                    <span class="keyword">self</span>.failure(dictionary);</span><br><span class="line">  <span class="comment">// 其他情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"服务暂时不可用，请稍后重试"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// 请求成功但是没有获取到数据</span></span><br><span class="line">        DDLogWarn(<span class="string">@"self.success(nil)"</span>);</span><br><span class="line">        <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"服务暂时不可用，请稍后重试"</span>&#125;);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的深加工过程，在具体的 API 类中再做介绍。</p><p>请求发送失败的公共处理逻辑：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestFailedFilter &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span>.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">self</span>.failure(dictionary);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        DDLogError(<span class="string">@"返回内容为空."</span>);</span><br><span class="line">        <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"服务暂时不可用，请稍后重试"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处在请求成功发送并获取回调之后，会出现一种特殊的情况（上面 Code 为801 的情况）：如果该请求需要登录状态，即是会携带<code>AccessToken</code>来发送请求，但是请求的结果是服务端提示<code>AccessToken</code>过期，此时不能立即回调该结果给 API 的调用者，而是要发送一个<code>LSServerTokenAPI</code>请求来尝试跟服务端请求换取新的<code>AccessToken</code>，如果服务端成功的返回了新的<code>AccessToken</code>，则应该让该请求重新携带新的<code>AccessToken</code>重发请求数据。如果没有获取到新的<code>AccessToken</code>，则此时应该失败回调给调用者，告诉调用者该用户已经掉线，需要重新登录才能继续请求。<br>此处的具体处理逻辑代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestTokenWithRetArray:(<span class="built_in">BOOL</span>)isAry retObj:(<span class="built_in">BOOL</span>)isObj&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *requrestDic = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:<span class="keyword">self</span>.requestArgument];</span><br><span class="line">    <span class="comment">// accessToken 过期</span></span><br><span class="line">    LSServerTokenAPI *accessAPI = [[LSServerTokenAPI alloc]init];</span><br><span class="line">    [accessAPI startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123;   <span class="comment">// 此处是直接使用的 YTKRequest 的回调方法</span></span><br><span class="line">        <span class="comment">// you can use self here, retain cycle won't happen</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</span><br><span class="line">        <span class="built_in">NSData</span> *data = [request.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dic = (<span class="built_in">NSDictionary</span> *)dictionary[<span class="string">@"data"</span>][<span class="string">@"result"</span>];</span><br><span class="line">        HNUserModel *user = [HNUserModel mj_objectWithKeyValues:dic];</span><br><span class="line">        <span class="keyword">if</span> (user.accessToken) &#123;   <span class="comment">// 如果换取到新的 Token</span></span><br><span class="line">            [[PMStore store]saveDataWithUserInfo:user];</span><br><span class="line">            requrestDic[<span class="string">@"accessToken"</span>] = user.accessToken;</span><br><span class="line">            <span class="keyword">self</span>.baseRequestArgument = requrestDic;</span><br><span class="line">            <span class="keyword">if</span> (sendCount &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"重发系统错误，请稍后重试"</span>&#125;);  <span class="comment">// 重发最多三次，多余三次的直接回调失败</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               [<span class="keyword">self</span> startRequest];  <span class="comment">// 重发该请求</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            [[PMStore store] removeUserDataAndLogOff];</span><br><span class="line">            <span class="keyword">self</span>.failure(@&#123;<span class="string">@"code"</span> : NoLogin&#125;);  <span class="comment">// 没有获取到新的 Token，回调数据登录失效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(YTKBaseRequest *request) &#123;</span><br><span class="line">        <span class="comment">// you can use self here, retain cycle won't happen</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</span><br><span class="line">        <span class="built_in">NSData</span> *data = [request.responseString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *dictionary = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">            DDLogError(<span class="string">@"发送请求更新 accessToken 失败，返回内容：\n%@"</span>,dictionary);</span><br><span class="line">            <span class="keyword">self</span>.failure(dictionary);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.failure(@&#123;<span class="string">@"msg"</span> : <span class="string">@"刷新 Token 系统错误，请稍后重试"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是为了避免无限的循环调用，<code>LSServerTokenAPI</code>本身不是<code>LSBaseRequest</code>类型的，而是和<code>LSBaseRequest</code>一样都是直接继承自<code>YTKRequest</code>的，因此此处的<code>LSServerTokenAPI</code>请求的回调不会再次经过<code>LSBaseRequest</code> 在<code>requestCompleteFilter</code>和<code>requestFailedFilter</code>回调方法中的公共逻辑，而是直接调用的<code>startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success failure:(YTKRequestCompletionBlock)failure</code>方法处理数据回调数据。</p><h2 id="operationAPI-类的设计"><a href="#operationAPI-类的设计" class="headerlink" title="operationAPI 类的设计"></a>operationAPI 类的设计</h2><p>具体的业务类非常的简单，因此非常多的回调处理逻辑都在<code>LSBaseRequest</code>内部完成处理了。<br>如果需要创建一个新的业务请求 API，只要创建一个继承自<code>LSBaseRequest</code>的 API 类，在类的头文件声明中，除特殊情况外，不需要做任何的处理，比如一个典型的请求个人信息的 API 接口声明如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">HNUserInfoAPI </span>: LSBaseRequest</span><br><span class="line"><span class="comment">// 此处一般不需要声明任何额外的属性和方法</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>  而具体业务的 API 实现，也只需要配置该 API 的 URL，API 的请求方式即可。</p><h3 id="额外的数据逻辑处理需求"><a href="#额外的数据逻辑处理需求" class="headerlink" title="额外的数据逻辑处理需求"></a>额外的数据逻辑处理需求</h3><p>如果该 API 请求对于回调数据有特殊的加工需求：</p><ul><li>需要一个列表数据，则会增加下面这些处理逻辑，实现<code>LSBaseRequest</code>的<code>resultData</code>的获取方法 ，比如请求交易记录的 API ：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处是实现LSBaseRequest的属性</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)resultData&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> handleData:<span class="keyword">self</span>.resultDic];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对请求的回调数据进行深加工，JSON 转列表</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)handleData:(<span class="built_in">NSDictionary</span> *)dictionary&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *resultArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">if</span> ([dictionary count]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultDic = (<span class="built_in">NSDictionary</span> *)[[dictionary objectForKey:<span class="string">@"data"</span>] objectForKey:<span class="string">@"result"</span>];</span><br><span class="line">        [resultArray addObjectsFromArray:[HNTradeRecordModel mj_objectArrayWithKeyValuesArray:resultDic]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要一个模型数据，则会增加下面这些处理逻辑， 实现<code>LSBaseRequest</code>的<code>model</code>的获取方法 ，比如请求个人信息的 API ：</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id)model&#123;</span><br><span class="line">    <span class="keyword">return</span> [self <span class="string">handleData:</span>self.resultDic];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对请求的数据进行深加工，JSON 转模型</span></span><br><span class="line">- (HNUserModel *)<span class="string">handleData:</span>(NSDictionary *)dictionary&#123;</span><br><span class="line">    <span class="keyword">if</span> ([dictionary count]) &#123;</span><br><span class="line">        [[PMStore store]<span class="string">handleUserDictionary:</span>dictionary <span class="string">resiterJpush:</span>NO];</span><br><span class="line">        NSDictionary *dic = [[dictionary <span class="string">objectForKey:</span>@<span class="string">"data"</span>] <span class="string">objectForKey:</span>@<span class="string">"result"</span>];</span><br><span class="line">        HNUserModel *model = [HNUserModel <span class="string">mj_objectWithKeyValues:</span>dic];</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果没有额外的数据需求，则上面这些逻辑都不需要。</li></ul><h2 id="具体业务流程说明："><a href="#具体业务流程说明：" class="headerlink" title="具体业务流程说明："></a>具体业务流程说明：</h2><p>如果需要新增一个新的业务请求类：</p><ol><li>新建一个新的基于<code>LSBaseRequest</code>类</li><li>完成 API 类的基本配置，包括 URL 和请求方式的配置</li><li>如果 该 API 类有更多的数据处理需求，按照上面所写的方式来处理</li></ol><p>在 ViewController 或者 View 中初始化 API，一个实例如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadDataFromService&#123;</span><br><span class="line">    <span class="comment">// API 请求的参数</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dic = [[<span class="built_in">NSMutableDictionary</span> alloc]initWithDictionary:@&#123;<span class="string">@"offset"</span>:<span class="keyword">self</span>.offset,</span><br><span class="line">                                                                                <span class="string">@"limit"</span>:<span class="string">@"10"</span>&#125;];</span><br><span class="line">  <span class="comment">// 初始化 API 请求，传入需要的参数及状态信息</span></span><br><span class="line">    HNInquiryListAPI *request = [[HNInquiryListAPI alloc]initWithArgumentValueDictionary:dic isLogin:<span class="literal">YES</span> isRetAry:<span class="literal">YES</span> isRetObj:<span class="literal">NO</span>];</span><br><span class="line">    [request setSuccessArray:^(<span class="built_in">NSArray</span> *resultData) &#123;</span><br><span class="line">        <span class="comment">// 初始化的要求 API 能够对回调数据进行深加工——返回列表，所以这里直接设置列表的 block 回调处理逻辑。</span></span><br><span class="line">    &#125;];</span><br><span class="line">    [request setFailure:^(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">  <span class="comment">// 请求失败的回调</span></span><br><span class="line">    &#125;];</span><br><span class="line">    [request startRequest];  <span class="comment">// 发送请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是完整的网络层架构的说明及具体业务处理的流程。</p><h2 id="其他说明——图片及文件上传请求"><a href="#其他说明——图片及文件上传请求" class="headerlink" title="其他说明——图片及文件上传请求"></a>其他说明——图片及文件上传请求</h2><p>上传图片的 API 不同于其他的业务处理 API，它不需要处理一堆的业务逻辑，而且目前也不需要登录等状态，因此网络层将上传图片的 API 直接独立了出来，直接继承与<code>YTKRequest</code>。目前的图片 API 如下，已经封装完成，图片微服务不做大的重构，此 API 也不需要做修改：</p><p>声明：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;YTKRequest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HNUploadImageApi</span> : <span class="title">YTKRequest</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithImage:(<span class="built_in">NSArray</span> *)image;  <span class="comment">// 需要上传的图片文件数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> baseRequestArgument;  <span class="comment">// 请求的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现部分 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"HNUploadImageApi.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HNUploadImageApi</span></span>&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *_image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithImage:(<span class="built_in">NSArray</span> *)image &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _image = image;  <span class="comment">// 初始化图片数组的属性</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (YTKRequestMethod)requestMethod &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建请求参数</span></span><br><span class="line">- (<span class="keyword">void</span>)setBaseRequestArgument:(<span class="keyword">id</span>)baseRequestArgument&#123;</span><br><span class="line">    <span class="keyword">if</span> (baseRequestArgument) &#123;</span><br><span class="line">        _baseRequestArgument = baseRequestArgument;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)requestArgument &#123;</span><br><span class="line">    <span class="keyword">if</span> (_baseRequestArgument) &#123;</span><br><span class="line">        <span class="keyword">return</span> _baseRequestArgument;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</span><br><span class="line">    <span class="keyword">return</span> UploadImageAPI;  <span class="comment">// 上传 URL 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求的 body 的构造</span></span><br><span class="line">- (AFConstructingBlock)constructingBodyBlock &#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; _image.count; i++)&#123;</span><br><span class="line">            <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(_image[i], <span class="number">0.5</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">float</span>)data.length/<span class="number">1024</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                data = <span class="built_in">UIImageJPEGRepresentation</span>(_image[i], <span class="number">1024</span>*<span class="number">1000.0</span>/(<span class="keyword">float</span>)data.length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"image%d.png"</span>,i];</span><br><span class="line">            <span class="built_in">NSString</span> *type = <span class="string">@"image/jpeg"</span>;</span><br><span class="line">            [formData appendPartWithFileData:data name:<span class="string">@"image"</span> fileName:name mimeType:type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>具体构建及发送请求的流程如下，以上传头像为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HNUploadImageApi *api = [[HNUploadImageApi alloc] <span class="string">initWithImage:</span>@[scaleImage]]; <span class="comment">// 初始化请求，并传递需要上传的图片数组</span></span><br><span class="line">api.baseRequestArgument = @&#123;@<span class="string">"type"</span>:@<span class="string">"0"</span>&#125;;   <span class="comment">// 构造请求的参数</span></span><br><span class="line">[api <span class="string">startWithCompletionBlockWithSuccess:</span>^(YTKBaseRequest *request)&#123;</span><br><span class="line">    NSData *data = [request.responseString <span class="string">dataUsingEncoding:</span>NSUTF8StringEncoding];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        NSMutableDictionary *dic = [NSJSONSerialization <span class="string">JSONObjectWithData:</span>data <span class="string">options:</span>NSJSONReadingMutableContainers <span class="string">error:</span>nil];</span><br><span class="line">  <span class="comment">// 初次处理上传成功后的数据回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="string">failure:</span>^(YTKBaseRequest *request)&#123;</span><br><span class="line">    <span class="comment">// 上传失败后是回调</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-网络层文档&quot;&gt;&lt;a href=&quot;#iOS-网络层文档&quot; class=&quot;headerlink&quot; title=&quot;iOS 网络层文档&quot;&gt;&lt;/a&gt;iOS 网络层文档&lt;/h1&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;iOS 的网络层使用 &lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YTKNetwork&lt;/a&gt;作为网络层底层架构，在  &lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YTKNetwork&lt;/a&gt;的&lt;code&gt;YTKRequest&lt;/code&gt;类和具体的业务请求层之间架设了一个中间业务类&lt;code&gt;LSBaseRequest&lt;/code&gt;，所有具体的 API 请求都继承于此类。&lt;/p&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YTKNetwork&lt;/a&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;YTKNetwork主要用于请求的发送及回调处理，YTKNetwork 的基本的思想是把每一个网络请求封装成对象。使用 YTKNetwork，每一个请求都需要继承 YTKRequest 类，通过覆盖父类的一些方法来构造指定的网络请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里为了避免我们具体业务类的相关回调逻辑与 YTKNetwork 耦合过高，所以封装了&lt;code&gt;LSBaseRequest&lt;/code&gt;来处理请求回调的公共逻辑。&lt;/p&gt;
&lt;p&gt;下面来一一说明。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://suool.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://suool.net/tags/iOS/"/>
    
      <category term="组件文档" scheme="http://suool.net/tags/%E7%BB%84%E4%BB%B6%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://suool.net/2016/10/27/%E6%97%A0%E9%A2%98/"/>
    <id>http://suool.net/2016/10/27/无题/</id>
    <published>2016-10-27T02:20:49.000Z</published>
    <updated>2016-10-27T03:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道到底该取什么样的题目了, 就像打的标签一样, 想写的东西有点多, 取什么名字都有点不合适.</p><p>马克思说,人和动物的根本区别在于能够制造和利用工具. 确实是这样, 但是真正使得人类进步的却应该是mistake, 是不断的犯错, 不断的改正和积累, 才能不断的进化, 才成为人.<br><a id="more"></a></p><h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><p>可能是工作的原因, 对于无限循环这样的事情是有些恐惧的, 无限循环意味着你所做的的东西不能正常的结束, 同时对我而言陷入到无限的循环当中是一件非常恐怖的事情, 你无法决定自己什么时候能够真正走到正确的道路上, 也不知道何时能够选择正确的方向.</p><p>但是另一方面, 几年前读到的一本书, 里面说到这样的一段话:</p><blockquote><p>我们都在for循环，区别在于你是什么情况下break;的。有的人退出阈值高，这是能坚持的一类人，有的人退出阈值低，这类人很可能遇到一些障碍就退出了。过早退出的原因往往在于对于未来的不确定性，对于投资时间最终无法收到回报的恐惧，感受到的困难越大，这种恐惧越大，因为越大的困难往往暗示着这个任务需要投资的时间越大。所以其实我们都是直觉经济学家，当我们说“畏难”的时候，其实我们畏惧的不是困难本身，而是困难所暗示的时间经济学意义。</p></blockquote><blockquote><p>模仿高德纳先生的名言：过早退出是一切失败的根源。</p></blockquote><p>所以, 关于循环的思考到这里就出现了一些问题.</p><p>显然, 我需要纠正我对于循环的态度, 我得承认我现在对循环的态度和选择是错误的, 害怕循环其实根本上来说是自己不够自信, 不相信自己能够掌控循环的节奏和走向.</p><p>同时, 需要结合的一点是, 所有的事情都是和人关联在一起的. 所有的事情也不是孤立存在的, 都是有关联的.</p><p>所以, 对待事情的态度其实就对人的态度, 当选择解决问题的方式的时候, 要先思考一下这个问题对应的人是谁, 对应的位置在哪里, 对应的态度应该是什么, 最终的方式也就确定了.</p><p>而所谓循环也只是上面”事情”的一种特殊情况, 既然选择了这样的位置, 就要用对应的态度去面对, 不要急于顺着自己一时的反应的走, 要真正的成长就要真正的去思考.</p><h2 id="关于希望"><a href="#关于希望" class="headerlink" title="关于希望"></a>关于希望</h2><p>总是不断的有新的希望产生和旧的希望破灭, 也总有一些希望成为了现实, 这样才能不断向前走.</p><p>所谓的希望也都是面向未来的, 每个希望都是自己对未来的路的一种认识. 所以, 我说生活中充满了失望和绝望也挺好的, 起码可以消除很多自己给自己的不必要的期望和羁绊, 让脚下的路更加真实, 也让自己对未来的认识更加清晰.</p><p>所以, 希望本来就是一个不确定的事情, 没有成为现实也是一个完全可以理解的事情, 生活就是这样的残酷, 不能拿着自己的标准去要求所有人都按照你的方式来.</p><p>只需要记住, 概率上的事情, 失败是很显然和正常的.</p><p>只能说, 很可惜, 自己欠缺了一些思考, 没有能够选择一个正确的方式去面对, 徒劳后悔也是没用的事情.</p><p>不能说”如果”, 生活是不存在如果的. 做错了一件事就是做错了, 是不能抱着”挽回”这样的期望的, 这样的期望是妄想.</p><p>这个时候唯一的能抱有的希望也稚只能是, 希望生活再给你一次机会, 自己能够选择一个”正确而合适”的方式解决问题, 这也是人一直会变的原因, 也是使人进步的原因.</p><p>所以, 用发展的眼光看未来, 用不断变化的观念去看待一个人.</p><h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>多读书, 多思考.</p><p>不要急于做决定, 不要急于判断一个人, 一件事情.</p><p>要知道生活是没有”如果”的, 那么急做什么呢.</p><p>未来还是有很多希望的.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道到底该取什么样的题目了, 就像打的标签一样, 想写的东西有点多, 取什么名字都有点不合适.&lt;/p&gt;
&lt;p&gt;马克思说,人和动物的根本区别在于能够制造和利用工具. 确实是这样, 但是真正使得人类进步的却应该是mistake, 是不断的犯错, 不断的改正和积累, 才能不断的进化, 才成为人.&lt;br&gt;
    
    </summary>
    
      <category term="思考" scheme="http://suool.net/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="希望" scheme="http://suool.net/tags/%E5%B8%8C%E6%9C%9B/"/>
    
      <category term="未来" scheme="http://suool.net/tags/%E6%9C%AA%E6%9D%A5/"/>
    
      <category term="循环" scheme="http://suool.net/tags/%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>踏过所有的过往</title>
    <link href="http://suool.net/2016/10/02/%E8%B8%8F%E8%BF%87%E6%89%80%E6%9C%89%E7%9A%84%E8%BF%87%E5%BE%80/"/>
    <id>http://suool.net/2016/10/02/踏过所有的过往/</id>
    <published>2016-10-02T02:20:49.000Z</published>
    <updated>2016-11-06T01:26:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>睡到凌晨被噩梦惊醒。</p><p>这些日子又何曾不像处在梦魇，只是自己不愿醒来，不想对过去说再见。一直想着如果有假如那又会是怎样的一副光景，不敢去接受其实只有自己停留在过去的事实。所谓贱人就是矫情，没想过只要自己用心改变，未来不需要假如也能很好，何苦一直留恋从前呢？</p><p>是啊，何苦一直留恋从前，何苦为难自己也为难别人呢？应该只是觉得还有一丝希望还有一点机会就不想放弃。</p><p>一丝希望可以让你丢掉所有的尊严和骄傲，让你恨不得把自己埋在地底下去。一丝希望也能抵挡住无限的伤害。</p><p>但是，其实也只是一丝希望而已，总有耗尽的一天，总有被现实击穿的一天，没了就永远没了。</p><p>连这些都没了，还想要停留在过去吗？</p><p>是时候say goodbye了。</p><p>总要向前看，不然谁愿意跟着一个人停留在过去，谁想带着一个不敢相信未来的人闯荡呢？</p><p>或许生活总能继续，但是生命中总能感觉到死的诱惑。</p><p>我想彻底抹除出现在我身上的你的痕迹了。我的未来不会再有从前那个我，我也不会遇见曾经那个你。</p><p>嗯，噩梦也挺好的，起码让人不继续活在梦里。</p><p>这些日子，我丧失对生活的希望，怀疑自己的人生。不止一次的想着即使现在死掉和以后死掉没有什么区别。</p><p>这些都拜你所赐。</p><p>我应该永远都不会理解你的想法了，我想我该醒过来了，再不醒过来，恐怕我真的要死在这梦里，死在过去了。</p><p>你确实很坏。</p><p>我要踏过这所有的绝望和过往，我要走了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;睡到凌晨被噩梦惊醒。&lt;/p&gt;
&lt;p&gt;这些日子又何曾不像处在梦魇，只是自己不愿醒来，不想对过去说再见。一直想着如果有假如那又会是怎样的一副光景，不敢去接受其实只有自己停留在过去的事实。所谓贱人就是矫情，没想过只要自己用心改变，未来不需要假如也能很好，何苦一直留恋从前呢？&lt;/p
      
    
    </summary>
    
      <category term="思考" scheme="http://suool.net/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="希望" scheme="http://suool.net/tags/%E5%B8%8C%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://suool.net/2016/06/27/hello-world/"/>
    <id>http://suool.net/2016/06/27/hello-world/</id>
    <published>2016-06-27T06:25:40.000Z</published>
    <updated>2016-09-25T07:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="假如"><a href="#假如" class="headerlink" title="假如"></a>假如</h1><p>如果时光倒流，我能做什么？</p><p>这一辈子就这么长, 怎么过完全看你的选择了.<br><a id="more"></a></p><ul><li>2016-8-18</li></ul><p>最近愈发的感觉到绝望和无助, 感觉自己所想的很多东西都是自己的妄想. 连白日梦都算不得.</p><ul><li>2016-9-5</li></ul><p>感觉没必要存在这样一个博客, 对于表达自己已经彻底的失去了兴趣.</p><p>当前这个环境, 大家不会关注别人真正需要什么, 也对你在思考什么不感兴趣. 我们都是这个社会创造出来的程式罢了, 按照一些约定俗成的规则去行事, 按照所谓的主流来制定自己存在的逻辑.</p><p>所以, 表达自己什么的, 没有必要, 不想过多的去争辩什么了, 没意思.</p><p>就这样吧.</p><ul><li>2016-9-11</li></ul><p>心情低落到了极点, 也悲观到极点.</p><p>我现在深深的感觉到自己的幼稚和孩子气, 一直都想要找个人来依靠. 这就是我的心理吧.</p><p>凡人皆有一死, 纵然多活几十年, 无甚成就, 又有什么意思呢?</p><p>其实不是我对未来绝望, 而是我对自己绝望, 过了这么多年, 我依然是如此怯懦的本性.</p><p>性格真是一个难以改变的东西, 你能挣脱性格的限制, 那么是不是也挣脱了命运的掌控呢?</p><p>这些想法以及现在这些日子总是让我不经意的想起高中那段阴暗的人生.</p><ul><li>2016-9-25</li></ul><p>昨天为了看程璧的演唱会回了广州.</p><p>感觉程璧的现场真的很让人享受, 差不多是按着一曲中文一曲日语歌的节奏, 偶尔还会朗读几首小诗.</p><p>嗯, 感觉女孩子读诗的样子真的是美极了.</p><p>整个演唱会感觉很棒, 下次有机会肯定还要听.</p><p>而且一定要去次好妹妹的.</p><p>今天回到了学校, 借了行志的饭卡混进了图书馆, 写了一天代码……</p><p>中午还和一个老朋友弘毅一起吃了饭, 聊了很多东西.</p><p>图书馆真是一个学习的好地方啊, 可惜来的机会太少了.</p><p>以后有机会一定要常回来~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;假如&quot;&gt;&lt;a href=&quot;#假如&quot; class=&quot;headerlink&quot; title=&quot;假如&quot;&gt;&lt;/a&gt;假如&lt;/h1&gt;&lt;p&gt;如果时光倒流，我能做什么？&lt;/p&gt;
&lt;p&gt;这一辈子就这么长, 怎么过完全看你的选择了.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
